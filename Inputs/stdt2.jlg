abstract type Core.AbstractArray{T, N} end  [typ @ Core.AbstractArray]
abstract type Core.AbstractChar end  [typ @ Core.AbstractChar]
abstract type Core.AbstractFloat <: Core.Real end  [typ @ Core.AbstractFloat]
abstract type Core.AbstractString end  [typ @ Core.AbstractString]
abstract type Core.Any end  [typ @ Core.Any]
struct Core.Argument end  [typ @ Core.Argument]
struct Core.ArgumentError <: Core.Exception end  [typ @ Core.ArgumentError]
mutable struct Core.Array{T, N} <: Core.DenseArray{T, N} end  [typ @ Core.Array]
struct Core.AssertionError <: Core.Exception end  [typ @ Core.AssertionError]
primitive type Core.Bool <: Core.Integer 8 end  [typ @ Core.Bool]
struct Core.BoundsError <: Core.Exception end  [typ @ Core.BoundsError]
mutable struct Core.Box end  [typ @ Core.Box]
const Core.BuiltinInts = Union{Core.Bool, Core.Int32, Core.Int64, Core.UInt32, Core.UInt64, Core.UInt8, Core.Int128, Core.Int16, Core.Int8, Core.UInt128, Core.UInt16}  [alias @ Core.BuiltinInts]
primitive type Core.Char <: Core.AbstractChar 32 end  [typ @ Core.Char]
mutable struct Core.CodeInfo end  [typ @ Core.CodeInfo]
mutable struct Core.CodeInstance end  [typ @ Core.CodeInstance]
const Core.Compiler.=> = Core.Pair  [alias @ Core.Compiler.=>]
abstract type Core.Compiler.AbstractDict{K, V} end  [typ @ Core.Compiler.AbstractDict]
abstract type Core.Compiler.AbstractInterpreter end  [typ @ Core.Compiler.AbstractInterpreter]
struct Core.Compiler.AbstractIterationInfo end  [typ @ Core.Compiler.AbstractIterationInfo]
const Core.Compiler.AbstractMatrix = Core.AbstractArray{T, 2} where T  [alias @ Core.Compiler.AbstractMatrix]
abstract type Core.Compiler.AbstractRange{T} <: Core.AbstractArray{T, 1} end  [typ @ Core.Compiler.AbstractRange]
abstract type Core.Compiler.AbstractSet{T} end  [typ @ Core.Compiler.AbstractSet]
abstract type Core.Compiler.AbstractUnitRange{T} <: Core.Compiler.OrdinalRange{T, T} end  [typ @ Core.Compiler.AbstractUnitRange]
const Core.Compiler.AbstractVecOrMat = Union{Core.AbstractArray{T, 1}, Core.AbstractArray{T, 2}} where T  [alias @ Core.Compiler.AbstractVecOrMat]
const Core.Compiler.AbstractVecOrTuple = Union{Tuple{Vararg{T}}, Base.AbstractVector{<:T}} where T  [alias @ Core.Compiler.AbstractVecOrTuple]
const Core.Compiler.AbstractVector = Core.AbstractArray{T, 1} where T  [alias @ Core.Compiler.AbstractVector]
const Core.Compiler.All32 = Tuple{T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, Vararg{T, N}} where {T, N}  [alias @ Core.Compiler.All32]
const Core.Compiler.Any32 = Tuple{Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Vararg{Core.Any, N}} where N  [alias @ Core.Compiler.Any32]
const Core.Compiler.AnyConditional = Union{Core.Compiler.Conditional, Core.InterConditional}  [alias @ Core.Compiler.AnyConditional]
const Core.Compiler.AnySSAValue = Union{Core.Compiler.NewSSAValue, Core.Compiler.OldSSAValue, Core.SSAValue}  [alias @ Core.Compiler.AnySSAValue]
struct Core.Compiler.ApplyCallInfo end  [typ @ Core.Compiler.ApplyCallInfo]
const Core.Compiler.ArgEscapeCache = Core.Compiler.EscapeAnalysis.ArgEscapeCache  [alias @ Core.Compiler.ArgEscapeCache]
struct Core.Compiler.ArgInfo end  [typ @ Core.Compiler.ArgInfo]
struct Core.Compiler.ArithmeticRounds <: Core.Compiler.ArithmeticStyle end  [typ @ Core.Compiler.ArithmeticRounds]
abstract type Core.Compiler.ArithmeticStyle end  [typ @ Core.Compiler.ArithmeticStyle]
struct Core.Compiler.ArithmeticUnknown <: Core.Compiler.ArithmeticStyle end  [typ @ Core.Compiler.ArithmeticUnknown]
struct Core.Compiler.ArithmeticWraps <: Core.Compiler.ArithmeticStyle end  [typ @ Core.Compiler.ArithmeticWraps]
struct Core.Compiler.BBIdxIter end  [typ @ Core.Compiler.BBIdxIter]
const Core.Compiler.BBNumber = Core.Int64  [alias @ Core.Compiler.BBNumber]
struct Core.Compiler.BasicBlock end  [typ @ Core.Compiler.BasicBlock]
mutable struct Core.Compiler.BitArray{N} <: Core.AbstractArray{Bool, N} end  [typ @ Core.Compiler.BitArray]
const Core.Compiler.BitInteger = Union{Core.Int128, Core.Int16, Core.Int32, Core.Int64, Core.Int8, Core.UInt128, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Core.Compiler.BitInteger]
const Core.Compiler.BitInteger32 = Union{Core.Int16, Core.Int32, Core.Int8, Core.UInt16, Core.UInt32, Core.UInt8}  [alias @ Core.Compiler.BitInteger32]
const Core.Compiler.BitInteger64 = Union{Core.Int16, Core.Int32, Core.Int64, Core.Int8, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Core.Compiler.BitInteger64]
const Core.Compiler.BitIntegerArray = Union{Core.Array{Core.Int128, N}, Core.Array{Core.Int16, N}, Core.Array{Core.Int32, N}, Core.Array{Core.Int64, N}, Core.Array{Core.Int8, N}, Core.Array{Core.UInt128, N}, Core.Array{Core.UInt16, N}, Core.Array{Core.UInt32, N}, Core.Array{Core.UInt64, N}, Core.Array{Core.UInt8, N}} where N  [alias @ Core.Compiler.BitIntegerArray]
const Core.Compiler.BitIntegerSmall = Union{Core.Int16, Core.Int32, Core.Int8, Core.UInt16, Core.UInt32, Core.UInt8}  [alias @ Core.Compiler.BitIntegerSmall]
const Core.Compiler.BitIntegerType = Union{Core.Type{Core.Int128}, Core.Type{Core.Int16}, Core.Type{Core.Int32}, Core.Type{Core.Int64}, Core.Type{Core.Int8}, Core.Type{Core.UInt128}, Core.Type{Core.UInt16}, Core.Type{Core.UInt32}, Core.Type{Core.UInt64}, Core.Type{Core.UInt8}}  [alias @ Core.Compiler.BitIntegerType]
const Core.Compiler.BitMatrix = Core.Compiler.BitArray{2}  [alias @ Core.Compiler.BitMatrix]
mutable struct Core.Compiler.BitSet <: Core.Compiler.AbstractSet{Int64} end  [typ @ Core.Compiler.BitSet]
const Core.Compiler.BitSigned = Union{Core.Int128, Core.Int16, Core.Int32, Core.Int64, Core.Int8}  [alias @ Core.Compiler.BitSigned]
const Core.Compiler.BitSigned32 = Union{Core.Int16, Core.Int32, Core.Int8}  [alias @ Core.Compiler.BitSigned32]
const Core.Compiler.BitSigned64 = Union{Core.Int16, Core.Int32, Core.Int64, Core.Int8}  [alias @ Core.Compiler.BitSigned64]
const Core.Compiler.BitSigned64T = Union{Core.Type{Core.Int16}, Core.Type{Core.Int32}, Core.Type{Core.Int64}, Core.Type{Core.Int8}}  [alias @ Core.Compiler.BitSigned64T]
const Core.Compiler.BitSignedSmall = Union{Core.Int16, Core.Int32, Core.Int8}  [alias @ Core.Compiler.BitSignedSmall]
const Core.Compiler.BitUnsigned = Union{Core.UInt128, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Core.Compiler.BitUnsigned]
const Core.Compiler.BitUnsigned32 = Union{Core.UInt16, Core.UInt32, Core.UInt8}  [alias @ Core.Compiler.BitUnsigned32]
const Core.Compiler.BitUnsigned64 = Union{Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Core.Compiler.BitUnsigned64]
const Core.Compiler.BitUnsigned64T = Union{Core.Type{Core.UInt16}, Core.Type{Core.UInt32}, Core.Type{Core.UInt64}, Core.Type{Core.UInt8}}  [alias @ Core.Compiler.BitUnsigned64T]
const Core.Compiler.BitUnsignedSmall = Union{Core.UInt16, Core.UInt32, Core.UInt8}  [alias @ Core.Compiler.BitUnsignedSmall]
const Core.Compiler.BitVector = Core.Compiler.BitArray{1}  [alias @ Core.Compiler.BitVector]
const Core.Compiler.Bits = Core.Array{Core.UInt64, 1}  [alias @ Core.Compiler.Bits]
struct Core.Compiler.BlockLiveness end  [typ @ Core.Compiler.BlockLiveness]
struct Core.Compiler.CFG end  [typ @ Core.Compiler.CFG]
mutable struct Core.Compiler.CFGInliningState end  [typ @ Core.Compiler.CFGInliningState]
struct Core.Compiler.CachedMethodTable{T} <: Core.Compiler.MethodTableView end  [typ @ Core.Compiler.CachedMethodTable]
struct Core.Compiler.CallMeta end  [typ @ Core.Compiler.CallMeta]
const Core.Compiler.Callable = Union{Core.Function, Core.Type}  [alias @ Core.Compiler.Callable]
struct Core.Compiler.CanonicalIndexError <: Core.Exception end  [typ @ Core.Compiler.CanonicalIndexError]
const Core.Compiler.Cdouble = Core.Float64  [alias @ Core.Compiler.Cdouble]
const Core.Compiler.Cfloat = Core.Float32  [alias @ Core.Compiler.Cfloat]
const Core.Compiler.Cint = Core.Int32  [alias @ Core.Compiler.Cint]
const Core.Compiler.Cintmax_t = Core.Int64  [alias @ Core.Compiler.Cintmax_t]
const Core.Compiler.Clonglong = Core.Int64  [alias @ Core.Compiler.Clonglong]
const Core.Compiler.CodeInstance = Core.CodeInstance  [alias @ Core.Compiler.CodeInstance]
struct Core.Compiler.CodegenParams end  [typ @ Core.Compiler.CodegenParams]
struct Core.Compiler.CompactPeekIterator end  [typ @ Core.Compiler.CompactPeekIterator]
const Core.Compiler.CompilerTypes = Union{Core.Compiler.NotFound, Core.Compiler.Conditional, Core.Compiler.MaybeUndef, Core.Const, Core.PartialStruct}  [alias @ Core.Compiler.CompilerTypes]
struct Core.Compiler.Conditional end  [typ @ Core.Compiler.Conditional]
const Core.Compiler.Const = Core.Const  [alias @ Core.Compiler.Const]
struct Core.Compiler.ConstAPI end  [typ @ Core.Compiler.ConstAPI]
struct Core.Compiler.ConstCallInfo end  [typ @ Core.Compiler.ConstCallInfo]
struct Core.Compiler.ConstCallResults end  [typ @ Core.Compiler.ConstCallResults]
struct Core.Compiler.ConstResult end  [typ @ Core.Compiler.ConstResult]
struct Core.Compiler.ConstantCase end  [typ @ Core.Compiler.ConstantCase]
const Core.Compiler.CoreDocs.Csize_t = Core.UInt64  [alias @ Core.Compiler.CoreDocs.Csize_t]
const Core.Compiler.Cptrdiff_t = Core.Int64  [alias @ Core.Compiler.Cptrdiff_t]
const Core.Compiler.Cshort = Core.Int16  [alias @ Core.Compiler.Cshort]
const Core.Compiler.Csize_t = Core.UInt64  [alias @ Core.Compiler.Csize_t]
const Core.Compiler.Cssize_t = Core.Int64  [alias @ Core.Compiler.Cssize_t]
const Core.Compiler.Cuchar = Core.UInt8  [alias @ Core.Compiler.Cuchar]
const Core.Compiler.Cuint = Core.UInt32  [alias @ Core.Compiler.Cuint]
const Core.Compiler.Cuintmax_t = Core.UInt64  [alias @ Core.Compiler.Cuintmax_t]
const Core.Compiler.Culonglong = Core.UInt64  [alias @ Core.Compiler.Culonglong]
const Core.Compiler.Cushort = Core.UInt16  [alias @ Core.Compiler.Cushort]
struct Core.Compiler.DFSTree end  [typ @ Core.Compiler.DFSTree]
struct Core.Compiler.DataTypeFieldDesc end  [typ @ Core.Compiler.DataTypeFieldDesc]
struct Core.Compiler.DataTypeLayout end  [typ @ Core.Compiler.DataTypeLayout]
struct Core.Compiler.DelayedInliningSpec end  [typ @ Core.Compiler.DelayedInliningSpec]
struct Core.Compiler.DelayedTyp end  [typ @ Core.Compiler.DelayedTyp]
const Core.Compiler.DenseMatrix = Core.DenseArray{T, 2} where T  [alias @ Core.Compiler.DenseMatrix]
const Core.Compiler.DenseVecOrMat = Union{Core.DenseArray{T, 1}, Core.DenseArray{T, 2}} where T  [alias @ Core.Compiler.DenseVecOrMat]
const Core.Compiler.DenseVector = Core.DenseArray{T, 1} where T  [alias @ Core.Compiler.DenseVector]
const Core.Compiler.DimOrInd = Union{Core.Integer, Core.Compiler.AbstractUnitRange}  [alias @ Core.Compiler.DimOrInd]
struct Core.Compiler.DimensionMismatch <: Core.Exception end  [typ @ Core.Compiler.DimensionMismatch]
const Core.Compiler.Dims = Tuple{Vararg{Core.Int64, N}} where N  [alias @ Core.Compiler.Dims]
const Core.Compiler.DimsInteger = Tuple{Vararg{Core.Integer, N}} where N  [alias @ Core.Compiler.DimsInteger]
const Core.Compiler.DimsOrInds = Tuple{Vararg{Union{Core.Integer, Core.Compiler.AbstractUnitRange}, N}} where N  [alias @ Core.Compiler.DimsOrInds]
struct Core.Compiler.DomTree end  [typ @ Core.Compiler.DomTree]
struct Core.Compiler.DomTreeNode end  [typ @ Core.Compiler.DomTreeNode]
struct Core.Compiler.DominatedBlocks end  [typ @ Core.Compiler.DominatedBlocks]
struct Core.Compiler.EdgeTracker end  [typ @ Core.Compiler.EdgeTracker]
struct Core.Compiler.Effects end  [typ @ Core.Compiler.Effects]
struct Core.Compiler.EffectsOverride end  [typ @ Core.Compiler.EffectsOverride]
struct Core.Compiler.EltypeUnknown <: Core.Compiler.IteratorEltype end  [typ @ Core.Compiler.EltypeUnknown]
const Core.Compiler.EscapeAnalysis.=> = Core.Pair  [alias @ Core.Compiler.EscapeAnalysis.=>]
const Core.Compiler.EscapeAnalysis.AInfo = Core.Compiler.IdSet{Core.Any}  [alias @ Core.Compiler.EscapeAnalysis.AInfo]
struct Core.Compiler.EscapeAnalysis.AliasChange <: Core.Compiler.EscapeAnalysis.Change end  [typ @ Core.Compiler.EscapeAnalysis.AliasChange]
const Core.Compiler.EscapeAnalysis.AliasSet = Core.Compiler.EscapeAnalysis.IntDisjointSet{Core.Int64}  [alias @ Core.Compiler.EscapeAnalysis.AliasSet]
struct Core.Compiler.EscapeAnalysis.AnalysisState{T<:Union{Core.Function, Core.Type}} end  [typ @ Core.Compiler.EscapeAnalysis.AnalysisState]
struct Core.Compiler.EscapeAnalysis.ArgAliasChange <: Core.Compiler.EscapeAnalysis.Change end  [typ @ Core.Compiler.EscapeAnalysis.ArgAliasChange]
struct Core.Compiler.EscapeAnalysis.ArgAliasing end  [typ @ Core.Compiler.EscapeAnalysis.ArgAliasing]
struct Core.Compiler.EscapeAnalysis.ArgEscapeCache end  [typ @ Core.Compiler.EscapeAnalysis.ArgEscapeCache]
struct Core.Compiler.EscapeAnalysis.ArgEscapeInfo end  [typ @ Core.Compiler.EscapeAnalysis.ArgEscapeInfo]
const Core.Compiler.EscapeAnalysis.Argument = Core.Argument  [alias @ Core.Compiler.EscapeAnalysis.Argument]
const Core.Compiler.EscapeAnalysis.ArrayInfo = Core.Compiler.IdDict{Core.Int64, Base.Vector{Core.Int64}}  [alias @ Core.Compiler.EscapeAnalysis.ArrayInfo]
const Core.Compiler.EscapeAnalysis.BitSet = Core.Compiler.BitSet  [alias @ Core.Compiler.EscapeAnalysis.BitSet]
struct Core.Compiler.EscapeAnalysis.CallInfo end  [typ @ Core.Compiler.EscapeAnalysis.CallInfo]
const Core.Compiler.EscapeAnalysis.Callable = Union{Core.Function, Core.Type}  [alias @ Core.Compiler.EscapeAnalysis.Callable]
abstract type Core.Compiler.EscapeAnalysis.Change end  [typ @ Core.Compiler.EscapeAnalysis.Change]
const Core.Compiler.EscapeAnalysis.Changes = Core.Array{Core.Compiler.EscapeAnalysis.Change, 1}  [alias @ Core.Compiler.EscapeAnalysis.Changes]
const Core.Compiler.EscapeAnalysis.CodeInstance = Core.CodeInstance  [alias @ Core.Compiler.EscapeAnalysis.CodeInstance]
const Core.Compiler.EscapeAnalysis.Const = Core.Const  [alias @ Core.Compiler.EscapeAnalysis.Const]
const Core.Compiler.EscapeAnalysis.ConstCallInfo = Core.Compiler.ConstCallInfo  [alias @ Core.Compiler.EscapeAnalysis.ConstCallInfo]
const Core.Compiler.EscapeAnalysis.ConstResult = Core.Compiler.ConstResult  [alias @ Core.Compiler.EscapeAnalysis.ConstResult]
const Core.Compiler.EscapeAnalysis.Csize_t = Core.UInt64  [alias @ Core.Compiler.EscapeAnalysis.Csize_t]
struct Core.Compiler.EscapeAnalysis.EscapeChange <: Core.Compiler.EscapeAnalysis.Change end  [typ @ Core.Compiler.EscapeAnalysis.EscapeChange]
struct Core.Compiler.EscapeAnalysis.EscapeInfo end  [typ @ Core.Compiler.EscapeAnalysis.EscapeInfo]
struct Core.Compiler.EscapeAnalysis.EscapeState end  [typ @ Core.Compiler.EscapeAnalysis.EscapeState]
const Core.Compiler.EscapeAnalysis.GotoIfNot = Core.GotoIfNot  [alias @ Core.Compiler.EscapeAnalysis.GotoIfNot]
const Core.Compiler.EscapeAnalysis.GotoNode = Core.GotoNode  [alias @ Core.Compiler.EscapeAnalysis.GotoNode]
const Core.Compiler.EscapeAnalysis.IRCode = Core.Compiler.IRCode  [alias @ Core.Compiler.EscapeAnalysis.IRCode]
const Core.Compiler.EscapeAnalysis.IdDict = Core.Compiler.IdDict  [alias @ Core.Compiler.EscapeAnalysis.IdDict]
const Core.Compiler.EscapeAnalysis.IdSet = Core.Compiler.IdSet  [alias @ Core.Compiler.EscapeAnalysis.IdSet]
struct Core.Compiler.EscapeAnalysis.IndexableElements end  [typ @ Core.Compiler.EscapeAnalysis.IndexableElements]
struct Core.Compiler.EscapeAnalysis.IndexableFields end  [typ @ Core.Compiler.EscapeAnalysis.IndexableFields]
const Core.Compiler.EscapeAnalysis.InferenceResult = Core.Compiler.InferenceResult  [alias @ Core.Compiler.EscapeAnalysis.InferenceResult]
mutable struct Core.Compiler.EscapeAnalysis.IntDisjointSet{T<:Core.Integer} end  [typ @ Core.Compiler.EscapeAnalysis.IntDisjointSet]
const Core.Compiler.EscapeAnalysis.InvokeCallInfo = Core.Compiler.InvokeCallInfo  [alias @ Core.Compiler.EscapeAnalysis.InvokeCallInfo]
const Core.Compiler.EscapeAnalysis.Linfo = Union{Core.Compiler.InferenceResult, Core.MethodInstance}  [alias @ Core.Compiler.EscapeAnalysis.Linfo]
struct Core.Compiler.EscapeAnalysis.LivenessChange <: Core.Compiler.EscapeAnalysis.Change end  [typ @ Core.Compiler.EscapeAnalysis.LivenessChange]
const Core.Compiler.EscapeAnalysis.LivenessSet = Core.Compiler.BitSet  [alias @ Core.Compiler.EscapeAnalysis.LivenessSet]
struct Core.Compiler.EscapeAnalysis.LocalDef end  [typ @ Core.Compiler.EscapeAnalysis.LocalDef]
struct Core.Compiler.EscapeAnalysis.LocalUse end  [typ @ Core.Compiler.EscapeAnalysis.LocalUse]
const Core.Compiler.EscapeAnalysis.MethodInstance = Core.MethodInstance  [alias @ Core.Compiler.EscapeAnalysis.MethodInstance]
const Core.Compiler.EscapeAnalysis.MethodMatch = Core.MethodMatch  [alias @ Core.Compiler.EscapeAnalysis.MethodMatch]
const Core.Compiler.EscapeAnalysis.MethodMatchInfo = Core.Compiler.MethodMatchInfo  [alias @ Core.Compiler.EscapeAnalysis.MethodMatchInfo]
const Core.Compiler.EscapeAnalysis.MethodResultPure = Core.Compiler.MethodResultPure  [alias @ Core.Compiler.EscapeAnalysis.MethodResultPure]
const Core.Compiler.EscapeAnalysis.OneTo = Core.Compiler.OneTo  [alias @ Core.Compiler.EscapeAnalysis.OneTo]
const Core.Compiler.EscapeAnalysis.PhiCNode = Core.PhiCNode  [alias @ Core.Compiler.EscapeAnalysis.PhiCNode]
const Core.Compiler.EscapeAnalysis.PhiNode = Core.PhiNode  [alias @ Core.Compiler.EscapeAnalysis.PhiNode]
const Core.Compiler.EscapeAnalysis.PiNode = Core.PiNode  [alias @ Core.Compiler.EscapeAnalysis.PiNode]
const Core.Compiler.EscapeAnalysis.ReturnNode = Core.ReturnNode  [alias @ Core.Compiler.EscapeAnalysis.ReturnNode]
const Core.Compiler.EscapeAnalysis.SSAValue = Core.SSAValue  [alias @ Core.Compiler.EscapeAnalysis.SSAValue]
const Core.Compiler.EscapeAnalysis.Signature = Core.Compiler.Signature  [alias @ Core.Compiler.EscapeAnalysis.Signature]
const Core.Compiler.EscapeAnalysis.SimpleVector = Core.SimpleVector  [alias @ Core.Compiler.EscapeAnalysis.SimpleVector]
struct Core.Compiler.EscapeAnalysis.Unindexable end  [typ @ Core.Compiler.EscapeAnalysis.Unindexable]
const Core.Compiler.EscapeAnalysis.UnionSplitInfo = Core.Compiler.UnionSplitInfo  [alias @ Core.Compiler.EscapeAnalysis.UnionSplitInfo]
const Core.Compiler.EscapeAnalysis.UnitRange = Core.Compiler.UnitRange  [alias @ Core.Compiler.EscapeAnalysis.UnitRange]
const Core.Compiler.EscapeAnalysis.UpsilonNode = Core.UpsilonNode  [alias @ Core.Compiler.EscapeAnalysis.UpsilonNode]
const Core.Compiler.EscapeAnalysis.Vector = Core.Array{T, 1} where T  [alias @ Core.Compiler.EscapeAnalysis.Vector]
const Core.Compiler.EscapeState = Core.Compiler.EscapeAnalysis.EscapeState  [alias @ Core.Compiler.EscapeState]
struct Core.Compiler.ExceptionStack <: Core.AbstractArray{Any, 1} end  [typ @ Core.Compiler.ExceptionStack]
struct Core.Compiler.ExponentialBackOff end  [typ @ Core.Compiler.ExponentialBackOff]
struct Core.Compiler.FailedMethodMatch end  [typ @ Core.Compiler.FailedMethodMatch]
struct Core.Compiler.FieldDesc end  [typ @ Core.Compiler.FieldDesc]
struct Core.Compiler.FieldDescStorage{T} end  [typ @ Core.Compiler.FieldDescStorage]
struct Core.Compiler.Generator{I, F} end  [typ @ Core.Compiler.Generator]
struct Core.Compiler.HasEltype <: Core.Compiler.IteratorEltype end  [typ @ Core.Compiler.HasEltype]
struct Core.Compiler.HasLength <: Core.Compiler.IteratorSize end  [typ @ Core.Compiler.HasLength]
struct Core.Compiler.HasShape{N} <: Core.Compiler.IteratorSize end  [typ @ Core.Compiler.HasShape]
struct Core.Compiler.IRCode end  [typ @ Core.Compiler.IRCode]
mutable struct Core.Compiler.IdDict{K, V} <: Core.Compiler.AbstractDict{K, V} end  [typ @ Core.Compiler.IdDict]
mutable struct Core.Compiler.IdSet{T} <: Core.Compiler.AbstractSet{T} end  [typ @ Core.Compiler.IdSet]
struct Core.Compiler.IdentityUnitRange{T<:Core.Compiler.AbstractUnitRange} <: Core.Compiler.AbstractUnitRange{Int64} end  [typ @ Core.Compiler.IdentityUnitRange]
mutable struct Core.Compiler.IncrementalCompact end  [typ @ Core.Compiler.IncrementalCompact]
struct Core.Compiler.IndexCartesian <: Core.Compiler.IndexStyle end  [typ @ Core.Compiler.IndexCartesian]
struct Core.Compiler.IndexLinear <: Core.Compiler.IndexStyle end  [typ @ Core.Compiler.IndexLinear]
abstract type Core.Compiler.IndexStyle end  [typ @ Core.Compiler.IndexStyle]
const Core.Compiler.Indices = Tuple{Vararg{Core.Compiler.AbstractUnitRange, N}} where N  [alias @ Core.Compiler.Indices]
struct Core.Compiler.InfStackUnwind end  [typ @ Core.Compiler.InfStackUnwind]
struct Core.Compiler.InferenceParams end  [typ @ Core.Compiler.InferenceParams]
mutable struct Core.Compiler.InferenceResult end  [typ @ Core.Compiler.InferenceResult]
mutable struct Core.Compiler.InferenceState end  [typ @ Core.Compiler.InferenceState]
struct Core.Compiler.InliningCase end  [typ @ Core.Compiler.InliningCase]
struct Core.Compiler.InliningState{S<:Union{Core.Nothing, Core.Compiler.EdgeTracker}, MICache, I<:Core.Compiler.AbstractInterpreter} end  [typ @ Core.Compiler.InliningState]
struct Core.Compiler.InliningTodo end  [typ @ Core.Compiler.InliningTodo]
struct Core.Compiler.Instruction end  [typ @ Core.Compiler.Instruction]
struct Core.Compiler.InstructionStream end  [typ @ Core.Compiler.InstructionStream]
const Core.Compiler.IntOrInd = Union{Core.Int64, Core.Compiler.AbstractUnitRange}  [alias @ Core.Compiler.IntOrInd]
const Core.Compiler.InterConditional = Core.InterConditional  [alias @ Core.Compiler.InterConditional]
struct Core.Compiler.InternalCodeCache end  [typ @ Core.Compiler.InternalCodeCache]
struct Core.Compiler.InternalMethodTable <: Core.Compiler.MethodTableView end  [typ @ Core.Compiler.InternalMethodTable]
struct Core.Compiler.InterpreterIP end  [typ @ Core.Compiler.InterpreterIP]
struct Core.Compiler.InvalidCodeError <: Core.Exception end  [typ @ Core.Compiler.InvalidCodeError]
struct Core.Compiler.InvokeCall end  [typ @ Core.Compiler.InvokeCall]
struct Core.Compiler.InvokeCallInfo end  [typ @ Core.Compiler.InvokeCallInfo]
struct Core.Compiler.InvokeCase end  [typ @ Core.Compiler.InvokeCase]
struct Core.Compiler.IsInfinite <: Core.Compiler.IteratorSize end  [typ @ Core.Compiler.IsInfinite]
abstract type Core.Compiler.IteratorEltype end  [typ @ Core.Compiler.IteratorEltype]
abstract type Core.Compiler.IteratorSize end  [typ @ Core.Compiler.IteratorSize]
struct Core.Compiler.Iterators.Accumulate{F, I, T} end  [typ @ Core.Compiler.Iterators.Accumulate]
struct Core.Compiler.Iterators.Count{T, S} end  [typ @ Core.Compiler.Iterators.Count]
struct Core.Compiler.Iterators.Cycle{I} end  [typ @ Core.Compiler.Iterators.Cycle]
struct Core.Compiler.Iterators.Drop{I} end  [typ @ Core.Compiler.Iterators.Drop]
struct Core.Compiler.Iterators.DropWhile{I, P<:Core.Function} end  [typ @ Core.Compiler.Iterators.DropWhile]
struct Core.Compiler.Iterators.Enumerate{I} end  [typ @ Core.Compiler.Iterators.Enumerate]
struct Core.Compiler.Iterators.Filter{F, I} end  [typ @ Core.Compiler.Iterators.Filter]
struct Core.Compiler.Iterators.Flatten{I} end  [typ @ Core.Compiler.Iterators.Flatten]
struct Core.Compiler.Iterators.IterationCutShort end  [typ @ Core.Compiler.Iterators.IterationCutShort]
const Core.Compiler.Iterators.IteratorEltype = Core.Compiler.IteratorEltype  [alias @ Core.Compiler.Iterators.IteratorEltype]
const Core.Compiler.Iterators.IteratorSize = Core.Compiler.IteratorSize  [alias @ Core.Compiler.Iterators.IteratorSize]
struct Core.Compiler.Iterators.PartitionIterator{T} end  [typ @ Core.Compiler.Iterators.PartitionIterator]
struct Core.Compiler.Iterators.ProductIterator{T<:Core.Tuple} end  [typ @ Core.Compiler.Iterators.ProductIterator]
struct Core.Compiler.Iterators.Repeated{O} end  [typ @ Core.Compiler.Iterators.Repeated]
struct Core.Compiler.Iterators.Rest{I, S} end  [typ @ Core.Compiler.Iterators.Rest]
struct Core.Compiler.Iterators.Reverse{T} end  [typ @ Core.Compiler.Iterators.Reverse]
mutable struct Core.Compiler.Iterators.Stateful{T, VS} end  [typ @ Core.Compiler.Iterators.Stateful]
struct Core.Compiler.Iterators.Take{I} end  [typ @ Core.Compiler.Iterators.Take]
struct Core.Compiler.Iterators.TakeWhile{I, P<:Core.Function} end  [typ @ Core.Compiler.Iterators.TakeWhile]
struct Core.Compiler.Iterators.Zip{Is<:Core.Tuple} end  [typ @ Core.Compiler.Iterators.Zip]
struct Core.Compiler.JLOptions end  [typ @ Core.Compiler.JLOptions]
struct Core.Compiler.KeyError <: Core.Exception end  [typ @ Core.Compiler.KeyError]
struct Core.Compiler.KeySet{K, T<:(Core.Compiler.AbstractDict{K})} <: Core.Compiler.AbstractSet{K} end  [typ @ Core.Compiler.KeySet]
mutable struct Core.Compiler.LazyString <: Core.AbstractString end  [typ @ Core.Compiler.LazyString]
const Core.Compiler.LiftedLeaves = Core.Compiler.IdDict{Core.Any, Union{Core.Nothing, Core.Compiler.LiftedValue}}  [alias @ Core.Compiler.LiftedLeaves]
struct Core.Compiler.LiftedPhi end  [typ @ Core.Compiler.LiftedPhi]
struct Core.Compiler.LiftedValue end  [typ @ Core.Compiler.LiftedValue]
struct Core.Compiler.LimitedAccuracy end  [typ @ Core.Compiler.LimitedAccuracy]
struct Core.Compiler.LinRange{T, L<:Core.Integer} <: Core.Compiler.AbstractRange{T} end  [typ @ Core.Compiler.LinRange]
const Core.Compiler.LineNum = Core.Int64  [alias @ Core.Compiler.LineNum]
struct Core.Compiler.LinearIndices{N, R<:Tuple{Vararg{Core.Compiler.AbstractUnitRange{Core.Int64}, N}}} <: Core.AbstractArray{Int64, N} end  [typ @ Core.Compiler.LinearIndices]
const Core.Compiler.Matrix = Core.Array{T, 2} where T  [alias @ Core.Compiler.Matrix]
const Core.Compiler.MaybeAbstractIterationInfo = Union{Core.Nothing, Core.Compiler.AbstractIterationInfo}  [alias @ Core.Compiler.MaybeAbstractIterationInfo]
struct Core.Compiler.MaybeUndef end  [typ @ Core.Compiler.MaybeUndef]
struct Core.Compiler.MethodCallResult end  [typ @ Core.Compiler.MethodCallResult]
const Core.Compiler.MethodInstance = Core.MethodInstance  [alias @ Core.Compiler.MethodInstance]
mutable struct Core.Compiler.MethodList <: Core.AbstractArray{Method, 1} end  [typ @ Core.Compiler.MethodList]
struct Core.Compiler.MethodLookupResult end  [typ @ Core.Compiler.MethodLookupResult]
const Core.Compiler.MethodMatch = Core.MethodMatch  [alias @ Core.Compiler.MethodMatch]
struct Core.Compiler.MethodMatchInfo end  [typ @ Core.Compiler.MethodMatchInfo]
struct Core.Compiler.MethodMatchKey end  [typ @ Core.Compiler.MethodMatchKey]
struct Core.Compiler.MethodMatchResult end  [typ @ Core.Compiler.MethodMatchResult]
struct Core.Compiler.MethodMatches end  [typ @ Core.Compiler.MethodMatches]
struct Core.Compiler.MethodResultPure end  [typ @ Core.Compiler.MethodResultPure]
abstract type Core.Compiler.MethodTableView end  [typ @ Core.Compiler.MethodTableView]
struct Core.Compiler.Missing end  [typ @ Core.Compiler.Missing]
struct Core.Compiler.NativeInterpreter <: Core.Compiler.AbstractInterpreter end  [typ @ Core.Compiler.NativeInterpreter]
const Core.Compiler.NeedsShaping = Union{Tuple{Core.Integer, Vararg{Core.Integer}}, Tuple{Core.Compiler.OneTo, Vararg{Core.Compiler.OneTo}}}  [alias @ Core.Compiler.NeedsShaping]
struct Core.Compiler.NewInstruction end  [typ @ Core.Compiler.NewInstruction]
struct Core.Compiler.NewNodeInfo end  [typ @ Core.Compiler.NewNodeInfo]
struct Core.Compiler.NewNodeStream end  [typ @ Core.Compiler.NewNodeStream]
struct Core.Compiler.NewSSAValue end  [typ @ Core.Compiler.NewSSAValue]
struct Core.Compiler.NotFound end  [typ @ Core.Compiler.NotFound]
struct Core.Compiler.Nowhere end  [typ @ Core.Compiler.Nowhere]
struct Core.Compiler.OOBToken end  [typ @ Core.Compiler.OOBToken]
struct Core.Compiler.OldSSAValue end  [typ @ Core.Compiler.OldSSAValue]
struct Core.Compiler.OneTo{T<:Core.Integer} <: Core.Compiler.AbstractUnitRange{T} end  [typ @ Core.Compiler.OneTo]
struct Core.Compiler.OpaqueClosureCallInfo end  [typ @ Core.Compiler.OpaqueClosureCallInfo]
struct Core.Compiler.OpaqueClosureCreateInfo end  [typ @ Core.Compiler.OpaqueClosureCreateInfo]
struct Core.Compiler.OptimizationParams end  [typ @ Core.Compiler.OptimizationParams]
mutable struct Core.Compiler.OptimizationState end  [typ @ Core.Compiler.OptimizationState]
const Core.Compiler.Order.AbstractVector = Core.AbstractArray{T, 1} where T  [alias @ Core.Compiler.Order.AbstractVector]
struct Core.Compiler.Order.By{T, O} <: Core.Compiler.Order.Ordering end  [typ @ Core.Compiler.Order.By]
const Core.Compiler.Order.DirectOrdering = Union{Core.Compiler.Order.ForwardOrdering, Core.Compiler.Order.ReverseOrdering{Core.Compiler.Order.ForwardOrdering}}  [alias @ Core.Compiler.Order.DirectOrdering]
struct Core.Compiler.Order.ForwardOrdering <: Core.Compiler.Order.Ordering end  [typ @ Core.Compiler.Order.ForwardOrdering]
struct Core.Compiler.Order.Lt{T} <: Core.Compiler.Order.Ordering end  [typ @ Core.Compiler.Order.Lt]
abstract type Core.Compiler.Order.Ordering end  [typ @ Core.Compiler.Order.Ordering]
struct Core.Compiler.Order.Perm{O<:Core.Compiler.Order.Ordering, V<:(Base.AbstractVector)} <: Core.Compiler.Order.Ordering end  [typ @ Core.Compiler.Order.Perm]
struct Core.Compiler.Order.ReverseOrdering{Fwd<:Core.Compiler.Order.Ordering} <: Core.Compiler.Order.Ordering end  [typ @ Core.Compiler.Order.ReverseOrdering]
abstract type Core.Compiler.OrderStyle end  [typ @ Core.Compiler.OrderStyle]
struct Core.Compiler.Ordered <: Core.Compiler.OrderStyle end  [typ @ Core.Compiler.Ordered]
abstract type Core.Compiler.OrdinalRange{T, S} <: Core.Compiler.AbstractRange{T} end  [typ @ Core.Compiler.OrdinalRange]
const Core.Compiler.OverflowSafe = Union{Core.Bool, Core.Int128, Core.Int16, Core.Int32, Core.Int64, Core.Int8, Core.UInt128, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Core.Compiler.OverflowSafe]
struct Core.Compiler.OverlayMethodTable <: Core.Compiler.MethodTableView end  [typ @ Core.Compiler.OverlayMethodTable]
struct Core.Compiler.Pairs{K, V, I, A} <: Core.Compiler.AbstractDict{K, V} end  [typ @ Core.Compiler.Pairs]
const Core.Compiler.PartialOpaque = Core.PartialOpaque  [alias @ Core.Compiler.PartialOpaque]
const Core.Compiler.PartialStruct = Core.PartialStruct  [alias @ Core.Compiler.PartialStruct]
struct Core.Compiler.PartialTypeVar end  [typ @ Core.Compiler.PartialTypeVar]
const Core.Compiler.PostNumber = Core.Int64  [alias @ Core.Compiler.PostNumber]
const Core.Compiler.PreNumber = Core.Int64  [alias @ Core.Compiler.PreNumber]
const Core.Compiler.RangeIndex = Union{Core.Int64, Core.Compiler.AbstractRange{Core.Int64}}  [alias @ Core.Compiler.RangeIndex]
struct Core.Compiler.RangeStepIrregular <: Core.Compiler.RangeStepStyle end  [typ @ Core.Compiler.RangeStepIrregular]
struct Core.Compiler.RangeStepRegular <: Core.Compiler.RangeStepStyle end  [typ @ Core.Compiler.RangeStepRegular]
abstract type Core.Compiler.RangeStepStyle end  [typ @ Core.Compiler.RangeStepStyle]
const Core.Compiler.RangeVecIntList = Union{Tuple{Vararg{Union{Base.AbstractVector{Core.Int64}, Core.Compiler.AbstractRange}}}, Base.AbstractVector{A}} where A<:Base.AbstractVector{Core.Int64}  [alias @ Core.Compiler.RangeVecIntList]
mutable struct Core.Compiler.RefValue{T} <: Core.Ref{T} end  [typ @ Core.Compiler.RefValue]
struct Core.Compiler.ResolvedInliningSpec end  [typ @ Core.Compiler.ResolvedInliningSpec]
struct Core.Compiler.ReturnTypeCallInfo end  [typ @ Core.Compiler.ReturnTypeCallInfo]
struct Core.Compiler.SNCAData end  [typ @ Core.Compiler.SNCAData]
const Core.Compiler.SPCSet = Core.Compiler.IdSet{Core.Int64}  [alias @ Core.Compiler.SPCSet]
struct Core.Compiler.SSADefUse end  [typ @ Core.Compiler.SSADefUse]
struct Core.Compiler.Signature end  [typ @ Core.Compiler.Signature]
const Core.Compiler.SignedInt = Union{Core.Int128, Core.Int16, Core.Int32, Core.Int64, Core.Int8}  [alias @ Core.Compiler.SignedInt]
struct Core.Compiler.SizeUnknown <: Core.Compiler.IteratorSize end  [typ @ Core.Compiler.SizeUnknown]
struct Core.Compiler.Slice{T<:Core.Compiler.AbstractUnitRange} <: Core.Compiler.AbstractUnitRange{Int64} end  [typ @ Core.Compiler.Slice]
mutable struct Core.Compiler.SlotInfo end  [typ @ Core.Compiler.SlotInfo]
struct Core.Compiler.SomeCase end  [typ @ Core.Compiler.SomeCase]
abstract type Core.Compiler.Sort.Algorithm end  [typ @ Core.Compiler.Sort.Algorithm]
const Core.Compiler.Sort.Float.DirectOrdering = Union{Core.Compiler.Order.ForwardOrdering, Core.Compiler.Order.ReverseOrdering{Core.Compiler.Order.ForwardOrdering}}  [alias @ Core.Compiler.Sort.Float.DirectOrdering]
const Core.Compiler.Sort.Float.FPSortable = Union{Base.AbstractVector{Union{Core.Compiler.Missing, Core.Float32}}, Base.AbstractVector{Union{Core.Compiler.Missing, Core.Float64}}, Base.AbstractVector{Core.Compiler.Missing}, Base.AbstractVector{Core.Float32}, Base.AbstractVector{Core.Float64}}  [alias @ Core.Compiler.Sort.Float.FPSortable]
const Core.Compiler.Sort.Float.Floats = Union{Core.Float32, Core.Float64}  [alias @ Core.Compiler.Sort.Float.Floats]
struct Core.Compiler.Sort.Float.Left <: Core.Compiler.Order.Ordering end  [typ @ Core.Compiler.Sort.Float.Left]
struct Core.Compiler.Sort.Float.Right <: Core.Compiler.Order.Ordering end  [typ @ Core.Compiler.Sort.Float.Right]
struct Core.Compiler.Sort.InsertionSortAlg <: Core.Compiler.Sort.Algorithm end  [typ @ Core.Compiler.Sort.InsertionSortAlg]
struct Core.Compiler.Sort.MergeSortAlg <: Core.Compiler.Sort.Algorithm end  [typ @ Core.Compiler.Sort.MergeSortAlg]
struct Core.Compiler.Sort.PartialQuickSort{T<:Union{Core.Integer, Core.Compiler.OrdinalRange}} <: Core.Compiler.Sort.Algorithm end  [typ @ Core.Compiler.Sort.PartialQuickSort]
struct Core.Compiler.Sort.QuickSortAlg <: Core.Compiler.Sort.Algorithm end  [typ @ Core.Compiler.Sort.QuickSortAlg]
struct Core.Compiler.StateUpdate end  [typ @ Core.Compiler.StateUpdate]
struct Core.Compiler.StepRange{T, S} <: Core.Compiler.OrdinalRange{T, S} end  [typ @ Core.Compiler.StepRange]
struct Core.Compiler.StepRangeLen{T, R, S, L<:Core.Integer} <: Core.Compiler.AbstractRange{T} end  [typ @ Core.Compiler.StepRangeLen]
struct Core.Compiler.StmtRange <: Core.Compiler.AbstractUnitRange{Int64} end  [typ @ Core.Compiler.StmtRange]
const Core.Compiler.TP = Union{Core.Type{Core.Pair{K, V}}, Core.Type{Tuple{K, V}}} where {K, V}  [alias @ Core.Compiler.TP]
struct Core.Compiler.Timings.InferenceFrameInfo end  [typ @ Core.Compiler.Timings.InferenceFrameInfo]
struct Core.Compiler.Timings.Timing end  [typ @ Core.Compiler.Timings.Timing]
struct Core.Compiler.TriState end  [typ @ Core.Compiler.TriState]
const Core.Compiler.TypeofVararg = Core.TypeofVararg  [alias @ Core.Compiler.TypeofVararg]
struct Core.Compiler.TypesView{T} end  [typ @ Core.Compiler.TypesView]
struct Core.Compiler.UndefToken end  [typ @ Core.Compiler.UndefToken]
struct Core.Compiler.UnionSplit end  [typ @ Core.Compiler.UnionSplit]
struct Core.Compiler.UnionSplitApplyCallInfo end  [typ @ Core.Compiler.UnionSplitApplyCallInfo]
struct Core.Compiler.UnionSplitInfo end  [typ @ Core.Compiler.UnionSplitInfo]
struct Core.Compiler.UnionSplitMethodMatches end  [typ @ Core.Compiler.UnionSplitMethodMatches]
struct Core.Compiler.UnitRange{T<:Core.Real} <: Core.Compiler.AbstractUnitRange{T} end  [typ @ Core.Compiler.UnitRange]
struct Core.Compiler.Unordered <: Core.Compiler.OrderStyle end  [typ @ Core.Compiler.Unordered]
const Core.Compiler.UnsignedInt = Union{Core.UInt128, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Core.Compiler.UnsignedInt]
mutable struct Core.Compiler.UseRef end  [typ @ Core.Compiler.UseRef]
struct Core.Compiler.UseRefIterator end  [typ @ Core.Compiler.UseRefIterator]
struct Core.Compiler.Val{x} end  [typ @ Core.Compiler.Val]
struct Core.Compiler.ValueIterator{T<:Core.Compiler.AbstractDict} end  [typ @ Core.Compiler.ValueIterator]
struct Core.Compiler.VarState end  [typ @ Core.Compiler.VarState]
const Core.Compiler.VarTable = Core.Array{Core.Compiler.VarState, 1}  [alias @ Core.Compiler.VarTable]
const Core.Compiler.VecOrMat = Union{Core.Array{T, 1}, Core.Array{T, 2}} where T  [alias @ Core.Compiler.VecOrMat]
const Core.Compiler.Vector = Core.Array{T, 1} where T  [alias @ Core.Compiler.Vector]
struct Core.Compiler.WindowsErrorInfo end  [typ @ Core.Compiler.WindowsErrorInfo]
struct Core.Compiler.WorldRange end  [typ @ Core.Compiler.WorldRange]
struct Core.Compiler.WorldView{Cache} end  [typ @ Core.Compiler.WorldView]
struct Core.ConcurrencyViolationError <: Core.Exception end  [typ @ Core.ConcurrencyViolationError]
struct Core.Const end  [typ @ Core.Const]
struct Core.CoreSTDERR <: Core.IO end  [typ @ Core.CoreSTDERR]
struct Core.CoreSTDOUT <: Core.IO end  [typ @ Core.CoreSTDOUT]
const Core.Cvoid = Core.Nothing  [alias @ Core.Cvoid]
abstract type Core.DenseArray{T, N} <: Core.AbstractArray{T, N} end  [typ @ Core.DenseArray]
struct Core.DivideError <: Core.Exception end  [typ @ Core.DivideError]
struct Core.DomainError <: Core.Exception end  [typ @ Core.DomainError]
struct Core.ErrorException <: Core.Exception end  [typ @ Core.ErrorException]
abstract type Core.Exception end  [typ @ Core.Exception]
mutable struct Core.Expr end  [typ @ Core.Expr]
primitive type Core.Float16 <: Core.AbstractFloat 16 end  [typ @ Core.Float16]
primitive type Core.Float32 <: Core.AbstractFloat 32 end  [typ @ Core.Float32]
primitive type Core.Float64 <: Core.AbstractFloat 64 end  [typ @ Core.Float64]
struct Core.GeneratedFunctionStub end  [typ @ Core.GeneratedFunctionStub]
struct Core.GlobalRef end  [typ @ Core.GlobalRef]
struct Core.GotoIfNot end  [typ @ Core.GotoIfNot]
struct Core.GotoNode end  [typ @ Core.GotoNode]
abstract type Core.IO end  [typ @ Core.IO]
const Core.IR.Argument = Core.Argument  [alias @ Core.IR.Argument]
const Core.IR.CodeInfo = Core.CodeInfo  [alias @ Core.IR.CodeInfo]
const Core.IR.CodeInstance = Core.CodeInstance  [alias @ Core.IR.CodeInstance]
const Core.IR.Const = Core.Const  [alias @ Core.IR.Const]
const Core.IR.GotoIfNot = Core.GotoIfNot  [alias @ Core.IR.GotoIfNot]
const Core.IR.GotoNode = Core.GotoNode  [alias @ Core.IR.GotoNode]
const Core.IR.LineInfoNode = Core.LineInfoNode  [alias @ Core.IR.LineInfoNode]
const Core.IR.MethodInstance = Core.MethodInstance  [alias @ Core.IR.MethodInstance]
const Core.IR.NewvarNode = Core.NewvarNode  [alias @ Core.IR.NewvarNode]
const Core.IR.PartialStruct = Core.PartialStruct  [alias @ Core.IR.PartialStruct]
const Core.IR.PhiCNode = Core.PhiCNode  [alias @ Core.IR.PhiCNode]
const Core.IR.PhiNode = Core.PhiNode  [alias @ Core.IR.PhiNode]
const Core.IR.PiNode = Core.PiNode  [alias @ Core.IR.PiNode]
const Core.IR.ReturnNode = Core.ReturnNode  [alias @ Core.IR.ReturnNode]
const Core.IR.SSAValue = Core.SSAValue  [alias @ Core.IR.SSAValue]
const Core.IR.Slot = Core.Slot  [alias @ Core.IR.Slot]
const Core.IR.SlotNumber = Core.SlotNumber  [alias @ Core.IR.SlotNumber]
const Core.IR.TypedSlot = Core.TypedSlot  [alias @ Core.IR.TypedSlot]
const Core.IR.UpsilonNode = Core.UpsilonNode  [alias @ Core.IR.UpsilonNode]
struct Core.InexactError <: Core.Exception end  [typ @ Core.InexactError]
struct Core.InitError <: Core.WrappedException end  [typ @ Core.InitError]
const Core.Int = Core.Int64  [alias @ Core.Int]
primitive type Core.Int128 <: Core.Signed 128 end  [typ @ Core.Int128]
primitive type Core.Int16 <: Core.Signed 16 end  [typ @ Core.Int16]
primitive type Core.Int32 <: Core.Signed 32 end  [typ @ Core.Int32]
primitive type Core.Int64 <: Core.Signed 64 end  [typ @ Core.Int64]
primitive type Core.Int8 <: Core.Signed 8 end  [typ @ Core.Int8]
abstract type Core.Integer <: Core.Real end  [typ @ Core.Integer]
struct Core.InterConditional end  [typ @ Core.InterConditional]
struct Core.InterruptException <: Core.Exception end  [typ @ Core.InterruptException]
primitive type Core.LLVMPtr{T, AS} <: Core.Ref{T} 64 end  [typ @ Core.LLVMPtr]
struct Core.LineInfoNode end  [typ @ Core.LineInfoNode]
struct Core.LineNumberNode end  [typ @ Core.LineNumberNode]
struct Core.LoadError <: Core.WrappedException end  [typ @ Core.LoadError]
mutable struct Core.Method end  [typ @ Core.Method]
struct Core.MethodError <: Core.Exception end  [typ @ Core.MethodError]
mutable struct Core.MethodInstance end  [typ @ Core.MethodInstance]
struct Core.MethodMatch end  [typ @ Core.MethodMatch]
mutable struct Core.MethodTable end  [typ @ Core.MethodTable]
mutable struct Core.Module end  [typ @ Core.Module]
const Core.NTuple = Tuple{Vararg{T, N}} where {N, T}  [alias @ Core.NTuple]
struct Core.NamedTuple{names, T<:Core.Tuple} end  [typ @ Core.NamedTuple]
struct Core.NewvarNode end  [typ @ Core.NewvarNode]
struct Core.Nothing end  [typ @ Core.Nothing]
abstract type Core.Number end  [typ @ Core.Number]
struct Core.OutOfMemoryError <: Core.Exception end  [typ @ Core.OutOfMemoryError]
struct Core.OverflowError <: Core.Exception end  [typ @ Core.OverflowError]
struct Core.Pair{A, B} end  [typ @ Core.Pair]
struct Core.PartialOpaque end  [typ @ Core.PartialOpaque]
struct Core.PartialStruct end  [typ @ Core.PartialStruct]
struct Core.PhiCNode end  [typ @ Core.PhiCNode]
struct Core.PhiNode end  [typ @ Core.PhiNode]
struct Core.PiNode end  [typ @ Core.PiNode]
primitive type Core.Ptr{T} <: Core.Ref{T} 64 end  [typ @ Core.Ptr]
struct Core.QuoteNode end  [typ @ Core.QuoteNode]
struct Core.ReadOnlyMemoryError <: Core.Exception end  [typ @ Core.ReadOnlyMemoryError]
abstract type Core.Real <: Core.Number end  [typ @ Core.Real]
abstract type Core.Ref{T} end  [typ @ Core.Ref]
struct Core.ReturnNode end  [typ @ Core.ReturnNode]
struct Core.SSAValue end  [typ @ Core.SSAValue]
struct Core.SegmentationFault <: Core.Exception end  [typ @ Core.SegmentationFault]
abstract type Core.Signed <: Core.Integer end  [typ @ Core.Signed]
mutable struct Core.SimpleVector end  [typ @ Core.SimpleVector]
abstract type Core.Slot end  [typ @ Core.Slot]
struct Core.SlotNumber <: Core.Slot end  [typ @ Core.SlotNumber]
struct Core.StackOverflowError <: Core.Exception end  [typ @ Core.StackOverflowError]
mutable struct Core.String <: Core.AbstractString end  [typ @ Core.String]
mutable struct Core.Symbol end  [typ @ Core.Symbol]
mutable struct Core.Task end  [typ @ Core.Task]
struct Core.Tuple end  [typ @ Core.Tuple]
abstract type Core.Type{T} end  [typ @ Core.Type]
struct Core.TypeError <: Core.Exception end  [typ @ Core.TypeError]
mutable struct Core.TypeMapEntry end  [typ @ Core.TypeMapEntry]
mutable struct Core.TypeMapLevel end  [typ @ Core.TypeMapLevel]
mutable struct Core.TypeName end  [typ @ Core.TypeName]
mutable struct Core.TypeVar end  [typ @ Core.TypeVar]
struct Core.TypedSlot <: Core.Slot end  [typ @ Core.TypedSlot]
struct Core.TypeofVararg end  [typ @ Core.TypeofVararg]
const Core.UInt = Core.UInt64  [alias @ Core.UInt]
primitive type Core.UInt128 <: Core.Unsigned 128 end  [typ @ Core.UInt128]
primitive type Core.UInt16 <: Core.Unsigned 16 end  [typ @ Core.UInt16]
primitive type Core.UInt32 <: Core.Unsigned 32 end  [typ @ Core.UInt32]
primitive type Core.UInt64 <: Core.Unsigned 64 end  [typ @ Core.UInt64]
primitive type Core.UInt8 <: Core.Unsigned 8 end  [typ @ Core.UInt8]
struct Core.UndefInitializer end  [typ @ Core.UndefInitializer]
struct Core.UndefKeywordError <: Core.Exception end  [typ @ Core.UndefKeywordError]
struct Core.UndefRefError <: Core.Exception end  [typ @ Core.UndefRefError]
struct Core.UndefVarError <: Core.Exception end  [typ @ Core.UndefVarError]
abstract type Core.Unsigned <: Core.Integer end  [typ @ Core.Unsigned]
struct Core.UpsilonNode end  [typ @ Core.UpsilonNode]
struct Core.VecElement{T} end  [typ @ Core.VecElement]
mutable struct Core.WeakRef end  [typ @ Core.WeakRef]
abstract type Core.WrappedException <: Core.Exception end  [typ @ Core.WrappedException]
const Base.=> = Core.Pair  [alias @ Base.=>]
const Base.AbstractArrayOrBroadcasted = Union{Base.AbstractBroadcasted, Core.AbstractArray}  [alias @ Base.AbstractArrayOrBroadcasted]
abstract type Base.AbstractBroadcasted end  [typ @ Base.AbstractBroadcasted]
abstract type Base.AbstractCartesianIndex{N} end  [typ @ Base.AbstractCartesianIndex]
abstract type Base.AbstractChannel{T} end  [typ @ Base.AbstractChannel]
abstract type Base.AbstractCmd end  [typ @ Base.AbstractCmd]
abstract type Base.AbstractDict{K, V} end  [typ @ Base.AbstractDict]
const Base.AbstractDisplay = Base.Multimedia.AbstractDisplay  [alias @ Base.AbstractDisplay]
abstract type Base.AbstractIrrational <: Core.Real end  [typ @ Base.AbstractIrrational]
abstract type Base.AbstractLock end  [typ @ Base.AbstractLock]
abstract type Base.AbstractMatch end  [typ @ Base.AbstractMatch]
const Base.AbstractMatrix = Core.AbstractArray{T, 2} where T  [alias @ Base.AbstractMatrix]
abstract type Base.AbstractPattern end  [typ @ Base.AbstractPattern]
abstract type Base.AbstractPipe <: Core.IO end  [typ @ Base.AbstractPipe]
abstract type Base.AbstractRange{T} <: Core.AbstractArray{T, 1} end  [typ @ Base.AbstractRange]
abstract type Base.AbstractSet{T} end  [typ @ Base.AbstractSet]
abstract type Base.AbstractUnitRange{T} <: Base.OrdinalRange{T, T} end  [typ @ Base.AbstractUnitRange]
const Base.AbstractVecOrMat = Union{Core.AbstractArray{T, 1}, Core.AbstractArray{T, 2}} where T  [alias @ Base.AbstractVecOrMat]
const Base.AbstractVecOrTuple = Union{Tuple{Vararg{T}}, Base.AbstractVector{<:T}} where T  [alias @ Base.AbstractVecOrTuple]
const Base.AbstractVector = Core.AbstractArray{T, 1} where T  [alias @ Base.AbstractVector]
const Base.AbstractZeroDimArray = Core.AbstractArray{T, 0} where T  [alias @ Base.AbstractZeroDimArray]
const Base.All16 = Tuple{T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, Vararg{T, N}} where {T, N}  [alias @ Base.All16]
const Base.All32 = Tuple{T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, Vararg{T, N}} where {T, N}  [alias @ Base.All32]
struct Base.AlwaysLockedST <: Base.AbstractLock end  [typ @ Base.AlwaysLockedST]
struct Base.AndCmds <: Base.AbstractCmd end  [typ @ Base.AndCmds]
const Base.Any16 = Tuple{Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Vararg{Core.Any, N}} where N  [alias @ Base.Any16]
const Base.Any32 = Tuple{Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Core.Any, Vararg{Core.Any, N}} where N  [alias @ Base.Any32]
const Base.AnyDict = Base.Dict{Core.Any, Core.Any}  [alias @ Base.AnyDict]
struct Base.ArithmeticRounds <: Base.ArithmeticStyle end  [typ @ Base.ArithmeticRounds]
abstract type Base.ArithmeticStyle end  [typ @ Base.ArithmeticStyle]
struct Base.ArithmeticUnknown <: Base.ArithmeticStyle end  [typ @ Base.ArithmeticUnknown]
struct Base.ArithmeticWraps <: Base.ArithmeticStyle end  [typ @ Base.ArithmeticWraps]
const Base.Array = Core.Array  [alias @ Base.Array]
mutable struct Base.AsyncCollector end  [typ @ Base.AsyncCollector]
mutable struct Base.AsyncCollectorState end  [typ @ Base.AsyncCollectorState]
mutable struct Base.AsyncCondition end  [typ @ Base.AsyncCondition]
mutable struct Base.AsyncGenerator end  [typ @ Base.AsyncGenerator]
mutable struct Base.AsyncGeneratorState end  [typ @ Base.AsyncGeneratorState]
struct Base.BaseDocs.Keyword end  [typ @ Base.BaseDocs.Keyword]
const Base.BigFloat = Base.MPFR.BigFloat  [alias @ Base.BigFloat]
const Base.BigInt = Base.GMP.BigInt  [alias @ Base.BigInt]
abstract type Base.BinaryPlatforms.AbstractPlatform end  [typ @ Base.BinaryPlatforms.AbstractPlatform]
struct Base.BinaryPlatforms.CPUID.ISA end  [typ @ Base.BinaryPlatforms.CPUID.ISA]
struct Base.Libc.Libdl.dl_phdr_info end  [typ @ Base.Libc.Libdl.dl_phdr_info]
struct Base.BinaryPlatforms.Platform <: Base.BinaryPlatforms.AbstractPlatform end  [typ @ Base.BinaryPlatforms.Platform]
mutable struct Base.BitArray{N} <: Core.AbstractArray{Bool, N} end  [typ @ Base.BitArray]
const Base.BitInteger = Union{Core.Int128, Core.Int16, Core.Int32, Core.Int64, Core.Int8, Core.UInt128, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Base.BitInteger]
const Base.BitInteger32 = Union{Core.Int16, Core.Int32, Core.Int8, Core.UInt16, Core.UInt32, Core.UInt8}  [alias @ Base.BitInteger32]
const Base.BitInteger64 = Union{Core.Int16, Core.Int32, Core.Int64, Core.Int8, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Base.BitInteger64]
const Base.BitIntegerArray = Union{Core.Array{Core.Int128, N}, Core.Array{Core.Int16, N}, Core.Array{Core.Int32, N}, Core.Array{Core.Int64, N}, Core.Array{Core.Int8, N}, Core.Array{Core.UInt128, N}, Core.Array{Core.UInt16, N}, Core.Array{Core.UInt32, N}, Core.Array{Core.UInt64, N}, Core.Array{Core.UInt8, N}} where N  [alias @ Base.BitIntegerArray]
const Base.BitIntegerSmall = Union{Core.Int16, Core.Int32, Core.Int8, Core.UInt16, Core.UInt32, Core.UInt8}  [alias @ Base.BitIntegerSmall]
const Base.BitIntegerType = Union{Core.Type{Core.Int128}, Core.Type{Core.Int16}, Core.Type{Core.Int32}, Core.Type{Core.Int64}, Core.Type{Core.Int8}, Core.Type{Core.UInt128}, Core.Type{Core.UInt16}, Core.Type{Core.UInt32}, Core.Type{Core.UInt64}, Core.Type{Core.UInt8}}  [alias @ Base.BitIntegerType]
const Base.BitMatrix = Base.BitArray{2}  [alias @ Base.BitMatrix]
mutable struct Base.BitSet <: Base.AbstractSet{Int64} end  [typ @ Base.BitSet]
const Base.BitSigned = Union{Core.Int128, Core.Int16, Core.Int32, Core.Int64, Core.Int8}  [alias @ Base.BitSigned]
const Base.BitSigned32 = Union{Core.Int16, Core.Int32, Core.Int8}  [alias @ Base.BitSigned32]
const Base.BitSigned64 = Union{Core.Int16, Core.Int32, Core.Int64, Core.Int8}  [alias @ Base.BitSigned64]
const Base.BitSigned64T = Union{Core.Type{Core.Int16}, Core.Type{Core.Int32}, Core.Type{Core.Int64}, Core.Type{Core.Int8}}  [alias @ Base.BitSigned64T]
const Base.BitSignedSmall = Union{Core.Int16, Core.Int32, Core.Int8}  [alias @ Base.BitSignedSmall]
const Base.BitUnsigned = Union{Core.UInt128, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Base.BitUnsigned]
const Base.BitUnsigned32 = Union{Core.UInt16, Core.UInt32, Core.UInt8}  [alias @ Base.BitUnsigned32]
const Base.BitUnsigned64 = Union{Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Base.BitUnsigned64]
const Base.BitUnsigned64T = Union{Core.Type{Core.UInt16}, Core.Type{Core.UInt32}, Core.Type{Core.UInt64}, Core.Type{Core.UInt8}}  [alias @ Base.BitUnsigned64T]
const Base.BitUnsignedSmall = Union{Core.UInt16, Core.UInt32, Core.UInt8}  [alias @ Base.BitUnsignedSmall]
const Base.BitVector = Base.BitArray{1}  [alias @ Base.BitVector]
const Base.Bits = Core.Array{Core.UInt64, 1}  [alias @ Base.Bits]
struct Base.BottomRF{T} end  [typ @ Base.BottomRF]
abstract type Base.Broadcast.AbstractArrayStyle{N} <: Base.Broadcast.BroadcastStyle end  [typ @ Base.Broadcast.AbstractArrayStyle]
struct Base.Broadcast.AndAnd end  [typ @ Base.Broadcast.AndAnd]
struct Base.Broadcast.ArrayConflict <: Base.Broadcast.AbstractArrayStyle{Any} end  [typ @ Base.Broadcast.ArrayConflict]
struct Base.Broadcast.ArrayStyle{A<:Core.AbstractArray} <: Base.Broadcast.AbstractArrayStyle{Any} end  [typ @ Base.Broadcast.ArrayStyle]
struct Base.Broadcast.BitMaskedBitArray{N, M} end  [typ @ Base.Broadcast.BitMaskedBitArray]
abstract type Base.Broadcast.BroadcastStyle end  [typ @ Base.Broadcast.BroadcastStyle]
struct Base.Broadcast.Broadcasted{Style<:Union{Core.Nothing, Base.Broadcast.BroadcastStyle}, Axes, F, Args<:Core.Tuple} <: Base.AbstractBroadcasted end  [typ @ Base.Broadcast.Broadcasted]
const Base.Broadcast.BroadcastedChunkableOp = Base.Broadcast.Broadcasted{Style, Axes, F} where {Style<:Union{Core.Nothing, Base.Broadcast.BroadcastStyle}, Axes, F<:Union{typeof(Base.:!), typeof(Base.:&), typeof(Base.:*), typeof(Base.:(==)), typeof(Base.identity), typeof(Base.xor), typeof(Base.:|), typeof(Base.:~)}}  [alias @ Base.Broadcast.BroadcastedChunkableOp]
struct Base.Broadcast.DefaultArrayStyle{N} <: Base.Broadcast.AbstractArrayStyle{N} end  [typ @ Base.Broadcast.DefaultArrayStyle]
const Base.Broadcast.DefaultMatrixStyle = Base.Broadcast.DefaultArrayStyle{2}  [alias @ Base.Broadcast.DefaultMatrixStyle]
const Base.Broadcast.DefaultVectorStyle = Base.Broadcast.DefaultArrayStyle{1}  [alias @ Base.Broadcast.DefaultVectorStyle]
struct Base.Broadcast.Extruded{T, K, D} end  [typ @ Base.Broadcast.Extruded]
const Base.Broadcast.NestedTuple = Tuple{var"#s886", Vararg{Core.Any}} where var"#s886"<:Base.Broadcast.Broadcasted  [alias @ Base.Broadcast.NestedTuple]
const Base.Broadcast.NonleafHandlingStyles = Union{Base.Broadcast.ArrayConflict, Base.Broadcast.DefaultArrayStyle}  [alias @ Base.Broadcast.NonleafHandlingStyles]
struct Base.Broadcast.OrOr end  [typ @ Base.Broadcast.OrOr]
struct Base.Broadcast.Style{T} <: Base.Broadcast.BroadcastStyle end  [typ @ Base.Broadcast.Style]
struct Base.Broadcast.Unknown <: Base.Broadcast.BroadcastStyle end  [typ @ Base.Broadcast.Unknown]
mutable struct Base.BufferStream <: Base.LibuvStream end  [typ @ Base.BufferStream]
const Base.ByteArray = Union{Base.CodeUnits{Core.UInt8, Core.String}, Base.Vector{Core.Int8}, Base.Vector{Core.UInt8}, Base.SubArray{Core.Int8, 1, Base.Vector{Core.Int8}, I, true} where I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}, Base.SubArray{Core.UInt8, 1, Base.CodeUnits{Core.UInt8, Core.String}, I, true} where I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}, Base.SubArray{Core.UInt8, 1, Base.Vector{Core.UInt8}, I, true} where I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}  [alias @ Base.ByteArray]
mutable struct Base.CFunction <: Core.Ref{Nothing} end  [typ @ Base.CFunction]
const Base.CI0 = Union{Base.IteratorsMD.CartesianIndex{0}, Core.AbstractArray{Base.IteratorsMD.CartesianIndex{0}}}  [alias @ Base.CI0]
struct Base.CacheHeaderIncludes end  [typ @ Base.CacheHeaderIncludes]
mutable struct Base.CachedTOMLDict end  [typ @ Base.CachedTOMLDict]
const Base.Callable = Union{Core.Function, Core.Type}  [alias @ Base.Callable]
struct Base.CanonicalIndexError <: Core.Exception end  [typ @ Base.CanonicalIndexError]
struct Base.CapturedException <: Core.Exception end  [typ @ Base.CapturedException]
struct Base.Cartesian.LReplace{S<:Core.AbstractString} end  [typ @ Base.Cartesian.LReplace]
const Base.CartesianIndex = Base.IteratorsMD.CartesianIndex  [alias @ Base.CartesianIndex]
const Base.CartesianIndices = Base.IteratorsMD.CartesianIndices  [alias @ Base.CartesianIndices]
const Base.Cchar = Core.Int8  [alias @ Base.Cchar]
const Base.Cdouble = Core.Float64  [alias @ Base.Cdouble]
const Base.Cfloat = Core.Float32  [alias @ Base.Cfloat]
mutable struct Base.Channel{T} <: Base.AbstractChannel{T} end  [typ @ Base.Channel]
const Base.Chars = Union{Core.AbstractChar, Tuple{Vararg{Core.AbstractChar}}, Base.Set{<:Core.AbstractChar}, Base.AbstractVector{<:Core.AbstractChar}}  [alias @ Base.Chars]
const Base.Checked.BrokenSignedIntMul = Core.Int128  [alias @ Base.Checked.BrokenSignedIntMul]
const Base.Checked.BrokenUnsignedIntMul = Core.UInt128  [alias @ Base.Checked.BrokenUnsignedIntMul]
const Base.Checked.SignedInt = Union{Core.Int128, Core.Int16, Core.Int32, Core.Int64, Core.Int8}  [alias @ Base.Checked.SignedInt]
const Base.Checked.UnsignedInt = Union{Core.UInt128, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Base.Checked.UnsignedInt]
const Base.Checked.brokenSignedIntMul = Core.Int128  [alias @ Base.Checked.brokenSignedIntMul]
const Base.Checked.brokenUnsignedIntMul = Core.UInt128  [alias @ Base.Checked.brokenUnsignedIntMul]
const Base.Cint = Core.Int32  [alias @ Base.Cint]
const Base.Cintmax_t = Core.Int64  [alias @ Base.Cintmax_t]
const Base.Clong = Core.Int64  [alias @ Base.Clong]
const Base.Clonglong = Core.Int64  [alias @ Base.Clonglong]
struct Base.Cmd <: Base.AbstractCmd end  [typ @ Base.Cmd]
struct Base.CmdRedirect <: Base.AbstractCmd end  [typ @ Base.CmdRedirect]
const Base.Cmode_t = Core.Int32  [alias @ Base.Cmode_t]
struct Base.CodePointError{T<:Core.Integer} <: Core.Exception end  [typ @ Base.CodePointError]
struct Base.CodeUnits{T, S<:Core.AbstractString} <: Core.DenseArray{T, 1} end  [typ @ Base.CodeUnits]
struct Base.CodegenParams end  [typ @ Base.CodegenParams]
const Base.CodeunitType = Union{Core.Type{Core.UInt16}, Core.Type{Core.UInt32}, Core.Type{Core.UInt8}}  [alias @ Base.CodeunitType]
struct Base.Complex{T<:Core.Real} <: Core.Number end  [typ @ Base.Complex]
const Base.ComplexF16 = Base.Complex{Core.Float16}  [alias @ Base.ComplexF16]
const Base.ComplexF32 = Base.Complex{Core.Float32}  [alias @ Base.ComplexF32]
const Base.ComplexF64 = Base.Complex{Core.Float64}  [alias @ Base.ComplexF64]
struct Base.CompositeException <: Core.Exception end  [typ @ Base.CompositeException]
const Base.Condition = Base.GenericCondition{Base.AlwaysLockedST}  [alias @ Base.Condition]
abstract type Base.CoreLogging.AbstractLogger end  [typ @ Base.CoreLogging.AbstractLogger]
struct Base.CoreLogging.LogLevel end  [typ @ Base.CoreLogging.LogLevel]
struct Base.CoreLogging.LogState end  [typ @ Base.CoreLogging.LogState]
struct Base.CoreLogging.NullLogger <: Base.CoreLogging.AbstractLogger end  [typ @ Base.CoreLogging.NullLogger]
struct Base.CoreLogging.SimpleLogger <: Base.CoreLogging.AbstractLogger end  [typ @ Base.CoreLogging.SimpleLogger]
const Base.Cptrdiff_t = Core.Int64  [alias @ Base.Cptrdiff_t]
const Base.Cshort = Core.Int16  [alias @ Base.Cshort]
const Base.Csize_t = Core.UInt64  [alias @ Base.Csize_t]
const Base.Cssize_t = Core.Int64  [alias @ Base.Cssize_t]
primitive type Base.Cstring 64 end  [typ @ Base.Cstring]
const Base.Cuchar = Core.UInt8  [alias @ Base.Cuchar]
const Base.Cuint = Core.UInt32  [alias @ Base.Cuint]
const Base.Cuintmax_t = Core.UInt64  [alias @ Base.Cuintmax_t]
const Base.Culong = Core.UInt64  [alias @ Base.Culong]
const Base.Culonglong = Core.UInt64  [alias @ Base.Culonglong]
const Base.Cushort = Core.UInt16  [alias @ Base.Cushort]
const Base.Cwchar_t = Core.Int32  [alias @ Base.Cwchar_t]
primitive type Base.Cwstring 64 end  [typ @ Base.Cwstring]
struct Base.CyclePadding{P} end  [typ @ Base.CyclePadding]
struct Base.DataTypeFieldDesc end  [typ @ Base.DataTypeFieldDesc]
struct Base.DataTypeLayout end  [typ @ Base.DataTypeLayout]
const Base.DenseMatrix = Core.DenseArray{T, 2} where T  [alias @ Base.DenseMatrix]
const Base.DenseVecOrMat = Union{Core.DenseArray{T, 1}, Core.DenseArray{T, 2}} where T  [alias @ Base.DenseVecOrMat]
const Base.DenseVector = Core.DenseArray{T, 1} where T  [alias @ Base.DenseVector]
struct Base.DevNull <: Core.IO end  [typ @ Base.DevNull]
mutable struct Base.Dict{K, V} <: Base.AbstractDict{K, V} end  [typ @ Base.Dict]
const Base.DimOrInd = Union{Core.Integer, Base.AbstractUnitRange}  [alias @ Base.DimOrInd]
struct Base.DimSelector{dims, T} end  [typ @ Base.DimSelector]
struct Base.DimensionMismatch <: Core.Exception end  [typ @ Base.DimensionMismatch]
const Base.Dims = Tuple{Vararg{Core.Int64, N}} where N  [alias @ Base.Dims]
const Base.DimsInteger = Tuple{Vararg{Core.Integer, N}} where N  [alias @ Base.DimsInteger]
const Base.DimsOrInds = Tuple{Vararg{Union{Core.Integer, Base.AbstractUnitRange}, N}} where N  [alias @ Base.DimsOrInds]
struct Base.Docs.Binding end  [typ @ Base.Docs.Binding]
const Base.Docs.Callable = Union{Core.Function, Core.Type}  [alias @ Base.Docs.Callable]
mutable struct Base.Docs.DocStr end  [typ @ Base.Docs.DocStr]
mutable struct Base.Docs.HTML{T} end  [typ @ Base.Docs.HTML]
const Base.Docs.METAType = Base.IdDict{Core.Any, Core.Any}  [alias @ Base.Docs.METAType]
mutable struct Base.Docs.MultiDoc end  [typ @ Base.Docs.MultiDoc]
mutable struct Base.Docs.Text{T} end  [typ @ Base.Docs.Text]
struct Base.EOFError <: Core.Exception end  [typ @ Base.EOFError]
struct Base.EachLine{IOT<:Core.IO} end  [typ @ Base.EachLine]
struct Base.EachStringIndex{T<:Core.AbstractString} end  [typ @ Base.EachStringIndex]
struct Base.EltypeUnknown <: Base.IteratorEltype end  [typ @ Base.EltypeUnknown]
const Base.Enum = Base.Enums.Enum  [alias @ Base.Enum]
abstract type Base.Enums.Enum{T<:Core.Integer} end  [typ @ Base.Enums.Enum]
struct Base.EnvDict <: Base.AbstractDict{String, String} end  [typ @ Base.EnvDict]
struct Base.ErrOrCmds <: Base.AbstractCmd end  [typ @ Base.ErrOrCmds]
mutable struct Base.Event end  [typ @ Base.Event]
struct Base.ExceptionStack <: Core.AbstractArray{Any, 1} end  [typ @ Base.ExceptionStack]
struct Base.Experimental.Const{T, N} <: Core.DenseArray{T, N} end  [typ @ Base.Experimental.Const]
struct Base.ExponentialBackOff end  [typ @ Base.ExponentialBackOff]
const Base.ExprNode = Union{Core.GotoNode, Core.SSAValue, Core.Expr, Core.GlobalRef, Core.GotoIfNot, Core.LineNumberNode, Core.PhiCNode, Core.PhiNode, Core.QuoteNode, Core.ReturnNode, Core.Slot, Core.UpsilonNode}  [alias @ Base.ExprNode]
const Base.F_or_FF = Union{Core.AbstractFloat, Tuple{Core.AbstractFloat, Core.AbstractFloat}}  [alias @ Base.F_or_FF]
const Base.FastContiguousSubArray = Base.SubArray{T, N, P, I, true} where {T, N, P, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}  [alias @ Base.FastContiguousSubArray]
const Base.FastMath.ComplexTypes = Union{Base.Complex{Core.Float32}, Base.Complex{Core.Float64}}  [alias @ Base.FastMath.ComplexTypes]
const Base.FastMath.FloatTypes = Union{Core.Float16, Core.Float32, Core.Float64}  [alias @ Base.FastMath.FloatTypes]
const Base.FastSubArray = Base.SubArray{T, N, P, I, true} where {T, N, P, I}  [alias @ Base.FastSubArray]
struct Base.FieldDesc end  [typ @ Base.FieldDesc]
struct Base.FieldDescStorage{T} end  [typ @ Base.FieldDescStorage]
struct Base.FileRedirect end  [typ @ Base.FileRedirect]
abstract type Base.Filesystem.AbstractFile <: Core.IO end  [typ @ Base.Filesystem.AbstractFile]
struct Base.Filesystem.DiskStat end  [typ @ Base.Filesystem.DiskStat]
mutable struct Base.Filesystem.File <: Base.Filesystem.AbstractFile end  [typ @ Base.Filesystem.File]
const Base.Filesystem.IOError = Base.IOError  [alias @ Base.Filesystem.IOError]
const Base.Filesystem.OS_HANDLE = Base.Libc.RawFD  [alias @ Base.Filesystem.OS_HANDLE]
const Base.Filesystem.RefValue = Base.RefValue  [alias @ Base.Filesystem.RefValue]
struct Base.Filesystem.StatStruct end  [typ @ Base.Filesystem.StatStruct]
struct Base.Filesystem.uv_dirent_t end  [typ @ Base.Filesystem.uv_dirent_t]
struct Base.FilteringRF{F, T} end  [typ @ Base.FilteringRF]
struct Base.FlatteningRF{T} end  [typ @ Base.FlatteningRF]
struct Base.FlipArgs{F} end  [typ @ Base.FlipArgs]
struct Base.GC_Diff end  [typ @ Base.GC_Diff]
struct Base.GC_Num end  [typ @ Base.GC_Num]
mutable struct Base.GMP.BigInt <: Core.Signed end  [typ @ Base.GMP.BigInt]
const Base.GMP.CdoubleMax = Union{Core.Float16, Core.Float32, Core.Float64}  [alias @ Base.GMP.CdoubleMax]
const Base.GMP.ClongMax = Union{Core.Int16, Core.Int32, Core.Int64, Core.Int8}  [alias @ Base.GMP.ClongMax]
const Base.GMP.CulongMax = Union{Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Base.GMP.CulongMax]
const Base.GMP.Limb = Core.UInt64  [alias @ Base.GMP.Limb]
const Base.GMP.MPQ.BigInt = Base.GMP.BigInt  [alias @ Base.GMP.MPQ.BigInt]
const Base.GMP.MPQ.Limb = Core.UInt64  [alias @ Base.GMP.MPQ.Limb]
const Base.GMP.MPZ.bitcnt_t = Core.UInt64  [alias @ Base.GMP.MPZ.bitcnt_t]
const Base.GMP.MPZ.mpz_t = Core.Ref{Base.GMP.BigInt}  [alias @ Base.GMP.MPZ.mpz_t]
mutable struct Base.GMP.MPQ._MPQ end  [typ @ Base.GMP.MPQ._MPQ]
const Base.GMP.MPQ.mpq_t = Core.Ref{Base.GMP.MPQ._MPQ}  [alias @ Base.GMP.MPQ.mpq_t]
const Base.GMP.SLimbMax = Union{Core.Int16, Core.Int32, Core.Int64, Core.Int8}  [alias @ Base.GMP.SLimbMax]
const Base.GMP.ULimbMax = Union{Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Base.GMP.ULimbMax]
struct Base.Generator{I, F} end  [typ @ Base.Generator]
struct Base.GenericCondition{L<:Base.AbstractLock} end  [typ @ Base.GenericCondition]
mutable struct Base.GenericIOBuffer{T<:Base.AbstractVector{Core.UInt8}} <: Core.IO end  [typ @ Base.GenericIOBuffer]
struct Base.GitVersionInfo end  [typ @ Base.GitVersionInfo]
const Base.HTML = Base.Docs.HTML  [alias @ Base.HTML]
const Base.HWNumber = Union{Core.Float32, Core.Float64, Core.Int16, Core.Int32, Core.Int64, Core.Int8, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8, Base.Complex{<:Union{Core.Float32, Core.Float64, Core.Int16, Core.Int32, Core.Int64, Core.Int8, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}}, Base.Rational{<:Union{Core.Float32, Core.Float64, Core.Int16, Core.Int32, Core.Int64, Core.Int8, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}}}  [alias @ Base.HWNumber]
const Base.HWReal = Union{Core.Float32, Core.Float64, Core.Int16, Core.Int32, Core.Int64, Core.Int8, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Base.HWReal]
struct Base.HasEltype <: Base.IteratorEltype end  [typ @ Base.HasEltype]
struct Base.HasLength <: Base.IteratorSize end  [typ @ Base.HasLength]
struct Base.HasShape{N} <: Base.IteratorSize end  [typ @ Base.HasShape]
const Base.IEEEFloat = Union{Core.Float16, Core.Float32, Core.Float64}  [alias @ Base.IEEEFloat]
const Base.IOBuffer = Base.GenericIOBuffer{Core.Array{Core.UInt8, 1}}  [alias @ Base.IOBuffer]
struct Base.IOContext{IO_t<:Core.IO} <: Base.AbstractPipe end  [typ @ Base.IOContext]
struct Base.IOError <: Core.Exception end  [typ @ Base.IOError]
abstract type Base.IOServer end  [typ @ Base.IOServer]
mutable struct Base.IOStream <: Core.IO end  [typ @ Base.IOStream]
const Base.IRShow.Argument = Core.Argument  [alias @ Base.IRShow.Argument]
const Base.IRShow.CFG = Core.Compiler.CFG  [alias @ Base.IRShow.CFG]
const Base.IRShow.Effects = Core.Compiler.Effects  [alias @ Base.IRShow.Effects]
const Base.IRShow.GotoIfNot = Core.GotoIfNot  [alias @ Base.IRShow.GotoIfNot]
const Base.IRShow.IRCode = Core.Compiler.IRCode  [alias @ Base.IRShow.IRCode]
struct Base.IRShow.IRShowConfig end  [typ @ Base.IRShow.IRShowConfig]
const Base.IRShow.ReturnNode = Core.ReturnNode  [alias @ Base.IRShow.ReturnNode]
const Base.IRShow.TriState = Core.Compiler.TriState  [alias @ Base.IRShow.TriState]
struct Base.IRShow._UNDEF end  [typ @ Base.IRShow._UNDEF]
mutable struct Base.IdDict{K, V} <: Base.AbstractDict{K, V} end  [typ @ Base.IdDict]
mutable struct Base.IdSet{T} <: Base.AbstractSet{T} end  [typ @ Base.IdSet]
struct Base.IdentityUnitRange{T<:Base.AbstractUnitRange} <: Base.AbstractUnitRange{Int64} end  [typ @ Base.IdentityUnitRange]
struct Base.ImmutableDict{K, V} <: Base.AbstractDict{K, V} end  [typ @ Base.ImmutableDict]
struct Base.IndexCartesian <: Base.IndexStyle end  [typ @ Base.IndexCartesian]
struct Base.IndexLinear <: Base.IndexStyle end  [typ @ Base.IndexLinear]
struct Base.IndexSCartesian2{K} <: Base.IndexStyle end  [typ @ Base.IndexSCartesian2]
abstract type Base.IndexStyle end  [typ @ Base.IndexStyle]
const Base.Indices = Tuple{Vararg{Base.AbstractUnitRange, N}} where N  [alias @ Base.Indices]
const Base.IntOrInd = Union{Core.Int64, Base.AbstractUnitRange}  [alias @ Base.IntOrInd]
struct Base.InterpreterIP end  [typ @ Base.InterpreterIP]
struct Base.InvalidCharError{T<:Core.AbstractChar} <: Core.Exception end  [typ @ Base.InvalidCharError]
struct Base.InvalidStateException <: Core.Exception end  [typ @ Base.InvalidStateException]
mutable struct Base.InvasiveLinkedList{T} end  [typ @ Base.InvasiveLinkedList]
struct Base.InvasiveLinkedListSynchronized{T} end  [typ @ Base.InvasiveLinkedListSynchronized]
struct Base.Irrational{sym} <: Base.AbstractIrrational end  [typ @ Base.Irrational]
struct Base.IsInfinite <: Base.IteratorSize end  [typ @ Base.IsInfinite]
abstract type Base.IteratorEltype end  [typ @ Base.IteratorEltype]
abstract type Base.IteratorSize end  [typ @ Base.IteratorSize]
struct Base.Iterators.Accumulate{F, I, T} end  [typ @ Base.Iterators.Accumulate]
struct Base.Iterators.Count{T, S} end  [typ @ Base.Iterators.Count]
struct Base.Iterators.Cycle{I} end  [typ @ Base.Iterators.Cycle]
struct Base.Iterators.Drop{I} end  [typ @ Base.Iterators.Drop]
struct Base.Iterators.DropWhile{I, P<:Core.Function} end  [typ @ Base.Iterators.DropWhile]
struct Base.Iterators.Enumerate{I} end  [typ @ Base.Iterators.Enumerate]
struct Base.Iterators.Filter{F, I} end  [typ @ Base.Iterators.Filter]
struct Base.Iterators.Flatten{I} end  [typ @ Base.Iterators.Flatten]
struct Base.Iterators.IterationCutShort end  [typ @ Base.Iterators.IterationCutShort]
const Base.Iterators.IteratorEltype = Base.IteratorEltype  [alias @ Base.Iterators.IteratorEltype]
const Base.Iterators.IteratorSize = Base.IteratorSize  [alias @ Base.Iterators.IteratorSize]
struct Base.Iterators.PartitionIterator{T} end  [typ @ Base.Iterators.PartitionIterator]
struct Base.Iterators.ProductIterator{T<:Core.Tuple} end  [typ @ Base.Iterators.ProductIterator]
struct Base.Iterators.Repeated{O} end  [typ @ Base.Iterators.Repeated]
struct Base.Iterators.Rest{I, S} end  [typ @ Base.Iterators.Rest]
struct Base.Iterators.Reverse{T} end  [typ @ Base.Iterators.Reverse]
mutable struct Base.Iterators.Stateful{T, VS} end  [typ @ Base.Iterators.Stateful]
struct Base.Iterators.Take{I} end  [typ @ Base.Iterators.Take]
struct Base.Iterators.TakeWhile{I, P<:Core.Function} end  [typ @ Base.Iterators.TakeWhile]
struct Base.Iterators.Zip{Is<:Core.Tuple} end  [typ @ Base.Iterators.Zip]
struct Base.IteratorsMD.CartesianIndex{N} <: Base.AbstractCartesianIndex{N} end  [typ @ Base.IteratorsMD.CartesianIndex]
struct Base.IteratorsMD.CartesianIndices{N, R<:Tuple{Vararg{Base.OrdinalRange{Core.Int64, Core.Int64}, N}}} <: Core.AbstractArray{CartesianIndex{N}, N} end  [typ @ Base.IteratorsMD.CartesianIndices]
const Base.IteratorsMD.CartesianPartition = Base.SubArray{T, 1, R, <:Tuple{Base.AbstractUnitRange{Core.Int64}}, false} where {T<:Base.IteratorsMD.CartesianIndex, P<:Base.IteratorsMD.CartesianIndices, R<:(Base.ReshapedArray{T, 1, P})}  [alias @ Base.IteratorsMD.CartesianPartition]
const Base.IteratorsMD.IndexStyle = Base.IndexStyle  [alias @ Base.IteratorsMD.IndexStyle]
const Base.IteratorsMD.IteratorSize = Base.IteratorSize  [alias @ Base.IteratorsMD.IteratorSize]
const Base.IteratorsMD.OrdinalRangeInt = Base.OrdinalRange{Core.Int64, Core.Int64}  [alias @ Base.IteratorsMD.OrdinalRangeInt]
struct Base.JLOptions end  [typ @ Base.JLOptions]
struct Base.KeyError <: Core.Exception end  [typ @ Base.KeyError]
struct Base.KeySet{K, T<:(Base.AbstractDict{K})} <: Base.AbstractSet{K} end  [typ @ Base.KeySet]
mutable struct Base.LazyString <: Core.AbstractString end  [typ @ Base.LazyString]
mutable struct Base.Libc.Cgroup end  [typ @ Base.Libc.Cgroup]
struct Base.Libc.Cpasswd end  [typ @ Base.Libc.Cpasswd]
struct Base.Libc.FILE end  [typ @ Base.Libc.FILE]
struct Base.Libc.Group end  [typ @ Base.Libc.Group]
struct Base.Libc.Passwd end  [typ @ Base.Libc.Passwd]
primitive type Base.Libc.RawFD 32 end  [typ @ Base.Libc.RawFD]
struct Base.Libc.TimeVal end  [typ @ Base.Libc.TimeVal]
mutable struct Base.Libc.TmStruct end  [typ @ Base.Libc.TmStruct]
abstract type Base.LibuvServer <: Base.IOServer end  [typ @ Base.LibuvServer]
abstract type Base.LibuvStream <: Core.IO end  [typ @ Base.LibuvStream]
struct Base.LinRange{T, L<:Core.Integer} <: Base.AbstractRange{T} end  [typ @ Base.LinRange]
struct Base.LinearIndices{N, R<:Tuple{Vararg{Base.AbstractUnitRange{Core.Int64}, N}}} <: Core.AbstractArray{Int64, N} end  [typ @ Base.LinearIndices]
const Base.LinkedList = Base.InvasiveLinkedList{Base.LinkedListItem{T}} where T  [alias @ Base.LinkedList]
mutable struct Base.LinkedListItem{T} end  [typ @ Base.LinkedListItem]
struct Base.LoadingCache end  [typ @ Base.LoadingCache]
struct Base.LogicalIndex{T, A<:(Core.AbstractArray{Core.Bool})} <: Core.AbstractArray{T, 1} end  [typ @ Base.LogicalIndex]
const Base.MIME = Base.Multimedia.MIME  [alias @ Base.MIME]
mutable struct Base.MPFR.BigFloat <: Core.AbstractFloat end  [typ @ Base.MPFR.BigFloat]
const Base.MPFR.CdoubleMax = Union{Core.Float16, Core.Float32, Core.Float64}  [alias @ Base.MPFR.CdoubleMax]
const Base.MPFR.ClongMax = Union{Core.Int16, Core.Int32, Core.Int64, Core.Int8}  [alias @ Base.MPFR.ClongMax]
const Base.MPFR.CulongMax = Union{Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Base.MPFR.CulongMax]
const Base.MPFR.Limb = Core.UInt64  [alias @ Base.MPFR.Limb]
primitive type Base.MPFR.MPFRRoundingMode <: Base.Enums.Enum{Int32} 32 end  [typ @ Base.MPFR.MPFRRoundingMode]
struct Base.MappingRF{F, T} end  [typ @ Base.MappingRF]
struct Base.Math.DoubleFloat32 end  [typ @ Base.Math.DoubleFloat32]
struct Base.Math.DoubleFloat64 end  [typ @ Base.Math.DoubleFloat64]
const Base.Matrix = Core.Array{T, 2} where T  [alias @ Base.Matrix]
struct Base.Meta.ParseError <: Core.Exception end  [typ @ Base.Meta.ParseError]
mutable struct Base.MethodList <: Core.AbstractArray{Method, 1} end  [typ @ Base.MethodList]
struct Base.Missing end  [typ @ Base.Missing]
struct Base.MissingException <: Core.Exception end  [typ @ Base.MissingException]
abstract type Base.Multimedia.AbstractDisplay end  [typ @ Base.Multimedia.AbstractDisplay]
struct Base.Multimedia.MIME{mime} end  [typ @ Base.Multimedia.MIME]
struct Base.Multimedia.TextDisplay <: Base.Multimedia.AbstractDisplay end  [typ @ Base.Multimedia.TextDisplay]
abstract type Base.MultiplicativeInverses.MultiplicativeInverse{T} end  [typ @ Base.MultiplicativeInverses.MultiplicativeInverse]
struct Base.MultiplicativeInverses.SignedMultiplicativeInverse{T<:Core.Signed} <: Base.MultiplicativeInverses.MultiplicativeInverse{T} end  [typ @ Base.MultiplicativeInverses.SignedMultiplicativeInverse]
struct Base.MultiplicativeInverses.UnsignedMultiplicativeInverse{T<:Core.Unsigned} <: Base.MultiplicativeInverses.MultiplicativeInverse{T} end  [typ @ Base.MultiplicativeInverses.UnsignedMultiplicativeInverse]
const Base.NTuple = Tuple{Vararg{T, N}} where {N, T}  [alias @ Base.NTuple]
const Base.NeedsShaping = Union{Tuple{Core.Integer, Vararg{Core.Integer}}, Tuple{Base.OneTo, Vararg{Base.OneTo}}}  [alias @ Base.NeedsShaping]
const Base.NonReshapedReinterpretArray = Base.ReinterpretArray{T, N, S, A, false} where {T, N, S, A<:Core.AbstractArray{S, N}}  [alias @ Base.NonReshapedReinterpretArray]
struct Base.Nowhere end  [typ @ Base.Nowhere]
const Base.OS_HANDLE = Base.Libc.RawFD  [alias @ Base.OS_HANDLE]
struct Base.OneTo{T<:Core.Integer} <: Base.AbstractUnitRange{T} end  [typ @ Base.OneTo]
struct Base.OrCmds <: Base.AbstractCmd end  [typ @ Base.OrCmds]
const Base.Order.AbstractVector = Core.AbstractArray{T, 1} where T  [alias @ Base.Order.AbstractVector]
struct Base.Order.By{T, O} <: Base.Order.Ordering end  [typ @ Base.Order.By]
const Base.Order.DirectOrdering = Union{Base.Order.ForwardOrdering, Base.Order.ReverseOrdering{Base.Order.ForwardOrdering}}  [alias @ Base.Order.DirectOrdering]
struct Base.Order.ForwardOrdering <: Base.Order.Ordering end  [typ @ Base.Order.ForwardOrdering]
struct Base.Order.Lt{T} <: Base.Order.Ordering end  [typ @ Base.Order.Lt]
abstract type Base.Order.Ordering end  [typ @ Base.Order.Ordering]
struct Base.Order.Perm{O<:Base.Order.Ordering, V<:(Base.AbstractVector)} <: Base.Order.Ordering end  [typ @ Base.Order.Perm]
struct Base.Order.ReverseOrdering{Fwd<:Base.Order.Ordering} <: Base.Order.Ordering end  [typ @ Base.Order.ReverseOrdering]
abstract type Base.OrderStyle end  [typ @ Base.OrderStyle]
struct Base.Ordered <: Base.OrderStyle end  [typ @ Base.Ordered]
abstract type Base.OrdinalRange{T, S} <: Base.AbstractRange{T} end  [typ @ Base.OrdinalRange]
const Base.OverflowSafe = Union{Core.Bool, Core.Int128, Core.Int16, Core.Int32, Core.Int64, Core.Int8, Core.UInt128, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Base.OverflowSafe]
const Base.PCRE.RefValue = Base.RefValue  [alias @ Base.PCRE.RefValue]
struct Base.Padding end  [typ @ Base.Padding]
struct Base.PaddingError end  [typ @ Base.PaddingError]
const Base.Pair = Core.Pair  [alias @ Base.Pair]
struct Base.Pairs{K, V, I, A} <: Base.AbstractDict{K, V} end  [typ @ Base.Pairs]
const Base.PartialQuickSort = Base.Sort.PartialQuickSort  [alias @ Base.PartialQuickSort]
const Base.PermutedDimsArray = Base.PermutedDimsArrays.PermutedDimsArray  [alias @ Base.PermutedDimsArray]
struct Base.PermutedDimsArrays.PermutedDimsArray{T, N, perm, iperm, AA<:Core.AbstractArray} <: Core.AbstractArray{T, N} end  [typ @ Base.PermutedDimsArrays.PermutedDimsArray]
mutable struct Base.Pipe <: Base.AbstractPipe end  [typ @ Base.Pipe]
mutable struct Base.PipeEndpoint <: Base.LibuvStream end  [typ @ Base.PipeEndpoint]
struct Base.PkgId end  [typ @ Base.PkgId]
mutable struct Base.PkgOrigin end  [typ @ Base.PkgOrigin]
struct Base.PrecompilableError <: Core.Exception end  [typ @ Base.PrecompilableError]
struct Base.Prehashed end  [typ @ Base.Prehashed]
mutable struct Base.Process <: Base.AbstractPipe end  [typ @ Base.Process]
mutable struct Base.ProcessChain <: Base.AbstractPipe end  [typ @ Base.ProcessChain]
struct Base.ProcessFailedException <: Core.Exception end  [typ @ Base.ProcessFailedException]
const Base.RangeIndex = Union{Core.Int64, Base.AbstractRange{Core.Int64}}  [alias @ Base.RangeIndex]
struct Base.RangeStepIrregular <: Base.RangeStepStyle end  [typ @ Base.RangeStepIrregular]
struct Base.RangeStepRegular <: Base.RangeStepStyle end  [typ @ Base.RangeStepRegular]
abstract type Base.RangeStepStyle end  [typ @ Base.RangeStepStyle]
const Base.RangeVecIntList = Union{Tuple{Vararg{Union{Base.AbstractVector{Core.Int64}, Base.AbstractRange}}}, Base.AbstractVector{A}} where A<:Base.AbstractVector{Core.Int64}  [alias @ Base.RangeVecIntList]
struct Base.Rational{T<:Core.Integer} <: Core.Real end  [typ @ Base.Rational]
const Base.RawFD = Base.Libc.RawFD  [alias @ Base.RawFD]
struct Base.ReadEachIterator{T, IOT<:Core.IO} end  [typ @ Base.ReadEachIterator]
const Base.Redirectable = Union{Base.Libc.RawFD, Base.FileRedirect, Core.IO}  [alias @ Base.Redirectable]
mutable struct Base.ReentrantLock <: Base.AbstractLock end  [typ @ Base.ReentrantLock]
struct Base.RefArray{T, A<:(Core.AbstractArray{T}), R} <: Core.Ref{T} end  [typ @ Base.RefArray]
mutable struct Base.RefValue{T} <: Core.Ref{T} end  [typ @ Base.RefValue]
mutable struct Base.Regex <: Base.AbstractPattern end  [typ @ Base.Regex]
struct Base.RegexAndMatchData end  [typ @ Base.RegexAndMatchData]
struct Base.RegexMatch <: Base.AbstractMatch end  [typ @ Base.RegexMatch]
struct Base.RegexMatchIterator end  [typ @ Base.RegexMatchIterator]
struct Base.ReinterpretArray{T, N, S, A<:(Core.AbstractArray{S}), IsReshaped} <: Core.AbstractArray{T, N} end  [typ @ Base.ReinterpretArray]
struct Base.ReshapedArray{T, N, P<:Core.AbstractArray, MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Core.Int64}}}} <: Core.AbstractArray{T, N} end  [typ @ Base.ReshapedArray]
struct Base.ReshapedArrayIterator{I, M} end  [typ @ Base.ReshapedArrayIterator]
const Base.ReshapedArrayLF = Base.ReshapedArray{T, N, P, Tuple{}} where {T, N, P<:Core.AbstractArray}  [alias @ Base.ReshapedArrayLF]
struct Base.ReshapedIndex{T} end  [typ @ Base.ReshapedIndex]
const Base.ReshapedRange = Base.ReshapedArray{T, N, A, Tuple{}} where {T, N, A<:Base.AbstractRange}  [alias @ Base.ReshapedRange]
const Base.ReshapedReinterpretArray = Base.ReinterpretArray{T, N, S, A, true} where {T, N, S, A<:(Core.AbstractArray{S})}  [alias @ Base.ReshapedReinterpretArray]
const Base.ReshapedUnitRange = Base.ReshapedArray{T, N, A, Tuple{}} where {T, N, A<:Base.AbstractUnitRange}  [alias @ Base.ReshapedUnitRange]
struct Base.Rounding.RoundingMode{T} end  [typ @ Base.Rounding.RoundingMode]
const Base.RoundingMode = Base.Rounding.RoundingMode  [alias @ Base.RoundingMode]
struct Base.SCartesianIndex2{K} end  [typ @ Base.SCartesianIndex2]
struct Base.SCartesianIndices2{K, R<:Base.AbstractUnitRange{Core.Int64}} <: Core.AbstractArray{Base.SCartesianIndex2{K}, 2} end  [typ @ Base.SCartesianIndices2]
struct Base.SHA1 end  [typ @ Base.SHA1]
const Base.ScalarIndex = Core.Real  [alias @ Base.ScalarIndex]
struct Base.ScheduledAfterSyncException <: Core.Exception end  [typ @ Base.ScheduledAfterSyncException]
mutable struct Base.SecretBuffer <: Core.IO end  [typ @ Base.SecretBuffer]
mutable struct Base.Semaphore end  [typ @ Base.Semaphore]
struct Base.Set{T} <: Base.AbstractSet{T} end  [typ @ Base.Set]
struct Base.SimdLoop.SimdError <: Core.Exception end  [typ @ Base.SimdLoop.SimdError]
struct Base.SizeUnknown <: Base.IteratorSize end  [typ @ Base.SizeUnknown]
struct Base.SkipMissing{T} end  [typ @ Base.SkipMissing]
struct Base.Slice{T<:Base.AbstractUnitRange} <: Base.AbstractUnitRange{Int64} end  [typ @ Base.Slice]
const Base.SlowSubArray = Base.SubArray{T, N, P, I, false} where {T, N, P, I}  [alias @ Base.SlowSubArray]
const Base.SmallSigned = Union{Core.Int16, Core.Int32, Core.Int8}  [alias @ Base.SmallSigned]
const Base.SmallUnsigned = Union{Core.UInt16, Core.UInt32, Core.UInt8}  [alias @ Base.SmallUnsigned]
struct Base.Some{T} end  [typ @ Base.Some]
abstract type Base.Sort.Algorithm end  [typ @ Base.Sort.Algorithm]
const Base.Sort.Float.DirectOrdering = Union{Base.Order.ForwardOrdering, Base.Order.ReverseOrdering{Base.Order.ForwardOrdering}}  [alias @ Base.Sort.Float.DirectOrdering]
const Base.Sort.Float.FPSortable = Union{Base.AbstractVector{Union{Base.Missing, Core.Float32}}, Base.AbstractVector{Union{Base.Missing, Core.Float64}}, Base.AbstractVector{Base.Missing}, Base.AbstractVector{Core.Float32}, Base.AbstractVector{Core.Float64}}  [alias @ Base.Sort.Float.FPSortable]
const Base.Sort.Float.Floats = Union{Core.Float32, Core.Float64}  [alias @ Base.Sort.Float.Floats]
struct Base.Sort.Float.Left <: Base.Order.Ordering end  [typ @ Base.Sort.Float.Left]
struct Base.Sort.Float.Right <: Base.Order.Ordering end  [typ @ Base.Sort.Float.Right]
struct Base.Sort.InsertionSortAlg <: Base.Sort.Algorithm end  [typ @ Base.Sort.InsertionSortAlg]
struct Base.Sort.MergeSortAlg <: Base.Sort.Algorithm end  [typ @ Base.Sort.MergeSortAlg]
struct Base.Sort.PartialQuickSort{T<:Union{Core.Integer, Base.OrdinalRange}} <: Base.Sort.Algorithm end  [typ @ Base.Sort.PartialQuickSort]
struct Base.Sort.QuickSortAlg <: Base.Sort.Algorithm end  [typ @ Base.Sort.QuickSortAlg]
const Base.SpawnIO = Union{Base.Libc.RawFD, Core.IO}  [alias @ Base.SpawnIO]
const Base.SpawnIOs = Core.Array{Union{Base.Libc.RawFD, Core.IO}, 1}  [alias @ Base.SpawnIOs]
struct Base.SplitIterator{S<:Core.AbstractString, F} end  [typ @ Base.SplitIterator]
const Base.StackTraces.CodeInfo = Core.CodeInfo  [alias @ Base.StackTraces.CodeInfo]
const Base.StackTraces.MethodInstance = Core.MethodInstance  [alias @ Base.StackTraces.MethodInstance]
struct Base.StackTraces.StackFrame end  [typ @ Base.StackTraces.StackFrame]
const Base.StackTraces.StackTrace = Core.Array{Base.StackTraces.StackFrame, 1}  [alias @ Base.StackTraces.StackTrace]
const Base.StdIOSet = Tuple{Union{Base.Libc.RawFD, Base.FileRedirect, Core.IO}, Union{Base.Libc.RawFD, Base.FileRedirect, Core.IO}, Union{Base.Libc.RawFD, Base.FileRedirect, Core.IO}}  [alias @ Base.StdIOSet]
struct Base.StepRange{T, S} <: Base.OrdinalRange{T, S} end  [typ @ Base.StepRange]
struct Base.StepRangeLen{T, R, S, L<:Core.Integer} <: Base.AbstractRange{T} end  [typ @ Base.StepRangeLen]
const Base.StickyWorkqueue = Base.InvasiveLinkedListSynchronized{Core.Task}  [alias @ Base.StickyWorkqueue]
const Base.StridedArray = Union{Core.DenseArray{T, N}, Base.ReinterpretArray{T, N, S, A, IsReshaped} where {A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.ReshapedArray{T, N, A} where A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, Base.SubArray{T, N, A, I} where {A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.ReshapedArray{T, N, A} where {T, N, A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}}, Core.DenseArray}, I<:Tuple{Vararg{Union{Core.Int64, Base.AbstractRange{Core.Int64}, Base.AbstractCartesianIndex, Base.ReshapedArray{T, N, A, Tuple{}} where {T, N, A<:Base.AbstractUnitRange}}}}}} where {T, N}  [alias @ Base.StridedArray]
const Base.StridedFastContiguousSubArray = Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}  [alias @ Base.StridedFastContiguousSubArray]
const Base.StridedMatrix = Union{Core.DenseArray{T, 2}, Base.ReinterpretArray{T, 2, S, A, IsReshaped} where {A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.ReshapedArray{T, 2, A} where A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, Base.SubArray{T, 2, A, I} where {A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.ReshapedArray{T, N, A} where {T, N, A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}}, Core.DenseArray}, I<:Tuple{Vararg{Union{Core.Int64, Base.AbstractRange{Core.Int64}, Base.AbstractCartesianIndex, Base.ReshapedArray{T, N, A, Tuple{}} where {T, N, A<:Base.AbstractUnitRange}}}}}} where T  [alias @ Base.StridedMatrix]
const Base.StridedReinterpretArray = Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}  [alias @ Base.StridedReinterpretArray]
const Base.StridedReshapedArray = Base.ReshapedArray{T, N, A} where {T, N, A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}}  [alias @ Base.StridedReshapedArray]
const Base.StridedSubArray = Base.SubArray{T, N, A, I} where {T, N, A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.ReshapedArray{T, N, A} where {T, N, A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}}, Core.DenseArray}, I<:Tuple{Vararg{Union{Core.Int64, Base.AbstractRange{Core.Int64}, Base.AbstractCartesianIndex, Base.ReshapedArray{T, N, A, Tuple{}} where {T, N, A<:Base.AbstractUnitRange}}}}}  [alias @ Base.StridedSubArray]
const Base.StridedVecOrMat = Union{Core.DenseArray{T, 1}, Core.DenseArray{T, 2}, Base.ReinterpretArray{T, 1, S, A, IsReshaped} where {A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.ReinterpretArray{T, 2, S, A, IsReshaped} where {A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.ReshapedArray{T, 1, A} where A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, Base.ReshapedArray{T, 2, A} where A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, Base.SubArray{T, 1, A, I} where {A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.ReshapedArray{T, N, A} where {T, N, A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}}, Core.DenseArray}, I<:Tuple{Vararg{Union{Core.Int64, Base.AbstractRange{Core.Int64}, Base.AbstractCartesianIndex, Base.ReshapedArray{T, N, A, Tuple{}} where {T, N, A<:Base.AbstractUnitRange}}}}}, Base.SubArray{T, 2, A, I} where {A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.ReshapedArray{T, N, A} where {T, N, A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}}, Core.DenseArray}, I<:Tuple{Vararg{Union{Core.Int64, Base.AbstractRange{Core.Int64}, Base.AbstractCartesianIndex, Base.ReshapedArray{T, N, A, Tuple{}} where {T, N, A<:Base.AbstractUnitRange}}}}}} where T  [alias @ Base.StridedVecOrMat]
const Base.StridedVector = Union{Core.DenseArray{T, 1}, Base.ReinterpretArray{T, 1, S, A, IsReshaped} where {A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.ReshapedArray{T, 1, A} where A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, Base.SubArray{T, 1, A, I} where {A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.ReshapedArray{T, N, A} where {T, N, A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}}, Core.DenseArray}, I<:Tuple{Vararg{Union{Core.Int64, Base.AbstractRange{Core.Int64}, Base.AbstractCartesianIndex, Base.ReshapedArray{T, N, A, Tuple{}} where {T, N, A<:Base.AbstractUnitRange}}}}}} where T  [alias @ Base.StridedVector]
struct Base.StringIndexError <: Core.Exception end  [typ @ Base.StringIndexError]
struct Base.SubArray{T, N, P, I, L} <: Core.AbstractArray{T, N} end  [typ @ Base.SubArray]
struct Base.SubString{T<:Core.AbstractString} <: Core.AbstractString end  [typ @ Base.SubString]
struct Base.SubstitutionString{T<:Core.AbstractString} <: Core.AbstractString end  [typ @ Base.SubstitutionString]
struct Base.SummarySize end  [typ @ Base.SummarySize]
mutable struct Base.Sys.CPUinfo end  [typ @ Base.Sys.CPUinfo]
mutable struct Base.Sys.UV_cpu_info_t end  [typ @ Base.Sys.UV_cpu_info_t]
struct Base.SystemError <: Core.Exception end  [typ @ Base.SystemError]
struct Base.TOML.Date end  [typ @ Base.TOML.Date]
struct Base.TOML.DateTime end  [typ @ Base.TOML.DateTime]
const Base.TOML.Err = Union{Base.TOML.ParserError, T} where T  [alias @ Base.TOML.Err]
primitive type Base.TOML.ErrorType <: Base.Enums.Enum{Int32} 32 end  [typ @ Base.TOML.ErrorType]
mutable struct Base.TOML.Parser end  [typ @ Base.TOML.Parser]
mutable struct Base.TOML.ParserError <: Core.Exception end  [typ @ Base.TOML.ParserError]
const Base.TOML.TOMLDict = Base.Dict{Core.String, Core.Any}  [alias @ Base.TOML.TOMLDict]
struct Base.TOML.Time end  [typ @ Base.TOML.Time]
struct Base.TOMLCache end  [typ @ Base.TOMLCache]
const Base.TP = Union{Core.Type{Core.Pair{K, V}}, Core.Type{Tuple{K, V}}} where {K, V}  [alias @ Base.TP]
mutable struct Base.TTY <: Base.LibuvStream end  [typ @ Base.TTY]
struct Base.TaskFailedException <: Core.Exception end  [typ @ Base.TaskFailedException]
const Base.Text = Base.Docs.Text  [alias @ Base.Text]
const Base.TextDisplay = Base.Multimedia.TextDisplay  [alias @ Base.TextDisplay]
const Base.ThreadSynchronizer = Base.GenericCondition{Base.Threads.SpinLock}  [alias @ Base.ThreadSynchronizer]
const Base.Threads.AbstractLock = Base.AbstractLock  [alias @ Base.Threads.AbstractLock]
abstract type Base.Threads.AbstractSchedule end  [typ @ Base.Threads.AbstractSchedule]
const Base.Threads.ArithmeticTypes = Union{Core.Float16, Core.Float32, Core.Float64, Core.Int128, Core.Int16, Core.Int32, Core.Int64, Core.Int8, Core.UInt128, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Base.Threads.ArithmeticTypes]
mutable struct Base.Threads.Atomic{T<:Union{Core.Bool, Core.Float16, Core.Float32, Core.Float64, Core.Int128, Core.Int16, Core.Int32, Core.Int64, Core.Int8, Core.UInt128, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}} end  [typ @ Base.Threads.Atomic]
const Base.Threads.AtomicTypes = Union{Core.Bool, Core.Float16, Core.Float32, Core.Float64, Core.Int128, Core.Int16, Core.Int32, Core.Int64, Core.Int8, Core.UInt128, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Base.Threads.AtomicTypes]
const Base.Threads.Condition = Base.GenericCondition{Base.ReentrantLock}  [alias @ Base.Threads.Condition]
const Base.Threads.Event = Base.Event  [alias @ Base.Threads.Event]
struct Base.Threads.FairSchedule <: Base.Threads.AbstractSchedule end  [typ @ Base.Threads.FairSchedule]
const Base.Threads.FloatTypes = Union{Core.Float16, Core.Float32, Core.Float64}  [alias @ Base.Threads.FloatTypes]
const Base.Threads.IntTypes = Union{Core.Int128, Core.Int16, Core.Int32, Core.Int64, Core.Int8, Core.UInt128, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}  [alias @ Base.Threads.IntTypes]
mutable struct Base.Threads.SpinLock <: Base.AbstractLock end  [typ @ Base.Threads.SpinLock]
struct Base.Threads.StaticSchedule <: Base.Threads.AbstractSchedule end  [typ @ Base.Threads.StaticSchedule]
mutable struct Base.Timer end  [typ @ Base.Timer]
struct Base.TwicePrecision{T} end  [typ @ Base.TwicePrecision]
struct Base.UUID end  [typ @ Base.UUID]
struct Base.Unicode.GraphemeIterator{S<:Core.AbstractString} end  [typ @ Base.Unicode.GraphemeIterator]
const Base.Unicode.Symbol = Core.Symbol  [alias @ Base.Unicode.Symbol]
struct Base.UnitRange{T<:Core.Real} <: Base.AbstractUnitRange{T} end  [typ @ Base.UnitRange]
struct Base.Unordered <: Base.OrderStyle end  [typ @ Base.Unordered]
struct Base.UnwrapTaskFailedException end  [typ @ Base.UnwrapTaskFailedException]
const Base.VInt = Core.UInt32  [alias @ Base.VInt]
struct Base.Val{x} end  [typ @ Base.Val]
struct Base.ValueIterator{T<:Base.AbstractDict} end  [typ @ Base.ValueIterator]
const Base.VecOrMat = Union{Core.Array{T, 1}, Core.Array{T, 2}} where T  [alias @ Base.VecOrMat]
const Base.Vector = Core.Array{T, 1} where T  [alias @ Base.Vector]
const Base.VerTuple = Tuple{Vararg{Union{Core.UInt64, Core.String}}}  [alias @ Base.VerTuple]
struct Base.VersionNumber end  [typ @ Base.VersionNumber]
const Base.ViewIndex = Union{Core.Real, Core.AbstractArray}  [alias @ Base.ViewIndex]
mutable struct Base.WeakKeyDict{K, V} <: Base.AbstractDict{K, V} end  [typ @ Base.WeakKeyDict]
struct Base.WindowsErrorInfo end  [typ @ Base.WindowsErrorInfo]
const Base.WrappedException = Core.WrappedException  [alias @ Base.WrappedException]
struct Base._InitialValue end  [typ @ Base._InitialValue]
const ArgTools.AbstractCmd = Base.AbstractCmd  [alias @ ArgTools.AbstractCmd]
const ArgTools.ArgRead = Union{Base.AbstractCmd, Core.AbstractString, Core.IO}  [alias @ ArgTools.ArgRead]
const ArgTools.ArgWrite = Union{Base.AbstractCmd, Core.AbstractString, Core.IO}  [alias @ ArgTools.ArgWrite]
const ArgTools.CmdRedirect = Base.CmdRedirect  [alias @ ArgTools.CmdRedirect]
const ArgTools.Process = Base.Process  [alias @ ArgTools.Process]
const Artifacts.SHA1 = Base.SHA1  [alias @ Artifacts.SHA1]
struct Base64.Base64DecodePipe <: Core.IO end  [typ @ Base64.Base64DecodePipe]
struct Base64.Base64EncodePipe <: Core.IO end  [typ @ Base64.Base64EncodePipe]
mutable struct Base64.Buffer end  [typ @ Base64.Buffer]
const CRC32c.FastContiguousSubArray = Base.SubArray{T, N, P, I, true} where {T, N, P, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}  [alias @ CRC32c.FastContiguousSubArray]
struct FileWatching.FDEvent end  [typ @ FileWatching.FDEvent]
mutable struct FileWatching.FDWatcher end  [typ @ FileWatching.FDWatcher]
struct FileWatching.FileEvent end  [typ @ FileWatching.FileEvent]
mutable struct FileWatching.FileMonitor end  [typ @ FileWatching.FileMonitor]
mutable struct FileWatching.FolderMonitor end  [typ @ FileWatching.FolderMonitor]
const FileWatching.IOError = Base.IOError  [alias @ FileWatching.IOError]
mutable struct FileWatching.PollingFileWatcher end  [typ @ FileWatching.PollingFileWatcher]
const FileWatching.StatStruct = Base.Filesystem.StatStruct  [alias @ FileWatching.StatStruct]
mutable struct FileWatching._FDWatcher end  [typ @ FileWatching._FDWatcher]
const Logging.AbstractLogger = Base.CoreLogging.AbstractLogger  [alias @ Logging.AbstractLogger]
struct Logging.ConsoleLogger <: Base.CoreLogging.AbstractLogger end  [typ @ Logging.ConsoleLogger]
const Logging.LogLevel = Base.CoreLogging.LogLevel  [alias @ Logging.LogLevel]
const Logging.NullLogger = Base.CoreLogging.NullLogger  [alias @ Logging.NullLogger]
const Logging.SimpleLogger = Base.CoreLogging.SimpleLogger  [alias @ Logging.SimpleLogger]
mutable struct Mmap.Anonymous <: Core.IO end  [typ @ Mmap.Anonymous]
const Mmap.OS_HANDLE = Base.Libc.RawFD  [alias @ Mmap.OS_HANDLE]
const SHA.AbstractBytes = Union{Tuple{Vararg{Core.UInt8, N}} where N, Base.AbstractVector{Core.UInt8}}  [alias @ SHA.AbstractBytes]
struct SHA.HMAC_CTX{CTX<:SHA.SHA_CTX} end  [typ @ SHA.HMAC_CTX]
mutable struct SHA.SHA1_CTX <: SHA.SHA_CTX end  [typ @ SHA.SHA1_CTX]
const SHA.SHA224_CTX = SHA.SHA2_224_CTX  [alias @ SHA.SHA224_CTX]
const SHA.SHA256_CTX = SHA.SHA2_256_CTX  [alias @ SHA.SHA256_CTX]
mutable struct SHA.SHA2_224_CTX <: SHA.SHA2_CTX end  [typ @ SHA.SHA2_224_CTX]
mutable struct SHA.SHA2_256_CTX <: SHA.SHA2_CTX end  [typ @ SHA.SHA2_256_CTX]
mutable struct SHA.SHA2_384_CTX <: SHA.SHA2_CTX end  [typ @ SHA.SHA2_384_CTX]
mutable struct SHA.SHA2_512_CTX <: SHA.SHA2_CTX end  [typ @ SHA.SHA2_512_CTX]
abstract type SHA.SHA2_CTX <: SHA.SHA_CTX end  [typ @ SHA.SHA2_CTX]
const SHA.SHA384_CTX = SHA.SHA2_384_CTX  [alias @ SHA.SHA384_CTX]
mutable struct SHA.SHA3_224_CTX <: SHA.SHA3_CTX end  [typ @ SHA.SHA3_224_CTX]
mutable struct SHA.SHA3_256_CTX <: SHA.SHA3_CTX end  [typ @ SHA.SHA3_256_CTX]
mutable struct SHA.SHA3_384_CTX <: SHA.SHA3_CTX end  [typ @ SHA.SHA3_384_CTX]
mutable struct SHA.SHA3_512_CTX <: SHA.SHA3_CTX end  [typ @ SHA.SHA3_512_CTX]
abstract type SHA.SHA3_CTX <: SHA.SHA_CTX end  [typ @ SHA.SHA3_CTX]
const SHA.SHA512_CTX = SHA.SHA2_512_CTX  [alias @ SHA.SHA512_CTX]
abstract type SHA.SHA_CTX end  [typ @ SHA.SHA_CTX]
abstract type Serialization.AbstractSerializer end  [typ @ Serialization.AbstractSerializer]
const Serialization.OtherInt = Core.Int32  [alias @ Serialization.OtherInt]
mutable struct Serialization.Serializer{I<:Core.IO} <: Serialization.AbstractSerializer end  [typ @ Serialization.Serializer]
const Serialization.SimpleVector = Core.SimpleVector  [alias @ Serialization.SimpleVector]
struct Sockets.DNSError <: Core.Exception end  [typ @ Sockets.DNSError]
abstract type Sockets.IPAddr end  [typ @ Sockets.IPAddr]
struct Sockets.IPv4 <: Sockets.IPAddr end  [typ @ Sockets.IPv4]
struct Sockets.IPv6 <: Sockets.IPAddr end  [typ @ Sockets.IPv6]
struct Sockets.InetAddr{T<:Sockets.IPAddr} end  [typ @ Sockets.InetAddr]
mutable struct Sockets.PipeServer <: Base.LibuvServer end  [typ @ Sockets.PipeServer]
mutable struct Sockets.TCPServer <: Base.LibuvServer end  [typ @ Sockets.TCPServer]
mutable struct Sockets.TCPSocket <: Base.LibuvStream end  [typ @ Sockets.TCPSocket]
mutable struct Sockets.UDPSocket <: Base.LibuvStream end  [typ @ Sockets.UDPSocket]
abstract type DelimitedFiles.DLMHandler end  [typ @ DelimitedFiles.DLMHandler]
mutable struct DelimitedFiles.DLMOffsets <: DelimitedFiles.DLMHandler end  [typ @ DelimitedFiles.DLMOffsets]
mutable struct DelimitedFiles.DLMStore{T} <: DelimitedFiles.DLMHandler end  [typ @ DelimitedFiles.DLMStore]
abstract type LinearAlgebra.AbstractQ{T} <: Core.AbstractArray{T, 2} end  [typ @ LinearAlgebra.AbstractQ]
abstract type LinearAlgebra.AbstractRotation{T} end  [typ @ LinearAlgebra.AbstractRotation]
abstract type LinearAlgebra.AbstractTriangular{T, S<:(Base.AbstractMatrix)} <: Core.AbstractArray{T, 2} end  [typ @ LinearAlgebra.AbstractTriangular]
const LinearAlgebra.AdjOrTrans = Union{LinearAlgebra.Adjoint{T, S}, LinearAlgebra.Transpose{T, S}} where {T, S}  [alias @ LinearAlgebra.AdjOrTrans]
const LinearAlgebra.AdjOrTransAbsMat = Union{LinearAlgebra.Adjoint{T, var"#s886"}, LinearAlgebra.Transpose{T, var"#s886"}} where {T, var"#s886"<:(Base.AbstractMatrix)}  [alias @ LinearAlgebra.AdjOrTransAbsMat]
const LinearAlgebra.AdjOrTransAbsVec = Union{LinearAlgebra.Adjoint{T, var"#s886"}, LinearAlgebra.Transpose{T, var"#s886"}} where {T, var"#s886"<:(Base.AbstractVector)}  [alias @ LinearAlgebra.AdjOrTransAbsVec]
const LinearAlgebra.AdjOrTransStridedMat = Union{LinearAlgebra.Adjoint{T, <:Base.StridedMatrix{T} where T}, LinearAlgebra.Transpose{T, <:Base.StridedMatrix{T} where T}} where T  [alias @ LinearAlgebra.AdjOrTransStridedMat]
struct LinearAlgebra.Adjoint{T, S} <: Core.AbstractArray{T, 2} end  [typ @ LinearAlgebra.Adjoint]
const LinearAlgebra.AdjointAbsMat = LinearAlgebra.Adjoint{T, <:Base.AbstractMatrix} where T  [alias @ LinearAlgebra.AdjointAbsMat]
const LinearAlgebra.AdjointAbsVec = LinearAlgebra.Adjoint{T, <:Base.AbstractVector} where T  [alias @ LinearAlgebra.AdjointAbsVec]
abstract type LinearAlgebra.Algorithm end  [typ @ LinearAlgebra.Algorithm]
struct LinearAlgebra.BLAS.LBTConfig end  [typ @ LinearAlgebra.BLAS.LBTConfig]
struct LinearAlgebra.BLAS.LBTLibraryInfo end  [typ @ LinearAlgebra.BLAS.LBTLibraryInfo]
struct LinearAlgebra.BLAS.lbt_config_t end  [typ @ LinearAlgebra.BLAS.lbt_config_t]
struct LinearAlgebra.BLAS.lbt_library_info_t end  [typ @ LinearAlgebra.BLAS.lbt_library_info_t]
const LinearAlgebra.BiTri = Union{LinearAlgebra.Bidiagonal, LinearAlgebra.Tridiagonal}  [alias @ LinearAlgebra.BiTri]
const LinearAlgebra.BiTriSym = Union{LinearAlgebra.Bidiagonal, LinearAlgebra.SymTridiagonal, LinearAlgebra.Tridiagonal}  [alias @ LinearAlgebra.BiTriSym]
struct LinearAlgebra.Bidiagonal{T, V<:Core.AbstractArray{T, 1}} <: Core.AbstractArray{T, 2} end  [typ @ LinearAlgebra.Bidiagonal]
const LinearAlgebra.BlasComplex = Union{Base.Complex{Core.Float32}, Base.Complex{Core.Float64}}  [alias @ LinearAlgebra.BlasComplex]
const LinearAlgebra.BlasFloat = Union{Core.Float32, Core.Float64, Base.ComplexF32, Base.ComplexF64}  [alias @ LinearAlgebra.BlasFloat]
const LinearAlgebra.BlasHessenbergQ = LinearAlgebra.HessenbergQ{T, <:Base.StridedMatrix{T}, <:Base.StridedVector{T}, sym} where {T<:Union{Core.Float32, Core.Float64, Base.ComplexF32, Base.ComplexF64}, sym}  [alias @ LinearAlgebra.BlasHessenbergQ]
const LinearAlgebra.BlasInt = Core.Int64  [alias @ LinearAlgebra.BlasInt]
const LinearAlgebra.BlasReal = Union{Core.Float32, Core.Float64}  [alias @ LinearAlgebra.BlasReal]
struct LinearAlgebra.BunchKaufman{T, S<:(Base.AbstractMatrix), P<:(Base.AbstractVector{<:Core.Integer})} <: LinearAlgebra.Factorization{T} end  [typ @ LinearAlgebra.BunchKaufman]
struct LinearAlgebra.Cholesky{T, S<:(Base.AbstractMatrix)} <: LinearAlgebra.Factorization{T} end  [typ @ LinearAlgebra.Cholesky]
struct LinearAlgebra.CholeskyPivoted{T, S<:(Base.AbstractMatrix), P<:(Base.AbstractVector{<:Core.Integer})} <: LinearAlgebra.Factorization{T} end  [typ @ LinearAlgebra.CholeskyPivoted]
struct LinearAlgebra.ColumnNorm <: LinearAlgebra.PivotingStrategy end  [typ @ LinearAlgebra.ColumnNorm]
const LinearAlgebra.ConvertibleSpecialMatrix = Union{LinearAlgebra.AbstractTriangular, LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.SymTridiagonal, LinearAlgebra.Tridiagonal}  [alias @ LinearAlgebra.ConvertibleSpecialMatrix]
struct LinearAlgebra.Diagonal{T, V<:Core.AbstractArray{T, 1}} <: Core.AbstractArray{T, 2} end  [typ @ LinearAlgebra.Diagonal]
struct LinearAlgebra.DivideAndConquer <: LinearAlgebra.Algorithm end  [typ @ LinearAlgebra.DivideAndConquer]
struct LinearAlgebra.Eigen{T, V, S<:(Base.AbstractMatrix), U<:(Base.AbstractVector)} <: LinearAlgebra.Factorization{T} end  [typ @ LinearAlgebra.Eigen]
abstract type LinearAlgebra.Factorization{T} end  [typ @ LinearAlgebra.Factorization]
struct LinearAlgebra.GeneralizedEigen{T, V, S<:(Base.AbstractMatrix), U<:(Base.AbstractVector)} <: LinearAlgebra.Factorization{T} end  [typ @ LinearAlgebra.GeneralizedEigen]
struct LinearAlgebra.GeneralizedSVD{T, S<:(Base.AbstractMatrix), Tr, C<:Core.AbstractArray{Tr, 1}} <: LinearAlgebra.Factorization{T} end  [typ @ LinearAlgebra.GeneralizedSVD]
struct LinearAlgebra.GeneralizedSchur{Ty, M<:(Base.AbstractMatrix), A<:(Base.AbstractVector), B<:Core.AbstractArray{Ty, 1}} <: LinearAlgebra.Factorization{Ty} end  [typ @ LinearAlgebra.GeneralizedSchur]
struct LinearAlgebra.Givens{T} <: LinearAlgebra.AbstractRotation{T} end  [typ @ LinearAlgebra.Givens]
const LinearAlgebra.HermOrSym = Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T, S}} where {T, S}  [alias @ LinearAlgebra.HermOrSym]
struct LinearAlgebra.Hermitian{T, S<:(Core.AbstractArray{<:T, 2})} <: Core.AbstractArray{T, 2} end  [typ @ LinearAlgebra.Hermitian]
struct LinearAlgebra.Hessenberg{T, SH<:(Base.AbstractMatrix), S<:(Base.AbstractMatrix), W<:(Base.AbstractVector), V<:Core.Number} <: LinearAlgebra.Factorization{T} end  [typ @ LinearAlgebra.Hessenberg]
struct LinearAlgebra.HessenbergQ{T, S<:(Base.AbstractMatrix), W<:(Base.AbstractVector), sym} <: LinearAlgebra.AbstractQ{T} end  [typ @ LinearAlgebra.HessenbergQ]
const LinearAlgebra.IndexStyle = Base.IndexStyle  [alias @ LinearAlgebra.IndexStyle]
struct LinearAlgebra.LAPACKException <: Core.Exception end  [typ @ LinearAlgebra.LAPACKException]
const LinearAlgebra.LAPACKFactorizations = Union{LinearAlgebra.Cholesky{T, S}, LinearAlgebra.BunchKaufman{T, S}, LinearAlgebra.LQ{T, S, C} where C<:Base.AbstractVector{T}, LinearAlgebra.LU{T, S}, LinearAlgebra.QR{T, S, C} where C<:Base.AbstractVector{T}, LinearAlgebra.QRCompactWY{T, S, C} where C<:Base.AbstractMatrix{T}, LinearAlgebra.QRPivoted{T, S, C} where C<:Base.AbstractVector{T}, LinearAlgebra.SVD{T, var"#s886", S, C} where {var"#s886"<:Core.Real, C<:Base.AbstractVector{var"#s886"}}} where {T, S}  [alias @ LinearAlgebra.LAPACKFactorizations]
struct LinearAlgebra.LDLt{T, S<:Core.AbstractArray{T, 2}} <: LinearAlgebra.Factorization{T} end  [typ @ LinearAlgebra.LDLt]
struct LinearAlgebra.LQ{T, S<:Core.AbstractArray{T, 2}, C<:Core.AbstractArray{T, 1}} <: LinearAlgebra.Factorization{T} end  [typ @ LinearAlgebra.LQ]
struct LinearAlgebra.LQPackedQ{T, S<:Core.AbstractArray{T, 2}, C<:Core.AbstractArray{T, 1}} <: Core.AbstractArray{T, 2} end  [typ @ LinearAlgebra.LQPackedQ]
struct LinearAlgebra.LU{T, S<:Core.AbstractArray{T, 2}, P<:(Base.AbstractVector{<:Core.Integer})} <: LinearAlgebra.Factorization{T} end  [typ @ LinearAlgebra.LU]
const LinearAlgebra.LowerOrUnitLowerTriangular = Union{LinearAlgebra.LowerTriangular{T, S} where S<:Base.AbstractMatrix{T}, LinearAlgebra.UnitLowerTriangular{T, S} where S<:Base.AbstractMatrix{T}} where T  [alias @ LinearAlgebra.LowerOrUnitLowerTriangular]
struct LinearAlgebra.LowerTriangular{T, S<:Core.AbstractArray{T, 2}} <: LinearAlgebra.AbstractTriangular{T, S} end  [typ @ LinearAlgebra.LowerTriangular]
struct LinearAlgebra.MulAddMul{ais1, bis0, TA, TB} end  [typ @ LinearAlgebra.MulAddMul]
struct LinearAlgebra.NoPivot <: LinearAlgebra.PivotingStrategy end  [typ @ LinearAlgebra.NoPivot]
const LinearAlgebra.NumberArray = Core.AbstractArray{T} where T<:Core.Number  [alias @ LinearAlgebra.NumberArray]
abstract type LinearAlgebra.PivotingStrategy end  [typ @ LinearAlgebra.PivotingStrategy]
struct LinearAlgebra.PosDefException <: Core.Exception end  [typ @ LinearAlgebra.PosDefException]
const LinearAlgebra.PossibleTriangularMatrix = Union{LinearAlgebra.AbstractTriangular, LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal}  [alias @ LinearAlgebra.PossibleTriangularMatrix]
struct LinearAlgebra.QR{T, S<:Core.AbstractArray{T, 2}, C<:Core.AbstractArray{T, 1}} <: LinearAlgebra.Factorization{T} end  [typ @ LinearAlgebra.QR]
struct LinearAlgebra.QRCompactWY{S, M<:Core.AbstractArray{S, 2}, C<:Core.AbstractArray{S, 2}} <: LinearAlgebra.Factorization{S} end  [typ @ LinearAlgebra.QRCompactWY]
struct LinearAlgebra.QRCompactWYQ{S, M<:Core.AbstractArray{S, 2}, C<:Core.AbstractArray{S, 2}} <: LinearAlgebra.AbstractQ{S} end  [typ @ LinearAlgebra.QRCompactWYQ]
struct LinearAlgebra.QRIteration <: LinearAlgebra.Algorithm end  [typ @ LinearAlgebra.QRIteration]
struct LinearAlgebra.QRPackedQ{T, S<:Core.AbstractArray{T, 2}, C<:Core.AbstractArray{T, 1}} <: LinearAlgebra.AbstractQ{T} end  [typ @ LinearAlgebra.QRPackedQ]
struct LinearAlgebra.QRPivoted{T, S<:Core.AbstractArray{T, 2}, C<:Core.AbstractArray{T, 1}, P<:(Base.AbstractVector{<:Core.Integer})} <: LinearAlgebra.Factorization{T} end  [typ @ LinearAlgebra.QRPivoted]
struct LinearAlgebra.RankDeficientException <: Core.Exception end  [typ @ LinearAlgebra.RankDeficientException]
const LinearAlgebra.RealHermSym = Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T, S}} where {T<:Core.Real, S}  [alias @ LinearAlgebra.RealHermSym]
const LinearAlgebra.RealHermSymComplexHerm = Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Hermitian{Base.Complex{T}, S}, LinearAlgebra.Symmetric{T, S}} where {T<:Core.Real, S}  [alias @ LinearAlgebra.RealHermSymComplexHerm]
const LinearAlgebra.RealHermSymComplexSym = Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T, S}, LinearAlgebra.Symmetric{Base.Complex{T}, S}} where {T<:Core.Real, S}  [alias @ LinearAlgebra.RealHermSymComplexSym]
const LinearAlgebra.RealOrComplex = Union{Core.Real, Base.Complex}  [alias @ LinearAlgebra.RealOrComplex]
struct LinearAlgebra.Rotation{T} <: LinearAlgebra.AbstractRotation{T} end  [typ @ LinearAlgebra.Rotation]
struct LinearAlgebra.RowMaximum <: LinearAlgebra.PivotingStrategy end  [typ @ LinearAlgebra.RowMaximum]
struct LinearAlgebra.SVD{T, Tr, M<:(Core.AbstractArray{T}), C<:Core.AbstractArray{Tr, 1}} <: LinearAlgebra.Factorization{T} end  [typ @ LinearAlgebra.SVD]
struct LinearAlgebra.Schur{Ty, S<:(Base.AbstractMatrix), C<:(Base.AbstractVector)} <: LinearAlgebra.Factorization{Ty} end  [typ @ LinearAlgebra.Schur]
struct LinearAlgebra.SingularException <: Core.Exception end  [typ @ LinearAlgebra.SingularException]
const LinearAlgebra.StridedMaybeAdjOrTransMat = Union{LinearAlgebra.Adjoint{T, <:Base.StridedMatrix{T} where T}, LinearAlgebra.Transpose{T, <:Base.StridedMatrix{T} where T}, Base.StridedArray{T, 2}} where T  [alias @ LinearAlgebra.StridedMaybeAdjOrTransMat]
const LinearAlgebra.StructuredMatrix = Union{LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.LowerTriangular, LinearAlgebra.SymTridiagonal, LinearAlgebra.Tridiagonal, LinearAlgebra.UnitLowerTriangular, LinearAlgebra.UnitUpperTriangular, LinearAlgebra.UpperTriangular}  [alias @ LinearAlgebra.StructuredMatrix]
struct LinearAlgebra.StructuredMatrixStyle{T} <: Base.Broadcast.AbstractArrayStyle{2} end  [typ @ LinearAlgebra.StructuredMatrixStyle]
struct LinearAlgebra.SymTridiagonal{T, V<:Core.AbstractArray{T, 1}} <: Core.AbstractArray{T, 2} end  [typ @ LinearAlgebra.SymTridiagonal]
struct LinearAlgebra.Symmetric{T, S<:(Core.AbstractArray{<:T, 2})} <: Core.AbstractArray{T, 2} end  [typ @ LinearAlgebra.Symmetric]
struct LinearAlgebra.Transpose{T, S} <: Core.AbstractArray{T, 2} end  [typ @ LinearAlgebra.Transpose]
const LinearAlgebra.TransposeAbsMat = LinearAlgebra.Transpose{T, <:Base.AbstractMatrix} where T  [alias @ LinearAlgebra.TransposeAbsMat]
const LinearAlgebra.TransposeAbsVec = LinearAlgebra.Transpose{T, <:Base.AbstractVector} where T  [alias @ LinearAlgebra.TransposeAbsVec]
struct LinearAlgebra.Tridiagonal{T, V<:Core.AbstractArray{T, 1}} <: Core.AbstractArray{T, 2} end  [typ @ LinearAlgebra.Tridiagonal]
struct LinearAlgebra.UniformScaling{T<:Core.Number} end  [typ @ LinearAlgebra.UniformScaling]
struct LinearAlgebra.UnitLowerTriangular{T, S<:Core.AbstractArray{T, 2}} <: LinearAlgebra.AbstractTriangular{T, S} end  [typ @ LinearAlgebra.UnitLowerTriangular]
struct LinearAlgebra.UnitUpperTriangular{T, S<:Core.AbstractArray{T, 2}} <: LinearAlgebra.AbstractTriangular{T, S} end  [typ @ LinearAlgebra.UnitUpperTriangular]
struct LinearAlgebra.UpperHessenberg{T, S<:Core.AbstractArray{T, 2}} <: Core.AbstractArray{T, 2} end  [typ @ LinearAlgebra.UpperHessenberg]
const LinearAlgebra.UpperOrUnitUpperTriangular = Union{LinearAlgebra.UnitUpperTriangular{T, S} where S<:Base.AbstractMatrix{T}, LinearAlgebra.UpperTriangular{T, S} where S<:Base.AbstractMatrix{T}} where T  [alias @ LinearAlgebra.UpperOrUnitUpperTriangular]
struct LinearAlgebra.UpperTriangular{T, S<:Core.AbstractArray{T, 2}} <: LinearAlgebra.AbstractTriangular{T, S} end  [typ @ LinearAlgebra.UpperTriangular]
struct LinearAlgebra.ZeroPivotException <: Core.Exception end  [typ @ LinearAlgebra.ZeroPivotException]
const LinearAlgebra._Annotated_DenseArrays = Union{LinearAlgebra.AbstractTriangular{T, A} where {T, A<:(Base.Matrix)}, LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.Hermitian{T, A} where {T, A<:(Base.Matrix)}, LinearAlgebra.SymTridiagonal, LinearAlgebra.Symmetric{T, A} where {T, A<:(Base.Matrix)}, LinearAlgebra.Tridiagonal}  [alias @ LinearAlgebra._Annotated_DenseArrays]
const LinearAlgebra._Annotated_Typed_DenseArrays = Union{LinearAlgebra.AbstractTriangular{T, A} where A<:(Base.Matrix), LinearAlgebra.Hermitian{T, A} where A<:(Base.Matrix), LinearAlgebra.Symmetric{T, A} where A<:(Base.Matrix)} where T  [alias @ LinearAlgebra._Annotated_Typed_DenseArrays]
const LinearAlgebra._DenseConcatGroup = Union{Core.Number, LinearAlgebra.AbstractTriangular{T, A} where {T, A<:(Base.Matrix)}, LinearAlgebra.Adjoint{<:Core.Any, <:Base.Vector}, LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.Hermitian{T, A} where {T, A<:(Base.Matrix)}, LinearAlgebra.SymTridiagonal, LinearAlgebra.Symmetric{T, A} where {T, A<:(Base.Matrix)}, LinearAlgebra.Transpose{<:Core.Any, <:Base.Vector}, LinearAlgebra.Tridiagonal, Base.Matrix, Base.Vector}  [alias @ LinearAlgebra._DenseConcatGroup]
const LinearAlgebra._Hermitian_DenseArrays = LinearAlgebra.Hermitian{T, A} where {T, A<:(Base.Matrix)}  [alias @ LinearAlgebra._Hermitian_DenseArrays]
const LinearAlgebra._SpecialArrays = Union{LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.SymTridiagonal, LinearAlgebra.Tridiagonal}  [alias @ LinearAlgebra._SpecialArrays]
const LinearAlgebra._Symmetric_DenseArrays = LinearAlgebra.Symmetric{T, A} where {T, A<:(Base.Matrix)}  [alias @ LinearAlgebra._Symmetric_DenseArrays]
const LinearAlgebra._Triangular_DenseArrays = LinearAlgebra.AbstractTriangular{T, A} where {T, A<:(Base.Matrix)}  [alias @ LinearAlgebra._Triangular_DenseArrays]
const LinearAlgebra._TypedDenseConcatGroup = Union{Base.Vector{T}, Base.Matrix{T}, LinearAlgebra.Adjoint{T, Base.Vector{T}}, LinearAlgebra.Transpose{T, Base.Vector{T}}, LinearAlgebra.AbstractTriangular{T, A} where A<:(Base.Matrix), LinearAlgebra.Hermitian{T, A} where A<:(Base.Matrix), LinearAlgebra.Symmetric{T, A} where A<:(Base.Matrix)} where T  [alias @ LinearAlgebra._TypedDenseConcatGroup]
mutable struct Markdown.Admonition end  [typ @ Markdown.Admonition]
mutable struct Markdown.BlockQuote end  [typ @ Markdown.BlockQuote]
mutable struct Markdown.Bold end  [typ @ Markdown.Bold]
mutable struct Markdown.Code end  [typ @ Markdown.Code]
mutable struct Markdown.Config end  [typ @ Markdown.Config]
mutable struct Markdown.Footnote end  [typ @ Markdown.Footnote]
mutable struct Markdown.Header{level} end  [typ @ Markdown.Header]
mutable struct Markdown.HorizontalRule end  [typ @ Markdown.HorizontalRule]
mutable struct Markdown.Image end  [typ @ Markdown.Image]
const Markdown.InnerConfig = Base.Dict{Core.Char, Base.Vector{Core.Function}}  [alias @ Markdown.InnerConfig]
mutable struct Markdown.Italic end  [typ @ Markdown.Italic]
mutable struct Markdown.LaTeX end  [typ @ Markdown.LaTeX]
mutable struct Markdown.LineBreak end  [typ @ Markdown.LineBreak]
mutable struct Markdown.Link end  [typ @ Markdown.Link]
mutable struct Markdown.List end  [typ @ Markdown.List]
mutable struct Markdown.MD end  [typ @ Markdown.MD]
mutable struct Markdown.Paragraph end  [typ @ Markdown.Paragraph]
mutable struct Markdown.Table end  [typ @ Markdown.Table]
const Printf.Chars = Union{Base.Val{'c'}, Base.Val{'C'}}  [alias @ Printf.Chars]
const Printf.Floats = Union{Base.Val{'e'}, Base.Val{'E'}, Base.Val{'f'}, Base.Val{'F'}, Base.Val{'g'}, Base.Val{'G'}, Base.Val{'a'}, Base.Val{'A'}}  [alias @ Printf.Floats]
struct Printf.Format{S, T} end  [typ @ Printf.Format]
const Printf.HexBases = Union{Base.Val{'x'}, Base.Val{'X'}, Base.Val{'a'}, Base.Val{'A'}}  [alias @ Printf.HexBases]
const Printf.Ints = Union{Base.Val{'d'}, Base.Val{'i'}, Base.Val{'u'}, Base.Val{'x'}, Base.Val{'X'}, Base.Val{'o'}}  [alias @ Printf.Ints]
const Printf.Pointer = Base.Val{'p'}  [alias @ Printf.Pointer]
const Printf.PositionCounter = Base.Val{'n'}  [alias @ Printf.PositionCounter]
struct Printf.Spec{T} end  [typ @ Printf.Spec]
const Printf.Strings = Union{Base.Val{'s'}, Base.Val{'S'}}  [alias @ Printf.Strings]
abstract type Random.AbstractRNG end  [typ @ Random.AbstractRNG]
const Random.BitFloatType = Union{Core.Type{Core.Float16}, Core.Type{Core.Float32}, Core.Type{Core.Float64}}  [alias @ Random.BitFloatType]
struct Random.CloseOpen01{T<:Core.AbstractFloat} <: Random.FloatInterval{T} end  [typ @ Random.CloseOpen01]
const Random.CloseOpen01_64 = Random.CloseOpen01{Core.Float64}  [alias @ Random.CloseOpen01_64]
struct Random.CloseOpen12{T<:Core.AbstractFloat} <: Random.FloatInterval{T} end  [typ @ Random.CloseOpen12]
const Random.CloseOpen12_64 = Random.CloseOpen12{Core.Float64}  [alias @ Random.CloseOpen12_64]
struct Random.DSFMT.DSFMT_state end  [typ @ Random.DSFMT.DSFMT_state]
struct Random.DSFMT.GF2X end  [typ @ Random.DSFMT.GF2X]
abstract type Random.FloatInterval{T<:Core.AbstractFloat} end  [typ @ Random.FloatInterval]
const Random.FloatInterval_64 = Random.FloatInterval{Core.Float64}  [alias @ Random.FloatInterval_64]
struct Random.LessThan{T<:Core.Integer, S} <: Random.Sampler{T} end  [typ @ Random.LessThan]
struct Random.Masked{T<:Core.Integer, S} <: Random.Sampler{T} end  [typ @ Random.Masked]
mutable struct Random.MersenneTwister <: Random.AbstractRNG end  [typ @ Random.MersenneTwister]
struct Random.RandomDevice <: Random.AbstractRNG end  [typ @ Random.RandomDevice]
const Random.Repetition = Union{Base.Val{1}, Base.Val{Inf}}  [alias @ Random.Repetition]
abstract type Random.Sampler{E} end  [typ @ Random.Sampler]
struct Random.SamplerBigFloat{I<:Random.FloatInterval{Base.MPFR.BigFloat}} <: Random.Sampler{BigFloat} end  [typ @ Random.SamplerBigFloat]
struct Random.SamplerBigInt{SP<:Random.Sampler{Core.UInt64}} <: Random.Sampler{BigInt} end  [typ @ Random.SamplerBigInt]
const Random.SamplerBoolBitInteger = Union{Random.SamplerType{Core.Bool}, Random.SamplerType{Core.Int128}, Random.SamplerType{Core.Int16}, Random.SamplerType{Core.Int32}, Random.SamplerType{Core.Int64}, Random.SamplerType{Core.Int8}, Random.SamplerType{Core.UInt128}, Random.SamplerType{Core.UInt16}, Random.SamplerType{Core.UInt32}, Random.SamplerType{Core.UInt64}, Random.SamplerType{Core.UInt8}}  [alias @ Random.SamplerBoolBitInteger]
struct Random.SamplerRangeFast{U<:Union{Core.UInt128, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}, T<:Union{Core.Int128, Core.Int16, Core.Int32, Core.Int64, Core.Int8, Core.UInt128, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}} <: Random.Sampler{T} end  [typ @ Random.SamplerRangeFast]
struct Random.SamplerRangeInt{T<:Core.Integer, U<:Core.Unsigned} <: Random.Sampler{T} end  [typ @ Random.SamplerRangeInt]
struct Random.SamplerRangeNDL{U<:Core.Unsigned, T} <: Random.Sampler{T} end  [typ @ Random.SamplerRangeNDL]
struct Random.SamplerSimple{T, S, E} <: Random.Sampler{E} end  [typ @ Random.SamplerSimple]
struct Random.SamplerTag{T, S, E} <: Random.Sampler{E} end  [typ @ Random.SamplerTag]
struct Random.SamplerTrivial{T, E} <: Random.Sampler{E} end  [typ @ Random.SamplerTrivial]
struct Random.SamplerType{T} <: Random.Sampler{T} end  [typ @ Random.SamplerType]
struct Random.TaskLocalRNG <: Random.AbstractRNG end  [typ @ Random.TaskLocalRNG]
struct Random.UInt10{T} <: Random.UniformBits{T} end  [typ @ Random.UInt10]
struct Random.UInt104{T} <: Random.UniformBits{T} end  [typ @ Random.UInt104]
struct Random.UInt104Raw{T} <: Random.UniformBits{T} end  [typ @ Random.UInt104Raw]
struct Random.UInt10Raw{T} <: Random.UniformBits{T} end  [typ @ Random.UInt10Raw]
struct Random.UInt23{T} <: Random.UniformBits{T} end  [typ @ Random.UInt23]
struct Random.UInt23Raw{T} <: Random.UniformBits{T} end  [typ @ Random.UInt23Raw]
struct Random.UInt2x52{T} <: Random.UniformBits{T} end  [typ @ Random.UInt2x52]
struct Random.UInt2x52Raw{T} <: Random.UniformBits{T} end  [typ @ Random.UInt2x52Raw]
struct Random.UInt52{T} <: Random.UniformBits{T} end  [typ @ Random.UInt52]
struct Random.UInt52Raw{T} <: Random.UniformBits{T} end  [typ @ Random.UInt52Raw]
abstract type Random.UniformBits{T<:Union{Core.Int128, Core.Int16, Core.Int32, Core.Int64, Core.Int8, Core.UInt128, Core.UInt16, Core.UInt32, Core.UInt64, Core.UInt8}} end  [typ @ Random.UniformBits]
struct Random.UniformT{T} <: Random.Sampler{T} end  [typ @ Random.UniformT]
struct Random.UnsafeView{T} <: Core.DenseArray{T, 1} end  [typ @ Random.UnsafeView]
mutable struct Random.Xoshiro <: Random.AbstractRNG end  [typ @ Random.Xoshiro]
const Random.XoshiroSimd.CloseOpen01 = Random.CloseOpen01  [alias @ Random.XoshiroSimd.CloseOpen01]
const Random.XoshiroSimd.SamplerTrivial = Random.SamplerTrivial  [alias @ Random.XoshiroSimd.SamplerTrivial]
const Random.XoshiroSimd.SamplerType = Random.SamplerType  [alias @ Random.XoshiroSimd.SamplerType]
const Random.XoshiroSimd.TaskLocalRNG = Random.TaskLocalRNG  [alias @ Random.XoshiroSimd.TaskLocalRNG]
const Random.XoshiroSimd.UnsafeView = Random.UnsafeView  [alias @ Random.XoshiroSimd.UnsafeView]
const Random.XoshiroSimd.Xoshiro = Random.Xoshiro  [alias @ Random.XoshiroSimd.Xoshiro]
struct Random._GLOBAL_RNG <: Random.AbstractRNG end  [typ @ Random._GLOBAL_RNG]
struct Tar.Header end  [typ @ Tar.Header]
primitive type Dates.AMPM <: Base.Enums.Enum{Int32} 32 end  [typ @ Dates.AMPM]
abstract type Dates.AbstractDateTime <: Dates.TimeType end  [typ @ Dates.AbstractDateTime]
abstract type Dates.AbstractDateToken end  [typ @ Dates.AbstractDateToken]
abstract type Dates.AbstractTime end  [typ @ Dates.AbstractTime]
abstract type Dates.Calendar <: Dates.AbstractTime end  [typ @ Dates.Calendar]
struct Dates.CompoundPeriod <: Dates.AbstractTime end  [typ @ Dates.CompoundPeriod]
const Dates.ConvertiblePeriod = Union{Dates.Day, Dates.Week, Dates.TimePeriod}  [alias @ Dates.ConvertiblePeriod]
struct Dates.Date <: Dates.TimeType end  [typ @ Dates.Date]
struct Dates.DateFormat{S, T<:Core.Tuple} end  [typ @ Dates.DateFormat]
struct Dates.DateFunction end  [typ @ Dates.DateFunction]
struct Dates.DateLocale end  [typ @ Dates.DateLocale]
struct Dates.DatePart{letter} <: Dates.AbstractDateToken end  [typ @ Dates.DatePart]
abstract type Dates.DatePeriod <: Dates.Period end  [typ @ Dates.DatePeriod]
struct Dates.DateTime <: Dates.AbstractDateTime end  [typ @ Dates.DateTime]
struct Dates.Day <: Dates.DatePeriod end  [typ @ Dates.Day]
abstract type Dates.DayOfWeekToken end  [typ @ Dates.DayOfWeekToken]
struct Dates.Decimal3 end  [typ @ Dates.Decimal3]
struct Dates.Delim{T, length} <: Dates.AbstractDateToken end  [typ @ Dates.Delim]
const Dates.FixedPeriod = Union{Dates.Day, Dates.Hour, Dates.Microsecond, Dates.Millisecond, Dates.Minute, Dates.Nanosecond, Dates.Second, Dates.Week}  [alias @ Dates.FixedPeriod]
const Dates.GeneralPeriod = Union{Dates.CompoundPeriod, Dates.Period}  [alias @ Dates.GeneralPeriod]
struct Dates.Hour <: Dates.TimePeriod end  [typ @ Dates.Hour]
struct Dates.ISOCalendar <: Dates.Calendar end  [typ @ Dates.ISOCalendar]
abstract type Dates.Instant <: Dates.AbstractTime end  [typ @ Dates.Instant]
const Dates.Locale = Union{Core.String, Dates.DateLocale}  [alias @ Dates.Locale]
struct Dates.Microsecond <: Dates.TimePeriod end  [typ @ Dates.Microsecond]
struct Dates.Millisecond <: Dates.TimePeriod end  [typ @ Dates.Millisecond]
struct Dates.Minute <: Dates.TimePeriod end  [typ @ Dates.Minute]
struct Dates.Month <: Dates.DatePeriod end  [typ @ Dates.Month]
struct Dates.Nanosecond <: Dates.TimePeriod end  [typ @ Dates.Nanosecond]
const Dates.OtherPeriod = Union{Dates.Month, Dates.Quarter, Dates.Year}  [alias @ Dates.OtherPeriod]
abstract type Dates.Period <: Dates.AbstractTime end  [typ @ Dates.Period]
struct Dates.Quarter <: Dates.DatePeriod end  [typ @ Dates.Quarter]
struct Dates.Second <: Dates.TimePeriod end  [typ @ Dates.Second]
struct Dates.Time <: Dates.TimeType end  [typ @ Dates.Time]
abstract type Dates.TimePeriod <: Dates.Period end  [typ @ Dates.TimePeriod]
abstract type Dates.TimeType <: Dates.AbstractTime end  [typ @ Dates.TimeType]
const Dates.TimeTypeOrPeriod = Union{Dates.Day, Dates.Week, Dates.TimePeriod, Dates.TimeType}  [alias @ Dates.TimeTypeOrPeriod]
abstract type Dates.TimeZone end  [typ @ Dates.TimeZone]
struct Dates.UTC <: Dates.TimeZone end  [typ @ Dates.UTC]
struct Dates.UTInstant{P<:Dates.Period} <: Dates.Instant end  [typ @ Dates.UTInstant]
struct Dates.Week <: Dates.DatePeriod end  [typ @ Dates.Week]
struct Dates.Year <: Dates.DatePeriod end  [typ @ Dates.Year]
abstract type Distributed.AbstractMsg end  [typ @ Distributed.AbstractMsg]
abstract type Distributed.AbstractRemoteRef end  [typ @ Distributed.AbstractRemoteRef]
abstract type Distributed.AbstractWorkerPool end  [typ @ Distributed.AbstractWorkerPool]
struct Distributed.BatchProcessingError <: Core.Exception end  [typ @ Distributed.BatchProcessingError]
mutable struct Distributed.CachingPool <: Distributed.AbstractWorkerPool end  [typ @ Distributed.CachingPool]
struct Distributed.CallMsg{Mode} <: Distributed.AbstractMsg end  [typ @ Distributed.CallMsg]
struct Distributed.CallWaitMsg <: Distributed.AbstractMsg end  [typ @ Distributed.CallWaitMsg]
abstract type Distributed.ClusterManager end  [typ @ Distributed.ClusterManager]
mutable struct Distributed.ClusterSerializer{I<:Core.IO} <: Serialization.AbstractSerializer end  [typ @ Distributed.ClusterSerializer]
struct Distributed.DefaultClusterManager <: Distributed.ClusterManager end  [typ @ Distributed.DefaultClusterManager]
mutable struct Distributed.Future <: Distributed.AbstractRemoteRef end  [typ @ Distributed.Future]
struct Distributed.IdentifySocketAckMsg <: Distributed.AbstractMsg end  [typ @ Distributed.IdentifySocketAckMsg]
struct Distributed.IdentifySocketMsg <: Distributed.AbstractMsg end  [typ @ Distributed.IdentifySocketMsg]
struct Distributed.JoinCompleteMsg <: Distributed.AbstractMsg end  [typ @ Distributed.JoinCompleteMsg]
struct Distributed.JoinPGRPMsg <: Distributed.AbstractMsg end  [typ @ Distributed.JoinPGRPMsg]
struct Distributed.LaunchWorkerError <: Core.Exception end  [typ @ Distributed.LaunchWorkerError]
struct Distributed.LocalManager <: Distributed.ClusterManager end  [typ @ Distributed.LocalManager]
mutable struct Distributed.LocalProcess end  [typ @ Distributed.LocalProcess]
struct Distributed.MsgHeader end  [typ @ Distributed.MsgHeader]
struct Distributed.ProcessExitedException <: Core.Exception end  [typ @ Distributed.ProcessExitedException]
mutable struct Distributed.ProcessGroup end  [typ @ Distributed.ProcessGroup]
struct Distributed.RRID end  [typ @ Distributed.RRID]
mutable struct Distributed.RemoteChannel{T<:Base.AbstractChannel} <: Distributed.AbstractRemoteRef end  [typ @ Distributed.RemoteChannel]
struct Distributed.RemoteDoMsg <: Distributed.AbstractMsg end  [typ @ Distributed.RemoteDoMsg]
struct Distributed.RemoteException <: Core.Exception end  [typ @ Distributed.RemoteException]
mutable struct Distributed.RemoteValue end  [typ @ Distributed.RemoteValue]
struct Distributed.ResultMsg <: Distributed.AbstractMsg end  [typ @ Distributed.ResultMsg]
struct Distributed.SSHManager <: Distributed.ClusterManager end  [typ @ Distributed.SSHManager]
struct Distributed.SyncTake end  [typ @ Distributed.SyncTake]
mutable struct Distributed.Worker end  [typ @ Distributed.Worker]
mutable struct Distributed.WorkerConfig end  [typ @ Distributed.WorkerConfig]
mutable struct Distributed.WorkerPool <: Distributed.AbstractWorkerPool end  [typ @ Distributed.WorkerPool]
primitive type Distributed.WorkerState <: Base.Enums.Enum{Int32} 32 end  [typ @ Distributed.WorkerState]
const InteractiveUtils.CodegenParams = Base.CodegenParams  [alias @ InteractiveUtils.CodegenParams]
abstract type LibGit2.AbstractCredential end  [typ @ LibGit2.AbstractCredential]
abstract type LibGit2.AbstractGitHash end  [typ @ LibGit2.AbstractGitHash]
abstract type LibGit2.AbstractGitObject end  [typ @ LibGit2.AbstractGitObject]
struct LibGit2.BlameHunk end  [typ @ LibGit2.BlameHunk]
struct LibGit2.BlameOptions end  [typ @ LibGit2.BlameOptions]
struct LibGit2.Buffer end  [typ @ LibGit2.Buffer]
struct LibGit2.CachedCredentials end  [typ @ LibGit2.CachedCredentials]
const LibGit2.Callbacks = Base.Dict{Core.Symbol, Tuple{Core.Ptr{Core.Nothing}, Core.Any}}  [alias @ LibGit2.Callbacks]
struct LibGit2.CertHostKey end  [typ @ LibGit2.CertHostKey]
struct LibGit2.CheckoutOptions end  [typ @ LibGit2.CheckoutOptions]
struct LibGit2.CherrypickOptions end  [typ @ LibGit2.CherrypickOptions]
struct LibGit2.CloneOptions end  [typ @ LibGit2.CloneOptions]
struct LibGit2.ConfigEntry end  [typ @ LibGit2.ConfigEntry]
primitive type LibGit2.Consts.DELTA_STATUS <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Consts.DELTA_STATUS]
primitive type LibGit2.Consts.GIT_BRANCH <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Consts.GIT_BRANCH]
primitive type LibGit2.Consts.GIT_CONFIG <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Consts.GIT_CONFIG]
primitive type LibGit2.Consts.GIT_CREDTYPE <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Consts.GIT_CREDTYPE]
primitive type LibGit2.Consts.GIT_FEATURE <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Consts.GIT_FEATURE]
primitive type LibGit2.Consts.GIT_FILEMODE <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Consts.GIT_FILEMODE]
primitive type LibGit2.Consts.GIT_MERGE <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Consts.GIT_MERGE]
primitive type LibGit2.Consts.GIT_MERGE_ANALYSIS <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Consts.GIT_MERGE_ANALYSIS]
primitive type LibGit2.Consts.GIT_MERGE_FILE <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Consts.GIT_MERGE_FILE]
primitive type LibGit2.Consts.GIT_MERGE_FILE_FAVOR <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Consts.GIT_MERGE_FILE_FAVOR]
primitive type LibGit2.Consts.GIT_MERGE_PREFERENCE <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Consts.GIT_MERGE_PREFERENCE]
primitive type LibGit2.Consts.GIT_OPT <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Consts.GIT_OPT]
primitive type LibGit2.Consts.GIT_PROXY <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Consts.GIT_PROXY]
primitive type LibGit2.Consts.GIT_REBASE_OPERATION <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Consts.GIT_REBASE_OPERATION]
primitive type LibGit2.Consts.GIT_REPOSITORY_OPEN <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Consts.GIT_REPOSITORY_OPEN]
primitive type LibGit2.Consts.GIT_SUBMODULE_IGNORE <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Consts.GIT_SUBMODULE_IGNORE]
primitive type LibGit2.Consts.OBJECT <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Consts.OBJECT]
mutable struct LibGit2.CredentialPayload end  [typ @ LibGit2.CredentialPayload]
const LibGit2.Creds = Union{Core.Nothing, LibGit2.AbstractCredential, LibGit2.CachedCredentials, LibGit2.CredentialPayload}  [alias @ LibGit2.Creds]
struct LibGit2.DescribeFormatOptions end  [typ @ LibGit2.DescribeFormatOptions]
struct LibGit2.DescribeOptions end  [typ @ LibGit2.DescribeOptions]
struct LibGit2.DiffDelta end  [typ @ LibGit2.DiffDelta]
struct LibGit2.DiffFile end  [typ @ LibGit2.DiffFile]
struct LibGit2.DiffOptionsStruct end  [typ @ LibGit2.DiffOptionsStruct]
primitive type LibGit2.Error.Class <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Error.Class]
primitive type LibGit2.Error.Code <: Base.Enums.Enum{Int32} 32 end  [typ @ LibGit2.Error.Code]
struct LibGit2.Error.ErrorStruct end  [typ @ LibGit2.Error.ErrorStruct]
struct LibGit2.Error.GitError <: Core.Exception end  [typ @ LibGit2.Error.GitError]
struct LibGit2.FetchHead end  [typ @ LibGit2.FetchHead]
struct LibGit2.FetchOptions end  [typ @ LibGit2.FetchOptions]
const LibGit2.GIT_CONFIG = LibGit2.Consts.GIT_CONFIG  [alias @ LibGit2.GIT_CONFIG]
const LibGit2.GIT_MERGE_FILE = LibGit2.Consts.GIT_MERGE_FILE  [alias @ LibGit2.GIT_MERGE_FILE]
const LibGit2.GIT_MERGE_FILE_FAVOR = LibGit2.Consts.GIT_MERGE_FILE_FAVOR  [alias @ LibGit2.GIT_MERGE_FILE_FAVOR]
const LibGit2.GIT_SUBMODULE_IGNORE = LibGit2.Consts.GIT_SUBMODULE_IGNORE  [alias @ LibGit2.GIT_SUBMODULE_IGNORE]
mutable struct LibGit2.GitAnnotated <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitAnnotated]
mutable struct LibGit2.GitBlame <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitBlame]
mutable struct LibGit2.GitBlob <: LibGit2.GitObject end  [typ @ LibGit2.GitBlob]
mutable struct LibGit2.GitBranchIter <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitBranchIter]
mutable struct LibGit2.GitCommit <: LibGit2.GitObject end  [typ @ LibGit2.GitCommit]
mutable struct LibGit2.GitConfig <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitConfig]
mutable struct LibGit2.GitConfigIter <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitConfigIter]
mutable struct LibGit2.GitCredential end  [typ @ LibGit2.GitCredential]
struct LibGit2.GitCredentialHelper end  [typ @ LibGit2.GitCredentialHelper]
mutable struct LibGit2.GitDescribeResult <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitDescribeResult]
mutable struct LibGit2.GitDiff <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitDiff]
mutable struct LibGit2.GitDiffStats <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitDiffStats]
struct LibGit2.GitHash <: LibGit2.AbstractGitHash end  [typ @ LibGit2.GitHash]
mutable struct LibGit2.GitIndex <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitIndex]
abstract type LibGit2.GitObject <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitObject]
mutable struct LibGit2.GitRebase <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitRebase]
mutable struct LibGit2.GitReference <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitReference]
mutable struct LibGit2.GitRemote <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitRemote]
mutable struct LibGit2.GitRepo <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitRepo]
mutable struct LibGit2.GitRevWalker <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitRevWalker]
struct LibGit2.GitShortHash <: LibGit2.AbstractGitHash end  [typ @ LibGit2.GitShortHash]
mutable struct LibGit2.GitSignature <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitSignature]
mutable struct LibGit2.GitStatus <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitStatus]
mutable struct LibGit2.GitTag <: LibGit2.GitObject end  [typ @ LibGit2.GitTag]
mutable struct LibGit2.GitTree <: LibGit2.GitObject end  [typ @ LibGit2.GitTree]
mutable struct LibGit2.GitTreeEntry <: LibGit2.AbstractGitObject end  [typ @ LibGit2.GitTreeEntry]
mutable struct LibGit2.GitUnknownObject <: LibGit2.GitObject end  [typ @ LibGit2.GitUnknownObject]
struct LibGit2.IndexEntry end  [typ @ LibGit2.IndexEntry]
struct LibGit2.IndexTime end  [typ @ LibGit2.IndexTime]
struct LibGit2.KnownHost end  [typ @ LibGit2.KnownHost]
struct LibGit2.MergeOptions end  [typ @ LibGit2.MergeOptions]
struct LibGit2.ProxyOptions end  [typ @ LibGit2.ProxyOptions]
struct LibGit2.PushOptions end  [typ @ LibGit2.PushOptions]
struct LibGit2.RebaseOperation end  [typ @ LibGit2.RebaseOperation]
struct LibGit2.RebaseOptions end  [typ @ LibGit2.RebaseOptions]
struct LibGit2.RemoteCallbacks end  [typ @ LibGit2.RemoteCallbacks]
mutable struct LibGit2.SSHCredential <: LibGit2.AbstractCredential end  [typ @ LibGit2.SSHCredential]
mutable struct LibGit2.Signature end  [typ @ LibGit2.Signature]
struct LibGit2.SignatureStruct end  [typ @ LibGit2.SignatureStruct]
struct LibGit2.State end  [typ @ LibGit2.State]
struct LibGit2.StatusEntry end  [typ @ LibGit2.StatusEntry]
struct LibGit2.StatusOptions end  [typ @ LibGit2.StatusOptions]
struct LibGit2.StrArrayStruct end  [typ @ LibGit2.StrArrayStruct]
struct LibGit2.TimeStruct end  [typ @ LibGit2.TimeStruct]
struct LibGit2.TransferProgress end  [typ @ LibGit2.TransferProgress]
mutable struct LibGit2.UserPasswordCredential <: LibGit2.AbstractCredential end  [typ @ LibGit2.UserPasswordCredential]
struct Profile.Allocs.Alloc end  [typ @ Profile.Allocs.Alloc]
struct Profile.Allocs.AllocResults end  [typ @ Profile.Allocs.AllocResults]
const Profile.Allocs.BTElement = Core.UInt64  [alias @ Profile.Allocs.BTElement]
const Profile.Allocs.BacktraceCache = Base.Dict{Core.UInt64, Base.Vector{Base.StackTraces.StackFrame}}  [alias @ Profile.Allocs.BacktraceCache]
struct Profile.Allocs.BufferType end  [typ @ Profile.Allocs.BufferType]
struct Profile.Allocs.CorruptType end  [typ @ Profile.Allocs.CorruptType]
struct Profile.Allocs.RawAlloc end  [typ @ Profile.Allocs.RawAlloc]
struct Profile.Allocs.RawBacktrace end  [typ @ Profile.Allocs.RawBacktrace]
struct Profile.Allocs.RawResults end  [typ @ Profile.Allocs.RawResults]
struct Profile.Allocs.UnknownType end  [typ @ Profile.Allocs.UnknownType]
const Profile.LineInfoDict = Base.Dict{Core.UInt64, Base.Vector{Base.StackTraces.StackFrame}}  [alias @ Profile.LineInfoDict]
const Profile.LineInfoFlatDict = Base.Dict{Core.UInt64, Base.StackTraces.StackFrame}  [alias @ Profile.LineInfoFlatDict]
struct Profile.ProfileFormat end  [typ @ Profile.ProfileFormat]
const Profile.StackFrame = Base.StackTraces.StackFrame  [alias @ Profile.StackFrame]
mutable struct Profile.StackFrameTree{T} end  [typ @ Profile.StackFrameTree]
abstract type SparseArrays.AbstractSparseArray{Tv, Ti, N} <: Core.AbstractArray{Tv, N} end  [typ @ SparseArrays.AbstractSparseArray]
const SparseArrays.AbstractSparseMatrix = SparseArrays.AbstractSparseArray{Tv, Ti, 2} where {Tv, Ti}  [alias @ SparseArrays.AbstractSparseMatrix]
abstract type SparseArrays.AbstractSparseMatrixCSC{Tv, Ti<:Core.Integer} <: SparseArrays.AbstractSparseArray{Tv, Ti, 2} end  [typ @ SparseArrays.AbstractSparseMatrixCSC]
const SparseArrays.AbstractSparseMatrixCSCInclAdjointAndTranspose = Union{LinearAlgebra.Adjoint{<:Core.Any, <:SparseArrays.AbstractSparseMatrixCSC}, LinearAlgebra.Transpose{<:Core.Any, <:SparseArrays.AbstractSparseMatrixCSC}, SparseArrays.AbstractSparseMatrixCSC}  [alias @ SparseArrays.AbstractSparseMatrixCSCInclAdjointAndTranspose]
const SparseArrays.AbstractSparseVector = SparseArrays.AbstractSparseArray{Tv, Ti, 1} where {Tv, Ti}  [alias @ SparseArrays.AbstractSparseVector]
const SparseArrays.AbstractTriangular = LinearAlgebra.AbstractTriangular  [alias @ SparseArrays.AbstractTriangular]
const SparseArrays.AbstractTriangularSparse = LinearAlgebra.AbstractTriangular{Tv, <:Union{SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Base.SubArray{Tv, 2, <:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange}} where {Tv, Ti}  [alias @ SparseArrays.AbstractTriangularSparse]
const SparseArrays.AdjOrTransDenseMatrix = Union{LinearAlgebra.Adjoint{<:Core.Any, <:Union{LinearAlgebra.LowerTriangular, LinearAlgebra.UnitLowerTriangular, LinearAlgebra.UnitUpperTriangular, LinearAlgebra.UpperTriangular, Base.StridedMatrix, Base.BitMatrix}}, LinearAlgebra.LowerTriangular, LinearAlgebra.Transpose{<:Core.Any, <:Union{LinearAlgebra.LowerTriangular, LinearAlgebra.UnitLowerTriangular, LinearAlgebra.UnitUpperTriangular, LinearAlgebra.UpperTriangular, Base.StridedMatrix, Base.BitMatrix}}, LinearAlgebra.UnitLowerTriangular, LinearAlgebra.UnitUpperTriangular, LinearAlgebra.UpperTriangular, Base.StridedMatrix, Base.BitMatrix}  [alias @ SparseArrays.AdjOrTransDenseMatrix]
const SparseArrays.AdjOrTransSparseVectorUnion = Union{LinearAlgebra.Adjoint{Tv, var"#s886"}, LinearAlgebra.Transpose{Tv, var"#s886"}} where {Tv, Ti, var"#s886"<:Union{SparseArrays.SparseVector{Tv, Ti}, Base.SubArray{Tv, 1, <:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, Core.Int64}, false}, Base.SubArray{Tv, 1, <:SparseArrays.AbstractSparseVector{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}}, false}}}  [alias @ SparseArrays.AdjOrTransSparseVectorUnion]
const SparseArrays.Array = Core.Array  [alias @ SparseArrays.Array]
const SparseArrays.Complex = Base.Complex  [alias @ SparseArrays.Complex]
const SparseArrays.DenseInputVecOrMat = Union{LinearAlgebra.Adjoint{<:Core.Any, <:Union{LinearAlgebra.LowerTriangular, LinearAlgebra.UnitLowerTriangular, LinearAlgebra.UnitUpperTriangular, LinearAlgebra.UpperTriangular, Base.StridedMatrix, Base.BitMatrix}}, LinearAlgebra.LowerTriangular, LinearAlgebra.Transpose{<:Core.Any, <:Union{LinearAlgebra.LowerTriangular, LinearAlgebra.UnitLowerTriangular, LinearAlgebra.UnitUpperTriangular, LinearAlgebra.UpperTriangular, Base.StridedMatrix, Base.BitMatrix}}, LinearAlgebra.UnitLowerTriangular, LinearAlgebra.UnitUpperTriangular, LinearAlgebra.UpperTriangular, Base.StridedMatrix, Base.StridedVector, Base.BitMatrix, Base.BitVector}  [alias @ SparseArrays.DenseInputVecOrMat]
const SparseArrays.DenseInputVector = Union{Base.BitArray{1}, Union{Core.DenseArray{T, 1}, Base.ReinterpretArray{T, 1, S, A, IsReshaped} where {A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.ReshapedArray{T, 1, A} where A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, Base.SubArray{T, 1, A, I} where {A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.ReshapedArray{T, N, A} where {T, N, A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}, IsReshaped, S}, Base.SubArray{T, N, A, I, true} where {T, N, A<:Core.DenseArray, I<:Union{Tuple{Vararg{Core.Real}}, Tuple{Base.AbstractUnitRange, Vararg{Core.Any}}}}, Core.DenseArray}}, Core.DenseArray}, I<:Tuple{Vararg{Union{Core.Int64, Base.AbstractRange{Core.Int64}, Base.AbstractCartesianIndex, Base.ReshapedArray{T, N, A, Tuple{}} where {T, N, A<:Base.AbstractUnitRange}}}}}} where T}  [alias @ SparseArrays.DenseInputVector]
const SparseArrays.DenseMatrixUnion = Union{LinearAlgebra.LowerTriangular, LinearAlgebra.UnitLowerTriangular, LinearAlgebra.UnitUpperTriangular, LinearAlgebra.UpperTriangular, Base.StridedMatrix, Base.BitMatrix}  [alias @ SparseArrays.DenseMatrixUnion]
const SparseArrays.HigherOrderFns.Broadcasted0 = Base.Broadcast.Broadcasted{Style, Axes, F, Tuple{}} where {Style<:Union{Core.Nothing, Base.Broadcast.BroadcastStyle}, Axes, F}  [alias @ SparseArrays.HigherOrderFns.Broadcasted0]
struct SparseArrays.HigherOrderFns.PromoteToSparse <: Base.Broadcast.AbstractArrayStyle{2} end  [typ @ SparseArrays.HigherOrderFns.PromoteToSparse]
const SparseArrays.HigherOrderFns.SPVM = Union{SparseArrays.HigherOrderFns.SparseMatStyle, SparseArrays.HigherOrderFns.SparseVecStyle}  [alias @ SparseArrays.HigherOrderFns.SPVM]
const SparseArrays.HigherOrderFns.SpBroadcasted1 = Base.Broadcast.Broadcasted{Style, Axes, F, Args} where {Style<:Union{SparseArrays.HigherOrderFns.SparseMatStyle, SparseArrays.HigherOrderFns.SparseVecStyle}, Axes, F, Args<:Tuple{Union{SparseArrays.AbstractSparseMatrixCSC, SparseArrays.SparseVector}}}  [alias @ SparseArrays.HigherOrderFns.SpBroadcasted1]
const SparseArrays.HigherOrderFns.SpBroadcasted2 = Base.Broadcast.Broadcasted{Style, Axes, F, Args} where {Style<:Union{SparseArrays.HigherOrderFns.SparseMatStyle, SparseArrays.HigherOrderFns.SparseVecStyle}, Axes, F, Args<:Tuple{Union{SparseArrays.AbstractSparseMatrixCSC, SparseArrays.SparseVector}, Union{SparseArrays.AbstractSparseMatrixCSC, SparseArrays.SparseVector}}}  [alias @ SparseArrays.HigherOrderFns.SpBroadcasted2]
struct SparseArrays.HigherOrderFns.SparseMatStyle <: Base.Broadcast.AbstractArrayStyle{2} end  [typ @ SparseArrays.HigherOrderFns.SparseMatStyle]
const SparseArrays.HigherOrderFns.SparseOrStructuredMatrix = Union{LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.LowerTriangular, LinearAlgebra.SymTridiagonal, LinearAlgebra.Tridiagonal, LinearAlgebra.UnitLowerTriangular, LinearAlgebra.UnitUpperTriangular, LinearAlgebra.UpperTriangular, SparseArrays.SparseMatrixCSC}  [alias @ SparseArrays.HigherOrderFns.SparseOrStructuredMatrix]
const SparseArrays.HigherOrderFns.SparseVecOrMat = Union{SparseArrays.AbstractSparseMatrixCSC, SparseArrays.SparseVector}  [alias @ SparseArrays.HigherOrderFns.SparseVecOrMat]
struct SparseArrays.HigherOrderFns.SparseVecStyle <: Base.Broadcast.AbstractArrayStyle{1} end  [typ @ SparseArrays.HigherOrderFns.SparseVecStyle]
const SparseArrays.HigherOrderFns.StructuredMatrix = Union{LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.SymTridiagonal, LinearAlgebra.Tridiagonal}  [alias @ SparseArrays.HigherOrderFns.StructuredMatrix]
const SparseArrays.LowerTriangularPlain = Union{LinearAlgebra.LowerTriangular{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}, LinearAlgebra.UnitLowerTriangular{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}} where T  [alias @ SparseArrays.LowerTriangularPlain]
const SparseArrays.LowerTriangularSparse = Union{LinearAlgebra.LowerTriangular{T, <:LinearAlgebra.Adjoint{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.LowerTriangular{T, <:LinearAlgebra.Transpose{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.LowerTriangular{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}, LinearAlgebra.UnitLowerTriangular{T, <:LinearAlgebra.Adjoint{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.UnitLowerTriangular{T, <:LinearAlgebra.Transpose{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.UnitLowerTriangular{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}} where T  [alias @ SparseArrays.LowerTriangularSparse]
const SparseArrays.LowerTriangularWrapped = Union{LinearAlgebra.LowerTriangular{T, <:LinearAlgebra.Adjoint{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.LowerTriangular{T, <:LinearAlgebra.Transpose{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.UnitLowerTriangular{T, <:LinearAlgebra.Adjoint{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.UnitLowerTriangular{T, <:LinearAlgebra.Transpose{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}} where T  [alias @ SparseArrays.LowerTriangularWrapped]
const SparseArrays.SparseColumnView = Base.SubArray{Tv, 1, <:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, Core.Int64}, false} where {Tv, Ti}  [alias @ SparseArrays.SparseColumnView]
struct SparseArrays.SparseMatrixCSC{Tv, Ti<:Core.Integer} <: SparseArrays.AbstractSparseMatrixCSC{Tv, Ti} end  [typ @ SparseArrays.SparseMatrixCSC]
const SparseArrays.SparseMatrixCSCSymmHerm = Union{LinearAlgebra.Hermitian{Tv, <:Union{SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Base.SubArray{Tv, 2, <:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange}}, LinearAlgebra.Symmetric{Tv, <:Union{SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Base.SubArray{Tv, 2, <:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange}}} where {Tv, Ti}  [alias @ SparseArrays.SparseMatrixCSCSymmHerm]
const SparseArrays.SparseMatrixCSCUnion = Union{SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Base.SubArray{Tv, 2, <:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where {Tv, Ti}  [alias @ SparseArrays.SparseMatrixCSCUnion]
const SparseArrays.SparseMatrixCSCView = Base.SubArray{Tv, 2, <:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where {Tv, Ti, I<:Base.AbstractUnitRange}  [alias @ SparseArrays.SparseMatrixCSCView]
const SparseArrays.SparseOrTri = Union{SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Base.SubArray{Tv, 2, <:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange, LinearAlgebra.LowerTriangular{Tv, <:Union{SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Base.SubArray{Tv, 2, <:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange}}, LinearAlgebra.UpperTriangular{Tv, <:Union{SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Base.SubArray{Tv, 2, <:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange}}} where {Tv, Ti}  [alias @ SparseArrays.SparseOrTri]
const SparseArrays.SparseTriangular = Union{LinearAlgebra.LowerTriangular{Tv, <:Union{SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Base.SubArray{Tv, 2, <:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange}}, LinearAlgebra.UpperTriangular{Tv, <:Union{SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Base.SubArray{Tv, 2, <:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange}}} where {Tv, Ti}  [alias @ SparseArrays.SparseTriangular]
struct SparseArrays.SparseVector{Tv, Ti<:Core.Integer} <: SparseArrays.AbstractSparseArray{Tv, Ti, 1} end  [typ @ SparseArrays.SparseVector]
const SparseArrays.SparseVectorUnion = Union{SparseArrays.SparseVector{Tv, Ti}, Base.SubArray{Tv, 1, <:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, Core.Int64}, false}, Base.SubArray{Tv, 1, <:SparseArrays.AbstractSparseVector{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}}, false}} where {Tv, Ti}  [alias @ SparseArrays.SparseVectorUnion]
const SparseArrays.SparseVectorView = Base.SubArray{Tv, 1, <:SparseArrays.AbstractSparseVector{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}}, false} where {Tv, Ti}  [alias @ SparseArrays.SparseVectorView]
const SparseArrays.TriangularSparse = Union{LinearAlgebra.LowerTriangular{T, <:LinearAlgebra.Adjoint{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.LowerTriangular{T, <:LinearAlgebra.Transpose{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.LowerTriangular{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}, LinearAlgebra.UnitLowerTriangular{T, <:LinearAlgebra.Adjoint{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.UnitLowerTriangular{T, <:LinearAlgebra.Transpose{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.UnitLowerTriangular{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}, LinearAlgebra.UnitUpperTriangular{T, <:LinearAlgebra.Adjoint{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.UnitUpperTriangular{T, <:LinearAlgebra.Transpose{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.UnitUpperTriangular{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}, LinearAlgebra.UpperTriangular{T, <:LinearAlgebra.Adjoint{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.UpperTriangular{T, <:LinearAlgebra.Transpose{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.UpperTriangular{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}} where T  [alias @ SparseArrays.TriangularSparse]
const SparseArrays.UnitDiagonalTriangular = Union{LinearAlgebra.UnitLowerTriangular, LinearAlgebra.UnitUpperTriangular}  [alias @ SparseArrays.UnitDiagonalTriangular]
const SparseArrays.UpperTriangularPlain = Union{LinearAlgebra.UnitUpperTriangular{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}, LinearAlgebra.UpperTriangular{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}} where T  [alias @ SparseArrays.UpperTriangularPlain]
const SparseArrays.UpperTriangularSparse = Union{LinearAlgebra.UnitUpperTriangular{T, <:LinearAlgebra.Adjoint{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.UnitUpperTriangular{T, <:LinearAlgebra.Transpose{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.UnitUpperTriangular{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}, LinearAlgebra.UpperTriangular{T, <:LinearAlgebra.Adjoint{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.UpperTriangular{T, <:LinearAlgebra.Transpose{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.UpperTriangular{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}} where T  [alias @ SparseArrays.UpperTriangularSparse]
const SparseArrays.UpperTriangularWrapped = Union{LinearAlgebra.UnitUpperTriangular{T, <:LinearAlgebra.Adjoint{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.UnitUpperTriangular{T, <:LinearAlgebra.Transpose{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.UpperTriangular{T, <:LinearAlgebra.Adjoint{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}, LinearAlgebra.UpperTriangular{T, <:LinearAlgebra.Transpose{T, <:Union{SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Base.SubArray{T, 2, <:SparseArrays.AbstractSparseMatrixCSC{T, Ti}, Tuple{Base.Slice{Base.OneTo{Core.Int64}}, I}} where I<:Base.AbstractUnitRange} where Ti}}} where T  [alias @ SparseArrays.UpperTriangularWrapped]
const SparseArrays.WrapperMatrixTypes = Union{LinearAlgebra.AbstractTriangular{T, MT}, LinearAlgebra.Adjoint{T, MT}, LinearAlgebra.Hermitian{T, MT}, LinearAlgebra.Symmetric{T, MT}, LinearAlgebra.Transpose{T, MT}, LinearAlgebra.UpperHessenberg{T, MT}, Base.SubArray{T, 2, MT}} where {T, MT}  [alias @ SparseArrays.WrapperMatrixTypes]
const SparseArrays._Annotated_SparseConcatArrays = Union{LinearAlgebra.AbstractTriangular{T, A} where {T, A<:Union{LinearAlgebra.Adjoint{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.SymTridiagonal, LinearAlgebra.Transpose{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Tridiagonal, SparseArrays.AbstractSparseMatrixCSC, SparseArrays.SparseVector}}, LinearAlgebra.Hermitian{T, A} where {T, A<:Union{LinearAlgebra.Adjoint{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.SymTridiagonal, LinearAlgebra.Transpose{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Tridiagonal, SparseArrays.AbstractSparseMatrixCSC, SparseArrays.SparseVector}}, LinearAlgebra.Symmetric{T, A} where {T, A<:Union{LinearAlgebra.Adjoint{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.SymTridiagonal, LinearAlgebra.Transpose{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Tridiagonal, SparseArrays.AbstractSparseMatrixCSC, SparseArrays.SparseVector}}}  [alias @ SparseArrays._Annotated_SparseConcatArrays]
const SparseArrays._Hermitian_SparseConcatArrays = LinearAlgebra.Hermitian{T, A} where {T, A<:Union{LinearAlgebra.Adjoint{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.SymTridiagonal, LinearAlgebra.Transpose{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Tridiagonal, SparseArrays.AbstractSparseMatrixCSC, SparseArrays.SparseVector}}  [alias @ SparseArrays._Hermitian_SparseConcatArrays]
const SparseArrays._SparseArrays = Union{LinearAlgebra.Adjoint{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Transpose{<:Core.Any, <:SparseArrays.SparseVector}, SparseArrays.AbstractSparseMatrixCSC, SparseArrays.SparseVector}  [alias @ SparseArrays._SparseArrays]
const SparseArrays._SparseConcatArrays = Union{LinearAlgebra.Adjoint{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.SymTridiagonal, LinearAlgebra.Transpose{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Tridiagonal, SparseArrays.AbstractSparseMatrixCSC, SparseArrays.SparseVector}  [alias @ SparseArrays._SparseConcatArrays]
const SparseArrays._SparseConcatGroup = Union{Core.Number, LinearAlgebra.AbstractTriangular{T, A} where {T, A<:(Base.Matrix)}, LinearAlgebra.AbstractTriangular{T, A} where {T, A<:Union{LinearAlgebra.Adjoint{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.SymTridiagonal, LinearAlgebra.Transpose{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Tridiagonal, SparseArrays.AbstractSparseMatrixCSC, SparseArrays.SparseVector}}, LinearAlgebra.Adjoint{<:Core.Any, <:Base.Vector}, LinearAlgebra.Adjoint{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.Hermitian{T, A} where {T, A<:(Base.Matrix)}, LinearAlgebra.Hermitian{T, A} where {T, A<:Union{LinearAlgebra.Adjoint{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.SymTridiagonal, LinearAlgebra.Transpose{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Tridiagonal, SparseArrays.AbstractSparseMatrixCSC, SparseArrays.SparseVector}}, LinearAlgebra.SymTridiagonal, LinearAlgebra.Symmetric{T, A} where {T, A<:(Base.Matrix)}, LinearAlgebra.Symmetric{T, A} where {T, A<:Union{LinearAlgebra.Adjoint{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.SymTridiagonal, LinearAlgebra.Transpose{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Tridiagonal, SparseArrays.AbstractSparseMatrixCSC, SparseArrays.SparseVector}}, LinearAlgebra.Transpose{<:Core.Any, <:Base.Vector}, LinearAlgebra.Transpose{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Tridiagonal, SparseArrays.AbstractSparseMatrixCSC, SparseArrays.SparseVector, Base.Matrix, Base.Vector}  [alias @ SparseArrays._SparseConcatGroup]
const SparseArrays._StridedOrTriangularMatrix = Union{LinearAlgebra.LowerTriangular{T, S} where S<:Base.AbstractMatrix{T}, LinearAlgebra.UnitLowerTriangular{T, S} where S<:Base.AbstractMatrix{T}, LinearAlgebra.UnitUpperTriangular{T, S} where S<:Base.AbstractMatrix{T}, LinearAlgebra.UpperTriangular{T, S} where S<:Base.AbstractMatrix{T}, Base.StridedArray{T, 2}} where T  [alias @ SparseArrays._StridedOrTriangularMatrix]
const SparseArrays._Symmetric_SparseConcatArrays = LinearAlgebra.Symmetric{T, A} where {T, A<:Union{LinearAlgebra.Adjoint{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.SymTridiagonal, LinearAlgebra.Transpose{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Tridiagonal, SparseArrays.AbstractSparseMatrixCSC, SparseArrays.SparseVector}}  [alias @ SparseArrays._Symmetric_SparseConcatArrays]
const SparseArrays._Triangular_SparseConcatArrays = LinearAlgebra.AbstractTriangular{T, A} where {T, A<:Union{LinearAlgebra.Adjoint{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Bidiagonal, LinearAlgebra.Diagonal, LinearAlgebra.SymTridiagonal, LinearAlgebra.Transpose{<:Core.Any, <:SparseArrays.SparseVector}, LinearAlgebra.Tridiagonal, SparseArrays.AbstractSparseMatrixCSC, SparseArrays.SparseVector}}  [alias @ SparseArrays._Triangular_SparseConcatArrays]
const UUIDs.UUID = Base.UUID  [alias @ UUIDs.UUID]
const REPL.AbstractDisplay = Base.Multimedia.AbstractDisplay  [alias @ REPL.AbstractDisplay]
abstract type REPL.AbstractREPL end  [typ @ REPL.AbstractREPL]
const REPL.AnyDict = Base.Dict{Core.Any, Core.Any}  [alias @ REPL.AnyDict]
mutable struct REPL.BasicREPL <: REPL.AbstractREPL end  [typ @ REPL.BasicREPL]
const REPL.CompletionProvider = REPL.LineEdit.CompletionProvider  [alias @ REPL.CompletionProvider]
const REPL.HistoryProvider = REPL.LineEdit.HistoryProvider  [alias @ REPL.HistoryProvider]
struct REPL.LatexCompletions <: REPL.LineEdit.CompletionProvider end  [typ @ REPL.LatexCompletions]
const REPL.LineEdit.AnyDict = Base.Dict{Core.Any, Core.Any}  [alias @ REPL.LineEdit.AnyDict]
const REPL.LineEdit.BufferLike = Union{REPL.LineEdit.MIState, REPL.LineEdit.ModeState, Base.IOBuffer}  [alias @ REPL.LineEdit.BufferLike]
abstract type REPL.LineEdit.CompletionProvider end  [typ @ REPL.LineEdit.CompletionProvider]
struct REPL.LineEdit.EmptyCompletionProvider <: REPL.LineEdit.CompletionProvider end  [typ @ REPL.LineEdit.EmptyCompletionProvider]
struct REPL.LineEdit.EmptyHistoryProvider <: REPL.LineEdit.HistoryProvider end  [typ @ REPL.LineEdit.EmptyHistoryProvider]
mutable struct REPL.LineEdit.HistoryPrompt <: REPL.LineEdit.TextInterface end  [typ @ REPL.LineEdit.HistoryPrompt]
abstract type REPL.LineEdit.HistoryProvider end  [typ @ REPL.LineEdit.HistoryProvider]
struct REPL.LineEdit.InputAreaState end  [typ @ REPL.LineEdit.InputAreaState]
struct REPL.LineEdit.KeyAlias end  [typ @ REPL.LineEdit.KeyAlias]
mutable struct REPL.LineEdit.MIState end  [typ @ REPL.LineEdit.MIState]
struct REPL.LineEdit.ModalInterface <: REPL.LineEdit.TextInterface end  [typ @ REPL.LineEdit.ModalInterface]
abstract type REPL.LineEdit.ModeState end  [typ @ REPL.LineEdit.ModeState]
struct REPL.LineEdit.Modifiers end  [typ @ REPL.LineEdit.Modifiers]
mutable struct REPL.LineEdit.PrefixHistoryPrompt <: REPL.LineEdit.TextInterface end  [typ @ REPL.LineEdit.PrefixHistoryPrompt]
mutable struct REPL.LineEdit.PrefixSearchState <: REPL.LineEdit.ModeState end  [typ @ REPL.LineEdit.PrefixSearchState]
mutable struct REPL.LineEdit.Prompt <: REPL.LineEdit.TextInterface end  [typ @ REPL.LineEdit.Prompt]
mutable struct REPL.LineEdit.PromptState <: REPL.LineEdit.ModeState end  [typ @ REPL.LineEdit.PromptState]
const REPL.LineEdit.Region = Core.Pair{Core.Int64, Core.Int64}  [alias @ REPL.LineEdit.Region]
mutable struct REPL.LineEdit.SearchState <: REPL.LineEdit.ModeState end  [typ @ REPL.LineEdit.SearchState]
const REPL.LineEdit.State = Union{REPL.LineEdit.MIState, REPL.LineEdit.ModeState}  [alias @ REPL.LineEdit.State]
const REPL.LineEdit.StringLike = Union{Core.Char, Base.SubString{Core.String}, Core.String}  [alias @ REPL.LineEdit.StringLike]
abstract type REPL.LineEdit.TextInterface end  [typ @ REPL.LineEdit.TextInterface]
mutable struct REPL.LineEditREPL <: REPL.AbstractREPL end  [typ @ REPL.LineEditREPL]
const REPL.MIState = REPL.LineEdit.MIState  [alias @ REPL.MIState]
struct REPL.Message end  [typ @ REPL.Message]
mutable struct REPL.Options end  [typ @ REPL.Options]
const REPL.PromptState = REPL.LineEdit.PromptState  [alias @ REPL.PromptState]
mutable struct REPL.REPLBackend end  [typ @ REPL.REPLBackend]
struct REPL.REPLBackendRef end  [typ @ REPL.REPLBackendRef]
mutable struct REPL.REPLCompletionProvider <: REPL.LineEdit.CompletionProvider end  [typ @ REPL.REPLCompletionProvider]
struct REPL.REPLCompletions.BslashCompletion <: REPL.REPLCompletions.Completion end  [typ @ REPL.REPLCompletions.BslashCompletion]
abstract type REPL.REPLCompletions.Completion end  [typ @ REPL.REPLCompletions.Completion]
const REPL.REPLCompletions.Completions = Tuple{Base.Vector{REPL.REPLCompletions.Completion}, Base.UnitRange{Core.Int64}, Core.Bool}  [alias @ REPL.REPLCompletions.Completions]
struct REPL.REPLCompletions.DictCompletion <: REPL.REPLCompletions.Completion end  [typ @ REPL.REPLCompletions.DictCompletion]
struct REPL.REPLCompletions.FieldCompletion <: REPL.REPLCompletions.Completion end  [typ @ REPL.REPLCompletions.FieldCompletion]
struct REPL.REPLCompletions.KeywordCompletion <: REPL.REPLCompletions.Completion end  [typ @ REPL.REPLCompletions.KeywordCompletion]
struct REPL.REPLCompletions.MethodCompletion <: REPL.REPLCompletions.Completion end  [typ @ REPL.REPLCompletions.MethodCompletion]
struct REPL.REPLCompletions.ModuleCompletion <: REPL.REPLCompletions.Completion end  [typ @ REPL.REPLCompletions.ModuleCompletion]
struct REPL.REPLCompletions.PackageCompletion <: REPL.REPLCompletions.Completion end  [typ @ REPL.REPLCompletions.PackageCompletion]
struct REPL.REPLCompletions.PathCompletion <: REPL.REPLCompletions.Completion end  [typ @ REPL.REPLCompletions.PathCompletion]
struct REPL.REPLCompletions.PropertyCompletion <: REPL.REPLCompletions.Completion end  [typ @ REPL.REPLCompletions.PropertyCompletion]
struct REPL.REPLCompletions.ShellCompletion <: REPL.REPLCompletions.Completion end  [typ @ REPL.REPLCompletions.ShellCompletion]
struct REPL.REPLCompletions.TextCompletion <: REPL.REPLCompletions.Completion end  [typ @ REPL.REPLCompletions.TextCompletion]
struct REPL.REPLDisplay{R<:REPL.AbstractREPL} <: Base.Multimedia.AbstractDisplay end  [typ @ REPL.REPLDisplay]
mutable struct REPL.REPLHistoryProvider <: REPL.LineEdit.HistoryProvider end  [typ @ REPL.REPLHistoryProvider]
mutable struct REPL.ShellCompletionProvider <: REPL.LineEdit.CompletionProvider end  [typ @ REPL.ShellCompletionProvider]
mutable struct REPL.StreamREPL <: REPL.AbstractREPL end  [typ @ REPL.StreamREPL]
abstract type REPL.TerminalMenus.AbstractConfig end  [typ @ REPL.TerminalMenus.AbstractConfig]
abstract type REPL.TerminalMenus.AbstractMenu end  [typ @ REPL.TerminalMenus.AbstractMenu]
struct REPL.TerminalMenus.Config <: REPL.TerminalMenus.AbstractConfig end  [typ @ REPL.TerminalMenus.Config]
const REPL.TerminalMenus.ConfiguredMenu = REPL.TerminalMenus._ConfiguredMenu{<:REPL.TerminalMenus.AbstractConfig}  [alias @ REPL.TerminalMenus.ConfiguredMenu]
primitive type REPL.TerminalMenus.Key <: Base.Enums.Enum{Int32} 32 end  [typ @ REPL.TerminalMenus.Key]
struct REPL.TerminalMenus.MultiSelectConfig <: REPL.TerminalMenus.AbstractConfig end  [typ @ REPL.TerminalMenus.MultiSelectConfig]
mutable struct REPL.TerminalMenus.MultiSelectMenu{C} <: REPL.TerminalMenus._ConfiguredMenu{C} end  [typ @ REPL.TerminalMenus.MultiSelectMenu]
mutable struct REPL.TerminalMenus.Pager{C} <: REPL.TerminalMenus._ConfiguredMenu{C} end  [typ @ REPL.TerminalMenus.Pager]
mutable struct REPL.TerminalMenus.RadioMenu{C} <: REPL.TerminalMenus._ConfiguredMenu{C} end  [typ @ REPL.TerminalMenus.RadioMenu]
abstract type REPL.TerminalMenus._ConfiguredMenu{C} <: REPL.TerminalMenus.AbstractMenu end  [typ @ REPL.TerminalMenus._ConfiguredMenu]
abstract type REPL.Terminals.AbstractTerminal <: Base.AbstractPipe end  [typ @ REPL.Terminals.AbstractTerminal]
mutable struct REPL.Terminals.TTYTerminal <: REPL.Terminals.UnixTerminal end  [typ @ REPL.Terminals.TTYTerminal]
mutable struct REPL.Terminals.TerminalBuffer <: REPL.Terminals.UnixTerminal end  [typ @ REPL.Terminals.TerminalBuffer]
abstract type REPL.Terminals.TextTerminal <: REPL.Terminals.AbstractTerminal end  [typ @ REPL.Terminals.TextTerminal]
abstract type REPL.Terminals.UnixTerminal <: REPL.Terminals.TextTerminal end  [typ @ REPL.Terminals.UnixTerminal]
const REPL.TextInterface = REPL.LineEdit.TextInterface  [alias @ REPL.TextInterface]
const SharedArrays.IndexStyle = Base.IndexStyle  [alias @ SharedArrays.IndexStyle]
const SharedArrays.RRID = Distributed.RRID  [alias @ SharedArrays.RRID]
mutable struct SharedArrays.SharedArray{T, N} <: Core.DenseArray{T, N} end  [typ @ SharedArrays.SharedArray]
const SharedArrays.SharedMatrix = SharedArrays.SharedArray{T, 2} where T  [alias @ SharedArrays.SharedMatrix]
const SharedArrays.SharedVector = SharedArrays.SharedArray{T, 1} where T  [alias @ SharedArrays.SharedVector]
const SuiteSparse.CHOLMOD.AbstractSparseMatrix = SparseArrays.AbstractSparseArray{Tv, Ti, 2} where {Tv, Ti}  [alias @ SuiteSparse.CHOLMOD.AbstractSparseMatrix]
struct SuiteSparse.CHOLMOD.CHOLMODException <: Core.Exception end  [typ @ SuiteSparse.CHOLMOD.CHOLMODException]
mutable struct SuiteSparse.CHOLMOD.Dense{Tv<:Union{Core.Float64, Base.ComplexF64}} <: Core.DenseArray{Tv, 2} end  [typ @ SuiteSparse.CHOLMOD.Dense]
mutable struct SuiteSparse.CHOLMOD.Factor{Tv<:Union{Core.Float64, Base.ComplexF64}} <: LinearAlgebra.Factorization{Tv} end  [typ @ SuiteSparse.CHOLMOD.Factor]
mutable struct SuiteSparse.CHOLMOD.FactorComponent{Tv, S} <: Core.AbstractArray{Tv, 2} end  [typ @ SuiteSparse.CHOLMOD.FactorComponent]
const SuiteSparse.CHOLMOD.ITypes = Union{Core.Int32, Core.Int64}  [alias @ SuiteSparse.CHOLMOD.ITypes]
const SuiteSparse.CHOLMOD.IndexCartesian = Base.IndexCartesian  [alias @ SuiteSparse.CHOLMOD.IndexCartesian]
const SuiteSparse.CHOLMOD.IndexLinear = Base.IndexLinear  [alias @ SuiteSparse.CHOLMOD.IndexLinear]
const SuiteSparse.CHOLMOD.IndexStyle = Base.IndexStyle  [alias @ SuiteSparse.CHOLMOD.IndexStyle]
const SuiteSparse.CHOLMOD.RealHermSymComplexHermF64SSL = Union{LinearAlgebra.Hermitian{Base.ComplexF64, SparseArrays.SparseMatrixCSC{Base.ComplexF64, Core.Int64}}, LinearAlgebra.Hermitian{Core.Float64, SparseArrays.SparseMatrixCSC{Core.Float64, Core.Int64}}, LinearAlgebra.Symmetric{Core.Float64, SparseArrays.SparseMatrixCSC{Core.Float64, Core.Int64}}}  [alias @ SuiteSparse.CHOLMOD.RealHermSymComplexHermF64SSL]
mutable struct SuiteSparse.CHOLMOD.Sparse{Tv<:Union{Core.Float64, Base.ComplexF64}} <: SparseArrays.AbstractSparseArray{Tv, Int64, 2} end  [typ @ SuiteSparse.CHOLMOD.Sparse]
const SuiteSparse.CHOLMOD.SparseMatrixCSC = SparseArrays.SparseMatrixCSC  [alias @ SuiteSparse.CHOLMOD.SparseMatrixCSC]
const SuiteSparse.CHOLMOD.SparseVecOrMat = Union{SparseArrays.SparseMatrixCSC{Tv, Ti}, SparseArrays.SparseVector{Tv, Ti}} where {Tv, Ti}  [alias @ SuiteSparse.CHOLMOD.SparseVecOrMat]
const SuiteSparse.CHOLMOD.StridedVecOrMatInclAdjAndTrans = Union{LinearAlgebra.Adjoint{<:Core.Any, <:Base.StridedVecOrMat}, LinearAlgebra.Transpose{<:Core.Any, <:Base.StridedVecOrMat}, Base.StridedVecOrMat}  [alias @ SuiteSparse.CHOLMOD.StridedVecOrMatInclAdjAndTrans]
const SuiteSparse.CHOLMOD.SuiteSparseStruct = Union{SuiteSparse.LibSuiteSparse.cholmod_dense_struct, SuiteSparse.LibSuiteSparse.cholmod_factor_struct, SuiteSparse.LibSuiteSparse.cholmod_sparse_struct}  [alias @ SuiteSparse.CHOLMOD.SuiteSparseStruct]
const SuiteSparse.CHOLMOD.SuiteSparse_long = Core.Int64  [alias @ SuiteSparse.CHOLMOD.SuiteSparse_long]
const SuiteSparse.CHOLMOD.VRealTypes = Core.Float64  [alias @ SuiteSparse.CHOLMOD.VRealTypes]
const SuiteSparse.CHOLMOD.VTypes = Union{Core.Float64, Base.ComplexF64}  [alias @ SuiteSparse.CHOLMOD.VTypes]
const SuiteSparse.LibSuiteSparse.BLAS_INT = Core.Int32  [alias @ SuiteSparse.LibSuiteSparse.BLAS_INT]
const SuiteSparse.LibSuiteSparse.Complex = Core.Float64  [alias @ SuiteSparse.LibSuiteSparse.Complex]
const SuiteSparse.LibSuiteSparse.SuiteSparseQR_C_factorization = SuiteSparse.LibSuiteSparse.SuiteSparseQR_C_factorization_struct  [alias @ SuiteSparse.LibSuiteSparse.SuiteSparseQR_C_factorization]
mutable struct SuiteSparse.LibSuiteSparse.SuiteSparseQR_C_factorization_struct end  [typ @ SuiteSparse.LibSuiteSparse.SuiteSparseQR_C_factorization_struct]
mutable struct SuiteSparse.LibSuiteSparse.SuiteSparse_config_struct end  [typ @ SuiteSparse.LibSuiteSparse.SuiteSparse_config_struct]
const SuiteSparse.LibSuiteSparse.SuiteSparse_long = Core.Int64  [alias @ SuiteSparse.LibSuiteSparse.SuiteSparse_long]
const SuiteSparse.LibSuiteSparse.cholmod_common = SuiteSparse.LibSuiteSparse.cholmod_common_struct  [alias @ SuiteSparse.LibSuiteSparse.cholmod_common]
mutable struct SuiteSparse.LibSuiteSparse.cholmod_common_struct end  [typ @ SuiteSparse.LibSuiteSparse.cholmod_common_struct]
const SuiteSparse.LibSuiteSparse.cholmod_dense = SuiteSparse.LibSuiteSparse.cholmod_dense_struct  [alias @ SuiteSparse.LibSuiteSparse.cholmod_dense]
mutable struct SuiteSparse.LibSuiteSparse.cholmod_dense_struct end  [typ @ SuiteSparse.LibSuiteSparse.cholmod_dense_struct]
mutable struct SuiteSparse.LibSuiteSparse.cholmod_descendant_score_t end  [typ @ SuiteSparse.LibSuiteSparse.cholmod_descendant_score_t]
const SuiteSparse.LibSuiteSparse.cholmod_factor = SuiteSparse.LibSuiteSparse.cholmod_factor_struct  [alias @ SuiteSparse.LibSuiteSparse.cholmod_factor]
mutable struct SuiteSparse.LibSuiteSparse.cholmod_factor_struct end  [typ @ SuiteSparse.LibSuiteSparse.cholmod_factor_struct]
struct SuiteSparse.LibSuiteSparse.cholmod_method_struct end  [typ @ SuiteSparse.LibSuiteSparse.cholmod_method_struct]
const SuiteSparse.LibSuiteSparse.cholmod_sparse = SuiteSparse.LibSuiteSparse.cholmod_sparse_struct  [alias @ SuiteSparse.LibSuiteSparse.cholmod_sparse]
mutable struct SuiteSparse.LibSuiteSparse.cholmod_sparse_struct end  [typ @ SuiteSparse.LibSuiteSparse.cholmod_sparse_struct]
const SuiteSparse.LibSuiteSparse.cholmod_triplet = SuiteSparse.LibSuiteSparse.cholmod_triplet_struct  [alias @ SuiteSparse.LibSuiteSparse.cholmod_triplet]
mutable struct SuiteSparse.LibSuiteSparse.cholmod_triplet_struct end  [typ @ SuiteSparse.LibSuiteSparse.cholmod_triplet_struct]
const SuiteSparse.LibSuiteSparse.descendantScore = SuiteSparse.LibSuiteSparse.cholmod_descendant_score_t  [alias @ SuiteSparse.LibSuiteSparse.descendantScore]
struct SuiteSparse.SPQR.QRSparse{Tv, Ti} <: LinearAlgebra.Factorization{Tv} end  [typ @ SuiteSparse.SPQR.QRSparse]
struct SuiteSparse.SPQR.QRSparseQ{Tv<:Union{Core.Float64, Base.ComplexF64}, Ti<:Core.Integer} <: LinearAlgebra.AbstractQ{Tv} end  [typ @ SuiteSparse.SPQR.QRSparseQ]
const SuiteSparse.UMFPACK.AbstractSerializer = Serialization.AbstractSerializer  [alias @ SuiteSparse.UMFPACK.AbstractSerializer]
const SuiteSparse.UMFPACK.Factorization = LinearAlgebra.Factorization  [alias @ SuiteSparse.UMFPACK.Factorization]
struct SuiteSparse.UMFPACK.MatrixIllConditionedException <: Core.Exception end  [typ @ SuiteSparse.UMFPACK.MatrixIllConditionedException]
const SuiteSparse.UMFPACK.SuiteSparse_long = Core.Int64  [alias @ SuiteSparse.UMFPACK.SuiteSparse_long]
const SuiteSparse.UMFPACK.UMFITypes = Union{Core.Int32, Core.Int64}  [alias @ SuiteSparse.UMFPACK.UMFITypes]
const SuiteSparse.UMFPACK.UMFVTypes = Union{Core.Float64, Base.ComplexF64}  [alias @ SuiteSparse.UMFPACK.UMFVTypes]
mutable struct SuiteSparse.UMFPACK.UmfpackLU{Tv<:Union{Core.Float64, Base.ComplexF64}, Ti<:Union{Core.Int32, Core.Int64}} <: LinearAlgebra.Factorization{Tv} end  [typ @ SuiteSparse.UMFPACK.UmfpackLU]
const TOML.Internals.Printer.MbyFunc = Union{Core.Nothing, Core.Function}  [alias @ TOML.Internals.Printer.MbyFunc]
const TOML.Internals.Printer.TOMLValue = Union{Dates.Date, Dates.DateTime, Dates.Time, Core.AbstractFloat, Core.AbstractString, Core.Integer, Base.AbstractDict, Base.AbstractVector}  [alias @ TOML.Internals.Printer.TOMLValue]
const TOML.Parser = Base.TOML.Parser  [alias @ TOML.Parser]
const TOML.ParserError = Base.TOML.ParserError  [alias @ TOML.ParserError]
abstract type Test.AbstractTestSet end  [typ @ Test.AbstractTestSet]
struct Test.Broken <: Test.Result end  [typ @ Test.Broken]
mutable struct Test.DefaultTestSet <: Test.AbstractTestSet end  [typ @ Test.DefaultTestSet]
struct Test.Error <: Test.Result end  [typ @ Test.Error]
abstract type Test.ExecutionResult end  [typ @ Test.ExecutionResult]
struct Test.Fail <: Test.Result end  [typ @ Test.Fail]
struct Test.FallbackTestSet <: Test.AbstractTestSet end  [typ @ Test.FallbackTestSet]
struct Test.FallbackTestSetException <: Core.Exception end  [typ @ Test.FallbackTestSetException]
struct Test.GenericArray{T, N} <: Core.AbstractArray{T, N} end  [typ @ Test.GenericArray]
struct Test.GenericDict{K, V} <: Base.AbstractDict{K, V} end  [typ @ Test.GenericDict]
struct Test.GenericOrder{T} end  [typ @ Test.GenericOrder]
struct Test.GenericSet{T} <: Base.AbstractSet{T} end  [typ @ Test.GenericSet]
struct Test.GenericString <: Core.AbstractString end  [typ @ Test.GenericString]
struct Test.Ignored end  [typ @ Test.Ignored]
struct Test.LogRecord end  [typ @ Test.LogRecord]
mutable struct Test.LogTestFailure <: Test.Result end  [typ @ Test.LogTestFailure]
struct Test.Pass <: Test.Result end  [typ @ Test.Pass]
abstract type Test.Result end  [typ @ Test.Result]
struct Test.Returned <: Test.ExecutionResult end  [typ @ Test.Returned]
mutable struct Test.TestLogger <: Base.CoreLogging.AbstractLogger end  [typ @ Test.TestLogger]
struct Test.TestSetException <: Core.Exception end  [typ @ Test.TestSetException]
struct Test.Threw <: Test.ExecutionResult end  [typ @ Test.Threw]
const LibCURL.CURL = Core.Nothing  [alias @ LibCURL.CURL]
const LibCURL.CURLFORMcode = Core.UInt32  [alias @ LibCURL.CURLFORMcode]
const LibCURL.CURLINFO = Core.UInt32  [alias @ LibCURL.CURLINFO]
const LibCURL.CURLM = Core.Nothing  [alias @ LibCURL.CURLM]
const LibCURL.CURLMSG = Core.UInt32  [alias @ LibCURL.CURLMSG]
const LibCURL.CURLMcode = Core.Int32  [alias @ LibCURL.CURLMcode]
const LibCURL.CURLMoption = Core.UInt32  [alias @ LibCURL.CURLMoption]
mutable struct LibCURL.CURLMsg end  [typ @ LibCURL.CURLMsg]
const LibCURL.CURLSH = Core.Nothing  [alias @ LibCURL.CURLSH]
const LibCURL.CURLSHcode = Core.UInt32  [alias @ LibCURL.CURLSHcode]
const LibCURL.CURLSHoption = Core.UInt32  [alias @ LibCURL.CURLSHoption]
const LibCURL.CURL_NETRC_OPTION = Core.UInt32  [alias @ LibCURL.CURL_NETRC_OPTION]
const LibCURL.CURL_SUFFIX_CURL_OFF_T = Core.Int64  [alias @ LibCURL.CURL_SUFFIX_CURL_OFF_T]
const LibCURL.CURL_SUFFIX_CURL_OFF_TU = Core.UInt64  [alias @ LibCURL.CURL_SUFFIX_CURL_OFF_TU]
const LibCURL.CURL_TLSAUTH = Core.UInt32  [alias @ LibCURL.CURL_TLSAUTH]
const LibCURL.CURL_TYPEOF_CURL_OFF_T = Core.Int64  [alias @ LibCURL.CURL_TYPEOF_CURL_OFF_T]
const LibCURL.CURL_TYPEOF_CURL_SOCKLEN_T = Core.Int32  [alias @ LibCURL.CURL_TYPEOF_CURL_SOCKLEN_T]
const LibCURL.CURLcode = Core.UInt32  [alias @ LibCURL.CURLcode]
const LibCURL.CURLformoption = Core.UInt32  [alias @ LibCURL.CURLformoption]
const LibCURL.CURLoption = Core.UInt32  [alias @ LibCURL.CURLoption]
const LibCURL.CURLsslset = Core.UInt32  [alias @ LibCURL.CURLsslset]
const LibCURL.CURLversion = Core.UInt32  [alias @ LibCURL.CURLversion]
const LibCURL.curl_TimeCond = Core.UInt32  [alias @ LibCURL.curl_TimeCond]
const LibCURL.curl_calloc_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_calloc_callback]
mutable struct LibCURL.curl_certinfo end  [typ @ LibCURL.curl_certinfo]
const LibCURL.curl_chunk_bgn_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_chunk_bgn_callback]
const LibCURL.curl_chunk_end_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_chunk_end_callback]
const LibCURL.curl_closepolicy = Core.UInt32  [alias @ LibCURL.curl_closepolicy]
const LibCURL.curl_closesocket_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_closesocket_callback]
const LibCURL.curl_conv_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_conv_callback]
const LibCURL.curl_debug_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_debug_callback]
mutable struct LibCURL.curl_fileinfo end  [typ @ LibCURL.curl_fileinfo]
const LibCURL.curl_fnmatch_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_fnmatch_callback]
const LibCURL.curl_formget_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_formget_callback]
mutable struct LibCURL.curl_forms end  [typ @ LibCURL.curl_forms]
const LibCURL.curl_free_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_free_callback]
const LibCURL.curl_ftpauth = Core.UInt32  [alias @ LibCURL.curl_ftpauth]
const LibCURL.curl_ftpccc = Core.UInt32  [alias @ LibCURL.curl_ftpccc]
const LibCURL.curl_ftpcreatedir = Core.UInt32  [alias @ LibCURL.curl_ftpcreatedir]
const LibCURL.curl_ftpmethod = Core.UInt32  [alias @ LibCURL.curl_ftpmethod]
const LibCURL.curl_ftpssl = Core.UInt32  [alias @ LibCURL.curl_ftpssl]
mutable struct LibCURL.curl_httppost end  [typ @ LibCURL.curl_httppost]
const LibCURL.curl_infotype = Core.UInt32  [alias @ LibCURL.curl_infotype]
const LibCURL.curl_ioctl_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_ioctl_callback]
mutable struct LibCURL.curl_khkey end  [typ @ LibCURL.curl_khkey]
const LibCURL.curl_khmatch = Core.UInt32  [alias @ LibCURL.curl_khmatch]
const LibCURL.curl_khstat = Core.UInt32  [alias @ LibCURL.curl_khstat]
const LibCURL.curl_khtype = Core.UInt32  [alias @ LibCURL.curl_khtype]
const LibCURL.curl_lock_access = Core.UInt32  [alias @ LibCURL.curl_lock_access]
const LibCURL.curl_lock_data = Core.UInt32  [alias @ LibCURL.curl_lock_data]
const LibCURL.curl_lock_function = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_lock_function]
const LibCURL.curl_malloc_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_malloc_callback]
const LibCURL.curl_mime = Core.Nothing  [alias @ LibCURL.curl_mime]
struct LibCURL.curl_mime_s end  [typ @ LibCURL.curl_mime_s]
const LibCURL.curl_mimepart = Core.Nothing  [alias @ LibCURL.curl_mimepart]
struct LibCURL.curl_mimepart_s end  [typ @ LibCURL.curl_mimepart_s]
const LibCURL.curl_multi_timer_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_multi_timer_callback]
const LibCURL.curl_off_t = Core.Int64  [alias @ LibCURL.curl_off_t]
const LibCURL.curl_opensocket_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_opensocket_callback]
const LibCURL.curl_progress_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_progress_callback]
const LibCURL.curl_proxytype = Core.UInt32  [alias @ LibCURL.curl_proxytype]
const LibCURL.curl_push_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_push_callback]
struct LibCURL.curl_pushheaders end  [typ @ LibCURL.curl_pushheaders]
const LibCURL.curl_read_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_read_callback]
const LibCURL.curl_realloc_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_realloc_callback]
const LibCURL.curl_resolver_start_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_resolver_start_callback]
const LibCURL.curl_seek_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_seek_callback]
mutable struct LibCURL.curl_slist end  [typ @ LibCURL.curl_slist]
mutable struct LibCURL.curl_sockaddr end  [typ @ LibCURL.curl_sockaddr]
const LibCURL.curl_socket_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_socket_callback]
const LibCURL.curl_socket_t = Core.Int32  [alias @ LibCURL.curl_socket_t]
const LibCURL.curl_sockopt_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_sockopt_callback]
const LibCURL.curl_sshkeycallback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_sshkeycallback]
const LibCURL.curl_ssl_backend = Core.Nothing  [alias @ LibCURL.curl_ssl_backend]
const LibCURL.curl_ssl_ctx_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_ssl_ctx_callback]
const LibCURL.curl_sslbackend = Core.UInt32  [alias @ LibCURL.curl_sslbackend]
const LibCURL.curl_strdup_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_strdup_callback]
mutable struct LibCURL.curl_tlssessioninfo end  [typ @ LibCURL.curl_tlssessioninfo]
const LibCURL.curl_unlock_function = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_unlock_function]
const LibCURL.curl_usessl = Core.UInt32  [alias @ LibCURL.curl_usessl]
mutable struct LibCURL.curl_version_info_data end  [typ @ LibCURL.curl_version_info_data]
mutable struct LibCURL.curl_waitfd end  [typ @ LibCURL.curl_waitfd]
const LibCURL.curl_write_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_write_callback]
const LibCURL.curl_xferinfo_callback = Core.Ptr{Core.Nothing}  [alias @ LibCURL.curl_xferinfo_callback]
const LibCURL.curlfiletype = Core.UInt32  [alias @ LibCURL.curlfiletype]
const LibCURL.curliocmd = Core.UInt32  [alias @ LibCURL.curliocmd]
const LibCURL.curlioerr = Core.UInt32  [alias @ LibCURL.curlioerr]
const LibCURL.curlsocktype = Core.UInt32  [alias @ LibCURL.curlsocktype]
const LibCURL.size_t = Core.UInt64  [alias @ LibCURL.size_t]
const LibCURL.socklen_t = Core.Int32  [alias @ LibCURL.socklen_t]
const LibCURL.time_t = Core.Int64  [alias @ LibCURL.time_t]
struct Downloads.Curl.CURLMsg end  [typ @ Downloads.Curl.CURLMsg]
mutable struct Downloads.Curl.Easy end  [typ @ Downloads.Curl.Easy]
mutable struct Downloads.Curl.Multi end  [typ @ Downloads.Curl.Multi]
struct Downloads.Curl.curl_slist_t end  [typ @ Downloads.Curl.curl_slist_t]
const Downloads.Curl.curl_socket_t = Core.Int32  [alias @ Downloads.Curl.curl_socket_t]
mutable struct Downloads.Downloader end  [typ @ Downloads.Downloader]
struct Downloads.RequestError <: Core.Exception end  [typ @ Downloads.RequestError]
struct Downloads.Response end  [typ @ Downloads.Response]
primitive type Pkg.GitTools.GitMode <: Base.Enums.Enum{Int32} 32 end  [typ @ Pkg.GitTools.GitMode]
const Pkg.GitTools.SHA1 = Base.SHA1  [alias @ Pkg.GitTools.SHA1]
const Pkg.Operations.PackageEntry = Pkg.Types.PackageEntry  [alias @ Pkg.Operations.PackageEntry]
struct Pkg.Operations.PackageStatusData end  [typ @ Pkg.Operations.PackageStatusData]
mutable struct Pkg.Registry.PkgEntry end  [typ @ Pkg.Registry.PkgEntry]
struct Pkg.Registry.PkgInfo end  [typ @ Pkg.Registry.PkgInfo]
struct Pkg.Registry.RegistryInstance end  [typ @ Pkg.Registry.RegistryInstance]
mutable struct Pkg.Registry.RegistrySpec end  [typ @ Pkg.Registry.RegistrySpec]
mutable struct Pkg.Registry.VersionInfo end  [typ @ Pkg.Registry.VersionInfo]
struct Pkg.API.PackageInfo end  [typ @ Pkg.API.PackageInfo]
struct Pkg.API.ProjectInfo end  [typ @ Pkg.API.ProjectInfo]
const Pkg.API.ResolverError = Pkg.Resolve.ResolverError  [alias @ Pkg.API.ResolverError]
struct Pkg.API.UndoSnapshot end  [typ @ Pkg.API.UndoSnapshot]
mutable struct Pkg.API.UndoState end  [typ @ Pkg.API.UndoState]
const Pkg.API.UsageByDepotDict = Base.Dict{Core.String, Base.Dict{Core.String, Dates.DateTime}}  [alias @ Pkg.API.UsageByDepotDict]
const Pkg.API.UsageDict = Base.Dict{Core.String, Dates.DateTime}  [alias @ Pkg.API.UsageDict]
const Pkg.Artifacts.SHA1 = Base.SHA1  [alias @ Pkg.Artifacts.SHA1]
struct Pkg.BinaryPlatforms.CompilerABI end  [typ @ Pkg.BinaryPlatforms.CompilerABI]
struct Pkg.BinaryPlatforms.FreeBSD <: Base.BinaryPlatforms.AbstractPlatform end  [typ @ Pkg.BinaryPlatforms.FreeBSD]
struct Pkg.BinaryPlatforms.Linux <: Base.BinaryPlatforms.AbstractPlatform end  [typ @ Pkg.BinaryPlatforms.Linux]
struct Pkg.BinaryPlatforms.MacOS <: Base.BinaryPlatforms.AbstractPlatform end  [typ @ Pkg.BinaryPlatforms.MacOS]
const Pkg.BinaryPlatforms.Platform = Base.BinaryPlatforms.Platform  [alias @ Pkg.BinaryPlatforms.Platform]
struct Pkg.BinaryPlatforms.UnknownPlatform <: Base.BinaryPlatforms.AbstractPlatform end  [typ @ Pkg.BinaryPlatforms.UnknownPlatform]
struct Pkg.BinaryPlatforms.Windows <: Base.BinaryPlatforms.AbstractPlatform end  [typ @ Pkg.BinaryPlatforms.Windows]
struct Pkg.LazilyInitializedFields.AlreadyInitializedException <: Core.Exception end  [typ @ Pkg.LazilyInitializedFields.AlreadyInitializedException]
struct Pkg.LazilyInitializedFields.NonLazyFieldException <: Core.Exception end  [typ @ Pkg.LazilyInitializedFields.NonLazyFieldException]
struct Pkg.LazilyInitializedFields.Uninitialized end  [typ @ Pkg.LazilyInitializedFields.Uninitialized]
struct Pkg.LazilyInitializedFields.UninitializedFieldException <: Core.Exception end  [typ @ Pkg.LazilyInitializedFields.UninitializedFieldException]
mutable struct Pkg.MiniProgressBars.MiniProgressBar end  [typ @ Pkg.MiniProgressBars.MiniProgressBar]
const Pkg.PackageMode = Pkg.Types.PackageMode  [alias @ Pkg.PackageMode]
const Pkg.PackageSpec = Pkg.Types.PackageSpec  [alias @ Pkg.PackageSpec]
const Pkg.PreserveLevel = Pkg.Types.PreserveLevel  [alias @ Pkg.PreserveLevel]
const Pkg.REPLMode.APIOptions = Base.Dict{Core.Symbol, Core.Any}  [alias @ Pkg.REPLMode.APIOptions]
struct Pkg.REPLMode.ArgSpec end  [typ @ Pkg.REPLMode.ArgSpec]
struct Pkg.REPLMode.Command end  [typ @ Pkg.REPLMode.Command]
const Pkg.REPLMode.CommandDeclaration = Core.Array{Core.Pair{Core.Symbol, Core.Any}, 1}  [alias @ Pkg.REPLMode.CommandDeclaration]
struct Pkg.REPLMode.CommandSpec end  [typ @ Pkg.REPLMode.CommandSpec]
struct Pkg.REPLMode.MiniREPL <: REPL.AbstractREPL end  [typ @ Pkg.REPLMode.MiniREPL]
struct Pkg.REPLMode.Option end  [typ @ Pkg.REPLMode.Option]
const Pkg.REPLMode.OptionDeclaration = Core.Array{Core.Pair{Core.Symbol, Core.Any}, 1}  [alias @ Pkg.REPLMode.OptionDeclaration]
struct Pkg.REPLMode.OptionSpec end  [typ @ Pkg.REPLMode.OptionSpec]
const Pkg.REPLMode.PSA = Core.Pair{Core.Symbol, Core.Any}  [alias @ Pkg.REPLMode.PSA]
const Pkg.REPLMode.PackageIdentifier = Core.String  [alias @ Pkg.REPLMode.PackageIdentifier]
const Pkg.REPLMode.PackageToken = Union{Core.String, Pkg.REPLMode.Rev, Pkg.REPLMode.Subdir, Pkg.REPLMode.VersionToken}  [alias @ Pkg.REPLMode.PackageToken]
struct Pkg.REPLMode.PkgCompletionProvider <: REPL.LineEdit.CompletionProvider end  [typ @ Pkg.REPLMode.PkgCompletionProvider]
struct Pkg.REPLMode.QString end  [typ @ Pkg.REPLMode.QString]
const Pkg.REPLMode.RegistrySpec = Pkg.Registry.RegistrySpec  [alias @ Pkg.REPLMode.RegistrySpec]
struct Pkg.REPLMode.Rev end  [typ @ Pkg.REPLMode.Rev]
mutable struct Pkg.REPLMode.Statement end  [typ @ Pkg.REPLMode.Statement]
struct Pkg.REPLMode.Subdir end  [typ @ Pkg.REPLMode.Subdir]
struct Pkg.REPLMode.VersionToken end  [typ @ Pkg.REPLMode.VersionToken]
const Pkg.RegistrySpec = Pkg.Registry.RegistrySpec  [alias @ Pkg.RegistrySpec]
const Pkg.Resolve.Field = Core.Array{Pkg.Resolve.FieldValue, 1}  [alias @ Pkg.Resolve.Field]
struct Pkg.Resolve.FieldValue end  [typ @ Pkg.Resolve.FieldValue]
struct Pkg.Resolve.Fixed end  [typ @ Pkg.Resolve.Fixed]
mutable struct Pkg.Resolve.Graph end  [typ @ Pkg.Resolve.Graph]
mutable struct Pkg.Resolve.GraphData end  [typ @ Pkg.Resolve.GraphData]
const Pkg.Resolve.InstState = Union{Core.Nothing, Base.VersionNumber}  [alias @ Pkg.Resolve.InstState]
mutable struct Pkg.Resolve.MaxSumParams end  [typ @ Pkg.Resolve.MaxSumParams]
mutable struct Pkg.Resolve.Messages end  [typ @ Pkg.Resolve.Messages]
mutable struct Pkg.Resolve.NodePerm end  [typ @ Pkg.Resolve.NodePerm]
const Pkg.Resolve.Requires = Base.Dict{Base.UUID, Pkg.Versions.VersionSpec}  [alias @ Pkg.Resolve.Requires]
const Pkg.Resolve.ResolveJournal = Core.Array{Tuple{Base.UUID, Core.String}, 1}  [alias @ Pkg.Resolve.ResolveJournal]
mutable struct Pkg.Resolve.ResolveLog end  [typ @ Pkg.Resolve.ResolveLog]
mutable struct Pkg.Resolve.ResolveLogEntry end  [typ @ Pkg.Resolve.ResolveLogEntry]
struct Pkg.Resolve.ResolverError <: Core.Exception end  [typ @ Pkg.Resolve.ResolverError]
mutable struct Pkg.Resolve.SolutionTrace end  [typ @ Pkg.Resolve.SolutionTrace]
struct Pkg.Resolve.Unsat end  [typ @ Pkg.Resolve.Unsat]
struct Pkg.Resolve.UnsatError <: Core.Exception end  [typ @ Pkg.Resolve.UnsatError]
struct Pkg.Resolve.VersionWeight end  [typ @ Pkg.Resolve.VersionWeight]
mutable struct Pkg.Types.Compat end  [typ @ Pkg.Types.Compat]
mutable struct Pkg.Types.Context end  [typ @ Pkg.Types.Context]
mutable struct Pkg.Types.EnvCache end  [typ @ Pkg.Types.EnvCache]
mutable struct Pkg.Types.GitRepo end  [typ @ Pkg.Types.GitRepo]
mutable struct Pkg.Types.Manifest end  [typ @ Pkg.Types.Manifest]
mutable struct Pkg.Types.PackageEntry end  [typ @ Pkg.Types.PackageEntry]
primitive type Pkg.Types.PackageMode <: Base.Enums.Enum{Int32} 32 end  [typ @ Pkg.Types.PackageMode]
mutable struct Pkg.Types.PackageSpec end  [typ @ Pkg.Types.PackageSpec]
struct Pkg.Types.PkgError <: Core.Exception end  [typ @ Pkg.Types.PkgError]
const Pkg.Types.Platform = Base.BinaryPlatforms.Platform  [alias @ Pkg.Types.Platform]
primitive type Pkg.Types.PreserveLevel <: Base.Enums.Enum{Int32} 32 end  [typ @ Pkg.Types.PreserveLevel]
mutable struct Pkg.Types.Project end  [typ @ Pkg.Types.Project]
const Pkg.Types.SHA1 = Base.SHA1  [alias @ Pkg.Types.SHA1]
struct Pkg.Types.Stage1 end  [typ @ Pkg.Types.Stage1]
const Pkg.Types.UUID = Base.UUID  [alias @ Pkg.Types.UUID]
primitive type Pkg.Types.UpgradeLevel <: Base.Enums.Enum{Int32} 32 end  [typ @ Pkg.Types.UpgradeLevel]
const Pkg.Types.VersionRange = Pkg.Versions.VersionRange  [alias @ Pkg.Types.VersionRange]
const Pkg.Types.VersionSpec = Pkg.Versions.VersionSpec  [alias @ Pkg.Types.VersionSpec]
const Pkg.Types.VersionTypes = Union{Pkg.Types.UpgradeLevel, Base.VersionNumber, Pkg.Versions.VersionSpec}  [alias @ Pkg.Types.VersionTypes]
const Pkg.UpgradeLevel = Pkg.Types.UpgradeLevel  [alias @ Pkg.UpgradeLevel]
struct Pkg.Versions.VersionBound end  [typ @ Pkg.Versions.VersionBound]
struct Pkg.Versions.VersionRange end  [typ @ Pkg.Versions.VersionRange]
struct Pkg.Versions.VersionSpec end  [typ @ Pkg.Versions.VersionSpec]
