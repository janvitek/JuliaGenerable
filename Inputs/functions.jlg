function  _find_nonascii_chunk(chunk_size,cu::AbstractVector{CU}, first,last) where {CU}
function  _isascii_chunks(chunk_size,cu::AbstractVector{CU}, first,last) where {CU}
function (*)(A::AbstractMatrix, B::AbstractMatrix)
function (*)(A::AbstractMatrix, Q::AbstractQ)
function (*)(A::AbstractMatrix{T}, x::AbstractVector{S}) where {T,S}
function (*)(A::AbstractVector, Q::AbstractQ)
function (*)(A::AdjOrTransAbsMat, D::Diagonal)
function (*)(A::AdjOrTransStridedMat{<:BlasComplex}, B::StridedMaybeAdjOrTransMat{<:BlasReal})
function (*)(A::StridedMatrix{<:BlasComplex}, B::StridedMaybeAdjOrTransMat{<:BlasReal})
function (*)(A::StridedMatrix{<:BlasReal}, B::StridedMatrix{<:BlasComplex})
function (*)(A::StridedMaybeAdjOrTransMat{<:BlasComplex}, B::StridedMaybeAdjOrTransMat{<:BlasComplex})
function (*)(A::StridedMaybeAdjOrTransMat{<:BlasReal}, B::StridedMaybeAdjOrTransMat{<:BlasReal})
function (*)(A::StridedMaybeAdjOrTransMat{T}, x::StridedVector{S}) where {T<:BlasFloat,S<:Real}
function (*)(D::Diagonal, A::AdjOrTransAbsMat)
function (*)(D::Diagonal, V::AbstractVector)
function (*)(Da::Diagonal, A::AbstractMatrix, Db::Diagonal)
function (*)(Da::Diagonal, Db::Diagonal)
function (*)(Da::Diagonal, Db::Diagonal, Dc::Diagonal)
function (*)(F::Hessenberg{<:Any,<:AbstractMatrix{T}}, x::S) where {T,S<:Number}
function (*)(Q::AbstractQ, B::AbstractMatrix)
function (*)(Q::AbstractQ, B::AbstractVector)
function (*)(Q::AbstractQ, b::Number)
function (*)(a::Number, Q::AbstractQ)
function (*)(s1::Union{AbstractChar, AbstractString}, ss::Union{AbstractChar, AbstractString}...)
function (*)(x::S, F::Hessenberg{<:Any,<:AbstractMatrix{T}}) where {T,S<:Number}
function (+)(A::AbstractMatrix, J::UniformScaling)
function (+)(A::Hermitian, J::UniformScaling{<:Complex})
function (+)(dt::Date, z::Month)
function (+)(dt::Date,y::Year)
function (+)(dt::DateTime, y::Year)
function (+)(dt::DateTime, z::Month)
function (+)(x::AbstractArray{<:TimeType}, y::GeneralPeriod)
function (+)(x::StridedArray{<:GeneralPeriod})
function (+)(x::StridedArray{<:GeneralPeriod}, y::TimeType)
function (+)(x::TimeType, y::CompoundPeriod)
function (+)(y::GeneralPeriod, x::AbstractArray{<:TimeType})
function (+)(y::TimeType, x::StridedArray{<:GeneralPeriod})
function (-)(A::Bidiagonal, B::Diagonal)
function (-)(A::Bidiagonal, B::SymTridiagonal)
function (-)(A::Bidiagonal, B::Tridiagonal)
function (-)(A::Diagonal, B::Bidiagonal)
function (-)(A::Diagonal, B::SymTridiagonal)
function (-)(A::Diagonal, B::Tridiagonal)
function (-)(A::SymTridiagonal, B::Bidiagonal)
function (-)(A::SymTridiagonal, B::Diagonal)
function (-)(A::Tridiagonal, B::Bidiagonal)
function (-)(A::Tridiagonal, B::Diagonal)
function (-)(A::UniformScaling, B::Bidiagonal)
function (-)(A::UniformScaling, B::Diagonal)
function (-)(A::UniformScaling, B::SymTridiagonal)
function (-)(A::UniformScaling, B::Tridiagonal)
function (-)(B::BitArray)
function (-)(J::UniformScaling, A::AbstractMatrix)
function (-)(J::UniformScaling{<:Complex}, A::Hermitian)
function (-)(dt::Date, z::Month)
function (-)(dt::Date,y::Year)
function (-)(dt::DateTime, z::Month)
function (-)(dt::DateTime,y::Year)
function (-)(x::AbstractArray{<:TimeType}, y::GeneralPeriod)
function (-)(x::AbstractArray{T}, y::T) where {T<:TimeType}
function (-)(x::StridedArray{<:GeneralPeriod}, y::TimeType)
function (-)(x::TimeType, y::CompoundPeriod)
function (-)(y::T, x::AbstractArray{T}) where {T<:TimeType}
function (/)(A::AbstractVecOrMat, B::AbstractVecOrMat)
function (/)(B::AbstractMatrix, F::Factorization)
function (/)(B::Union{Matrix{Complex{T}},AdjOrTrans{Complex{T},Vector{Complex{T}}}}, F::Factorization{T}) where {T<:BlasReal}
function (/)(S::SymTridiagonal, D::Diagonal)
function (:)(start::T, step::T, stop::T) where T<:IEEEFloat
function (<<)(B::BitVector, i::UInt)
function (==)(A::AbstractArray, B::AbstractArray)
function (==)(A::BitArray, B::BitArray)
function (>>>)(B::BitVector, i::UInt)
function (\)(A::AbstractMatrix, B::AbstractVecOrMat)
function (\)(A::Union{QR{T},QRCompactWY{T},QRPivoted{T}}, BIn::VecOrMat{Complex{T}}) where T<:BlasReal
function (\)(D::Diagonal, S::SymTridiagonal)
function (\)(F::Factorization, B::AbstractVecOrMat)
function (\)(F::Factorization{T}, B::VecOrMat{Complex{T}}) where {T<:BlasReal}
function (\)(F::LQ{T}, B::VecOrMat{Complex{T}}) where T<:BlasReal
function (^)(A::AbstractMatrix{T}, p::Integer) where T<:Integer
function (^)(A::AbstractMatrix{T}, p::Real) where T
function *(A::AbstractMatrix, B::AbstractTriangular)
function *(A::AbstractTriangular, B::AbstractTriangular)
function *(A::Bidiagonal, B::LowerOrUnitLowerTriangular)
function *(A::Bidiagonal, B::UpperOrUnitUpperTriangular)
function *(A::Diagonal, B::SymTridiagonal)
function *(A::LQ{TA}, B::AbstractVecOrMat{TB}) where {TA,TB}
function *(A::LowerOrUnitLowerTriangular, B::Bidiagonal)
function *(A::SymTridiagonal, B::Diagonal)
function *(A::UpperOrUnitUpperTriangular, B::Bidiagonal)
function *(B::Bidiagonal, H::UpperHessenberg)
function *(G1::Givens{S}, G2::Givens{T}) where {S,T}
function *(G::Givens{S}, R::Rotation{T}) where {S,T}
function *(G::Givens{T}, Gs::Givens{T}...) where {T}
function *(H::UpperHessenberg, B::Bidiagonal)
function *(H::UpperHessenberg, U::UpperOrUnitUpperTriangular)
function *(R::Rotation{S}, G::Givens{T}) where {S,T}
function *(S1::SizedArray, S2::SizedArray)
function *(U::UpperOrUnitUpperTriangular, H::UpperHessenberg)
function *(r1::Union{Regex,AbstractString,AbstractChar}, rs::Union{Regex,AbstractString,AbstractChar}...)
function *(transx::Transpose{<:Any,<:StridedVector{T}}, y::StridedVector{T}) where {T<:BlasComplex}
function *(u::Int128, v::Int128)
function *(u::UInt128, v::UInt128)
function *(x::Bool, y::T) where T<:AbstractFloat
function *(x::Rational, y::Integer)
function *(x::Rational, y::Rational)
function *(x::TwicePrecision, v::Number)
function *(x::TwicePrecision{<:IEEEFloat}, v::Integer)
function *(x::TwicePrecision{T}, y::TwicePrecision{T}) where {T}
function *(y::Integer, x::Rational)
function +(A::Array, Bs::Array...)
function +(A::Bidiagonal, B::Bidiagonal)
function +(r1::StepRangeLen{T,R}, r2::StepRangeLen{T,R}) where T where R<:TwicePrecision
function +(r1::StepRangeLen{T,S}, r2::StepRangeLen{T,S}) where {T,S}
function +(x::Bool, y::T) where T<:AbstractFloat
function +(x::Int32, y::Int32)
function +(x::Rational, y::Rational)
function +(x::T, y::Integer) where {T<:AbstractChar}
function +(x::TwicePrecision, y::Number)
function +(x::TwicePrecision{T}, y::TwicePrecision{T}) where T
function -(A::Bidiagonal, B::Bidiagonal)
function -(A::UnitLowerTriangular)
function -(A::UnitUpperTriangular)
function -(c::BigInt, x::BigFloat)
function -(r::LinRange)
function -(x::BigFloat)
function -(x::Rational, y::Rational)
function -(x::Rational{T}) where T<:BitSigned
function -(x::Rational{T}) where T<:Unsigned
function -(x::Real, z::Complex)
function -(x::Real, z::Complex{Bool})
function -(x::T, y::Integer) where {T<:AbstractChar}
function /(D::Diagonal, B::Bidiagonal)
function /(H::UpperHessenberg, B::Bidiagonal)
function /(H::UpperHessenberg, U::UnitUpperTriangular)
function /(H::UpperHessenberg, U::UpperTriangular)
function /(a::Complex{T}, b::Complex{T}) where T<:Real
function /(x::TwicePrecision, v::Number)
function /(x::TwicePrecision, y::TwicePrecision)
function /(z::ComplexF64, w::ComplexF64)
function /(z::Complex{T}, w::Complex{T}) where {T<:Union{Float16,Float32}}
function //(x::Integer,  y::Rational)
function //(x::Rational, y::Integer)
function //(x::Rational, y::Rational)
function <(t1::Any32, t2::Any32)
function <(t1::Tuple, t2::Tuple)
function <(x::AbstractIrrational, y::AbstractIrrational)
function <(x::AbstractIrrational, y::Rational{T}) where T
function <(x::Rational{T}, y::AbstractIrrational) where T
function <<(x::Integer, c::Integer)
function <<(x::Integer, c::Unsigned)
function ==(A::AbstractMatrix, J::UniformScaling)
function ==(A::Bidiagonal, B::Bidiagonal)
function ==(A::Bidiagonal, B::Tridiagonal)
function ==(A::StridedMatrix, J::UniformScaling)
function ==(A::Tridiagonal, B::SymTridiagonal)
function ==(a::Arr, b::Arr) where Arr <: BitIntegerArray{1}
function ==(a::Arr, b::Arr) where {Arr <: BitIntegerArray}
function ==(a::M, b::M) where {M <: BitIntegerMemory}
function ==(a::Regex, b::Regex)
function ==(a::StackFrame, b::StackFrame)
function ==(a::Union{String, SubString{String}}, b::Union{String, SubString{String}})
function ==(a::VersionNumber, b::VersionNumber)
function ==(l::AbstractDict, r::AbstractDict)
function ==(r::AbstractRange, s::AbstractRange)
function ==(r::OrdinalRange, s::OrdinalRange)
function ==(r::T, s::T) where {T<:AbstractRange}
function ==(r::Union{StepRange{T},StepRangeLen{T,T}}, s::Union{StepRange{T},StepRangeLen{T,T}}) where {T}
function ==(s1::BitSet, s2::BitSet)
function ==(v1::SimpleVector, v2::SimpleVector)
function ==(x::AbstractFloat, q::Rational)
function >>(x::Integer, c::Integer)
function >>>(x::Integer, c::Integer)
function >>>(x::Integer, c::Unsigned)
function A42645(a::Vector{T}) where T
function AbstractMatrix(F::CholeskyPivoted)
function AbstractMatrix(F::Hessenberg)
function Agen_nodrop(A::AbstractArray, I...)
function Agen_slice(A::AbstractArray, I...)
function AnnotatedString(chars::AbstractVector{C}) where {C<:AbstractChar}
function ArgEscapeCache(estate::EscapeState)
function ArgEscapeInfo(x::EscapeInfo)
function AsyncCondition(cb::Function)
function BBScanner(ir::IRCode)
function (-)(a::Fix42528, b::Fix42528)
function (==)(A::Eigen, B::Eigen)
function (==)(A::QRCompactWY, B::QRCompactWY)
function Base.Docs.catdoc(hs::LazyHelp...)
function Base.LinearIndices(inds::CartesianIndices)
function Base.LinearIndices(inds::CartesianIndices{N,R}) where {N,R<:NTuple{N, AbstractUnitRange}}
function Base.Sort._sort!(v::AbstractVector, ::MySecondAlg, o::Base.Order.Ordering, kw)
function Base.Sort._sort!(v::AbstractVector, ::NonScalarIndexingOfWithoutMissingVectorAlg, o::Base.Order.Ordering, kw)
function Base.Timer(delay::Period; interval::Period=Second)
function Base._extrema_rf(x::NTuple{2,BigFloat}, y::NTuple{2,BigFloat})
function Base._mapreduce_dim(f, op::CommutativeOps, init::Base._InitialValue, A::PermutedDimsArray, dims::Colon)
function Base._mapreduce_dim(f::typeof(identity), op::Union{typeof(Base.mul_prod),typeof(*)}, init::Base._InitialValue, A::PermutedDimsArray{<:Union{Real,Complex}}, dims::Colon)
function Base._reverse(iter::CartesianIndices, ::Colon)
function Base._sum(A::Bidiagonal, dims::Integer)
function Base._sum(A::Diagonal, dims::Integer)
function Base._sum(A::SymTridiagonal, ::Colon)
function Base._sum(A::SymTridiagonal, dims::Integer)
function Base._sum(A::Tridiagonal, dims::Integer)
function Base.cconvert(::Type{Ptr{DiffOptionsStruct}}, pathspecs::AbstractString)
function Base.cconvert(::Type{Ptr{StrArrayStruct}}, x::Vector)
function Base.cconvert(::Type{Ref{PtrStruct}}, a::RealStruct)
function Base.ceil(dt::TimeType, p::Period)
function Base.ceil(x::ConvertiblePeriod, precision::ConvertiblePeriod)
function Base.close(idle::UvTestIdle)
function Base.close(lock::LockMonitor)
function Base.close(obj::GitSignature)
function Base.close(pipe::Base64EncodePipe)
function Base.cmp(id1::GitHash, id2::GitHash)
function Base.cmp(id1::GitShortHash, id2::GitShortHash)
function Base.cmp(x::Rational{BigInt}, y::Rational{BigInt})
function Base.collect(inds::CartesianIndices)
function Base.collect(inds::CartesianIndices{N, R}) where {N,R<:NTuple{N, AbstractUnitRange}}
function Base.convert(::Type{GitSignature}, sig::Signature)
function Base.convert(::Type{Vector{String}}, sa::StrArrayStruct)
function Base.copy!(a::GitCredential, b::GitCredential)
function Base.copy(V::SubArray)
function Base.copy(aB::Adjoint{<:Any,<:Bidiagonal})
function Base.copy(bc::Broadcast.Broadcasted{Broadcast.Style{T22053}})
function Base.copy(tB::Transpose{<:Any,<:Bidiagonal})
function Base.copyto!(dest::PermutedDimsArray{T,N}, src::AbstractArray{T,N}) where {T,N}
function Base.copyto_unaliased!(deststyle::IndexStyle, dest::AbstractMatrix, srcstyle::IndexCartesian, src::AdjOrTransAbsMat)
function Base.deepcopy_internal(x::BigFloat, stackdict::IdDict)
function Base.fill!(B::BitMaskedBitArray, b::Bool)
function Base.fill!(F::Fill, v)
function Base.findall(path::String, idx::GitIndex)
function Base.floor(dt::Date, p::Day)
function Base.floor(dt::Date, p::Month)
function Base.floor(dt::Date, p::Quarter)
function Base.floor(dt::Date, p::Week)
function Base.floor(dt::Date, p::Year)
function Base.floor(dt::DateTime, p::TimePeriod)
function Base.floor(x::ConvertiblePeriod, precision::T) where T <: ConvertiblePeriod
function Base.getindex(A::OffsetArray, r::AbstractUnitRange{Int})
function Base.getindex(A::OffsetArray{<:Any,N}, I::Vararg{Int,N}) where N
function Base.getindex(A::OffsetVector, i::Int)
function Base.getindex(A::OffsetVector, r::AbstractRange{Int})
function Base.getindex(A::OffsetVector, r::AbstractUnitRange{Int})
function Base.getindex(A::PermutedDimsArray{T,N,perm,iperm}, I::Vararg{Int,N}) where {T,N,perm,iperm}
function Base.getindex(F::Fill{<:Any,N}, i::Vararg{Int,N}) where {N}
function Base.getindex(M::MyIdentity, i::Int, j::Int)
function Base.getindex(M::OneElVec, i::Int)
function Base.getindex(S::Strider{<:Any,N}, I::Vararg{Int,N}) where {N}
function Base.getindex(bc::Broadcasted, I::Union{Integer,CartesianIndex})
function Base.getindex(blame::GitBlame, i::Integer)
function Base.getindex(diff::GitDiff, i::Integer)
function Base.getindex(idx::GitIndex, i::Integer)
function Base.getindex(iter::CartesianIndices{N,R}, I::Vararg{Int, N}) where {N,R}
function Base.getindex(r::IdOffsetRange, i::Integer)
function Base.getindex(r::OneToThree, i::Int)
function Base.getindex(rb::GitRebase, i::Integer)
function Base.getindex(status::GitStatus, i::Integer)
function Base.getindex(tree::GitTree, i::Integer)
function Base.getindex(tree::GitTree, target::AbstractString)
function Base.getindex(val::ScopedValue{T})::T where T
function Base.getindex(x::OneHotVecOrMat{N}, inds::Vararg{Int,N}) where {N}
function Base.getproperty(c::Completion, name::Symbol)
function Base.getproperty(mstrct::TestMutable, p::Symbol)
function Base.getproperty(obj::AbstractGitObject, name::Symbol)
function Base.getproperty(obj::GitObject, name::Symbol)
function Base.getproperty(s::ModeState, name::Symbol)
function Base.getproperty(stats::DiskStat, field::Symbol)
function Base.getproperty(tcd::Issue51499CompletionDict, name::Symbol)
function Base.getproperty(ti::TextInterface, name::Symbol)
function Base.getproperty(v::Issue36437, s::Symbol)
function Base.hash(F::Eigen, h::UInt)
function Base.hash(F::QRCompactWY, h::UInt)
function Base.hash(ci::CartesianIndex, h::UInt)
function Base.hash(p::Platform, h::UInt)
function Base.hash(x::CompoundPeriod, h::UInt)
function Base.haskey(tree::GitTree, target::AbstractString)
function Base.inds2string(inds::Tuple{Vararg{Union{IdOffsetRange, IdentityUnitRange{<:IdOffsetRange}}}})
function Base.isassigned(A::Bidiagonal, i::Int, j::Int)
function Base.isassigned(A::HermOrSym, i::Int, j::Int)
function Base.isassigned(A::PermutedDimsArray{T,N,perm,iperm}, I::Vararg{Int,N}) where {T,N,perm,iperm}
function Base.isassigned(A::SymTridiagonal, i::Int, j::Int)
function Base.isassigned(A::Tridiagonal, i::Int, j::Int)
function Base.isassigned(D::Diagonal, i::Int, j::Int)
function Base.isequal(A::Eigen, B::Eigen)
function Base.isequal(A::QRCompactWY, B::QRCompactWY)
function Base.isequal(a::ComparesWithGC38727, b::WeakRef)
function Base.isreal(A::HermOrSym)
function Base.isstored(A::Bidiagonal, i::Int, j::Int)
function Base.isstored(A::SymTridiagonal, i::Int, j::Int)
function Base.isstored(A::Tridiagonal, i::Int, j::Int)
function Base.isstored(D::Diagonal, i::Int, j::Int)
function Base.iterate(::CountsIterate47688{N}, n=0) where N
function Base.iterate(bc::Broadcasted)
function Base.iterate(bi::GitBranchIter, state=nothing)
function Base.iterate(ci::GitConfigIter, state=nothing)
function Base.iterate(f::Foo36572, i=1)
function Base.iterate(n::Node, state::Node = n.child)
function Base.iterate(rb::GitRebase, state=nothing)
function Base.iterate(w::GitRevWalker, state=nothing)
function Base.length(blob::GitBlob)
function Base.length(status::GitStatus)
function Base.mapreduce(f, op, A1::OffsetUnitRange{<:Integer}, As::OffsetUnitRange{<:Integer}...; kw...)
function Base.mapreducedim!(f, op::CommutativeOps, B::AbstractArray{T,N}, A::PermutedDimsArray{S,N,perm,iperm}) where {T,S,N,perm,iperm}
function Base.mapreducedim!(f::typeof(identity), op::Union{typeof(Base.mul_prod),typeof(*)}, B::AbstractArray{T,N}, A::PermutedDimsArray{<:Union{Real,Complex},N,perm,iperm}) where {T,N,perm,iperm}
function Base.maximum(D::Diagonal{T}) where T <: Number
function Base.minimum(D::Diagonal{T}) where T <: Number
function Base.muladd(A::AbstractMatrix, y::AbstractVecOrMat, z::Union{Number, AbstractArray})
function Base.muladd(A::Diagonal, B::Diagonal, z::Diagonal)
function Base.muladd(A::StridedMaybeAdjOrTransMat{<:Number}, B::StridedMaybeAdjOrTransMat{<:Number}, z::Union{Number, AbstractVecOrMat})
function Base.muladd(A::StridedMaybeAdjOrTransMat{<:Number}, y::AbstractVector{<:Number}, z::Union{Number, AbstractVector})
function Base.muladd(u::AbstractVector, v::AdjOrTransAbsVec, z::Union{Number, AbstractArray})
function Base.nextind(a::AbstractArray{<:Any,N}, i::CartesianIndex{N}) where {N}
function Base.parentmodule(frame::StackFrame)
function Base.parse(::Type{DateTime}, s::AbstractString, df::typeof(ISODateTimeFormat))
function Base.parse(::Type{GitCredentialHelper}, helper::AbstractString)
function Base.parse(::Type{GitCredential}, url::AbstractString)
function Base.parse(::Type{Platform}, triplet::String; validate_strict::Bool = false)
function Base.parse(::Type{T}, str::AbstractString, df::DateFormat=default_format) where T<:TimeType
function Base.parse(::Type{UUID}, s::AbstractString)
function Base.prevind(a::AbstractArray{<:Any,N}, i::CartesianIndex{N}) where {N}
function Base.print(io::IO, dt::Date)
function Base.print(io::IO, dt::DateTime)
function Base.print(io::IO, id::GitHash)
function Base.promote_rule(A::Type{<:Diagonal{<:Any,V}}, B::Type{<:Diagonal{<:Any,W}}) where {V,W}
function Base.rand(rng::AbstractRNG, ::Random.SamplerType{Quaternion{T}}) where {T<:Real}
function Base.randn(rng::AbstractRNG, ::Type{Quaternion{T}}) where {T<:AbstractFloat}
function Base.read!(io::IO, cred::GitCredential)
function Base.read(pipe::Base64DecodePipe, ::Type{UInt8})
function Base.readbytes!(pipe::Base64DecodePipe, data::AbstractVector{UInt8}, nb::Integer=length)
function Base.replace_in_print_matrix(A::AdjOrTrans,i::Integer,j::Integer,s::AbstractString)
function Base.replace_in_print_matrix(A::Bidiagonal,i::Integer,j::Integer,s::AbstractString)
function Base.replace_in_print_matrix(A::Diagonal,i::Integer,j::Integer,s::AbstractString)
function Base.replace_in_print_matrix(A::HermOrSym,i::Integer,j::Integer,s::AbstractString)
function Base.replace_in_print_matrix(A::OffsetArray{<:Any,1}, i::Integer, j::Integer, s::AbstractString)
function Base.replace_in_print_matrix(A::OffsetArray{<:Any,2}, i::Integer, j::Integer, s::AbstractString)
function Base.replace_in_print_matrix(A::SymTridiagonal, i::Integer, j::Integer, s::AbstractString)
function Base.replace_in_print_matrix(A::Tridiagonal,i::Integer,j::Integer,s::AbstractString)
function Base.replace_in_print_matrix(A::UpperHessenberg, i::Integer, j::Integer, s::AbstractString)
function Base.replace_in_print_matrix(M::MyIdentity, i::Integer, j::Integer, s::AbstractString)
function Base.replace_in_print_matrix(M::OneElVec, i::Integer, j::Integer, s::AbstractString)
function Base.reshape(A::AbstractArray, inds::Tuple{OffsetAxis,Vararg{OffsetAxis}})
function Base.rest(s::AbstractString, st...)
function Base.round(::Type{Date}, x::TimeTypeOrPeriod, ::Type{P}, r::RoundingMode=RoundNearestTiesUp) where P <: Period
function Base.round(x::AbstractFloat, ::typeof(RoundFromZero))
function Base.round(x::TimeTypeOrPeriod, ::Type{P}, r::RoundingMode=RoundNearestTiesUp) where P <: Period
function Base.seek(h::FILE, offset::Integer)
function Base.setindex!(A::OffsetArray{T,N}, val, I::Vararg{Int,N}) where {T,N}
function Base.setindex!(A::OffsetVector, val, i::Int)
function Base.setindex!(A::PermutedDimsArray{T,N,perm,iperm}, val, I::Vararg{Int,N}) where {T,N,perm,iperm}
function Base.setindex!(F::Fill, v, k::Integer)
function Base.setindex!(p::AbstractPlatform, v::String, k::String)
function Base.setproperty!(cred::SSHCredential, name::Symbol, value)
function Base.setproperty!(cred::UserPasswordCredential, name::Symbol, value)
function Base.setproperty!(mstrct::TestMutable, p::Symbol, v)
function Base.show(io::IO, ::MIME, p::Platform)
function Base.show(io::IO, ::MIME, x::AdjointFactorization)
function Base.show(io::IO, ::MIME, x::Enum)
function Base.show(io::IO, ::MIME, x::TransposeFactorization)
function Base.show(io::IO, A::ZeroBasedUnitRange)
function Base.show(io::IO, a::Alloc)
function Base.show(io::IO, alg::Algorithm)
function Base.show(io::IO, b::Binding)
function Base.show(io::IO, bc::Broadcasted{Style}) where {Style}
function Base.show(io::IO, blame_hunk::BlameHunk)
function Base.show(io::IO, blob::GitBlob)
function Base.show(io::IO, c::GitCommit)
function Base.show(io::IO, ce::ConfigEntry)
function Base.show(io::IO, cfg::CFG)
function Base.show(io::IO, d::DatePart{c}) where c
function Base.show(io::IO, d::Delim)
function Base.show(io::IO, dd::DiffDelta)
function Base.show(io::IO, df::DateFormat{S,T}) where {S,T}
function Base.show(io::IO, df::DiffFile)
function Base.show(io::IO, diff::GitDiff)
function Base.show(io::IO, diff_stat::GitDiffStats)
function Base.show(io::IO, e::Effects)
function Base.show(io::IO, ex::TestSetException)
function Base.show(io::IO, fh::FetchHead)
function Base.show(io::IO, idx::GitIndex)
function Base.show(io::IO, lbt::LBTConfig)
function Base.show(io::IO, m::MIME, t::Type{<:Enum})
function Base.show(io::IO, op::BroadcastFunction)
function Base.show(io::IO, p::Platform)
function Base.show(io::IO, r::OffsetRange)
function Base.show(io::IO, rb::GitRebase)
function Base.show(io::IO, rbo::RebaseOperation)
function Base.show(io::IO, rbs::RainbowString)
function Base.show(io::IO, ref::GitReference)
function Base.show(io::IO, repo::GitRepo)
function Base.show(io::IO, result::GitDescribeResult)
function Base.show(io::IO, scope::Scope)
function Base.show(io::IO, sig::Signature)
function Base.show(io::IO, t::Broken)
function Base.show(io::IO, t::Error)
function Base.show(io::IO, t::Fail)
function Base.show(io::IO, t::LogTestFailure)
function Base.show(io::IO, t::Pass)
function Base.show(io::IO, t::Time)
function Base.show(io::IO, te::GitTreeEntry)
function Base.show(io::IO, tree::GitTree)
function Base.show(io::IO, val::ScopedValue)
function Base.show(io::IO, x::AdjointFactorization)
function Base.show(io::IO, x::Enum)
function Base.show(io::IO, x::EscapeInfo)
function Base.show(io::IO, x::T, forceuntyped::Bool=false, fromprint::Bool=false) where {T <: Base.IEEEFloat}
function Base.show(io::IO, x::TransposeFactorization)
function Base.show(io::IO, x::X28004)
function Base.showarg(io::IO, A::PermutedDimsArray{T,N,perm}, toplevel) where {T,N,perm}
function Base.showarg(io::IO, r::Iterators.Pairs{<:Any, <:Any, I, D}, toplevel) where {D, I}
function Base.showarg(io::IO, r::Iterators.Pairs{<:CartesianIndex, <:Any, <:Any, T}, toplevel) where T <: AbstractArray
function Base.showarg(io::IO, r::Iterators.Pairs{<:CartesianIndex, <:Any, <:Any, T}, toplevel) where T<:AbstractVector
function Base.showarg(io::IO, r::Iterators.Pairs{<:Integer, <:Any, <:Any, T}, toplevel) where T <: Union{AbstractVector, Tuple}
function Base.showarg(io::IO, r::Iterators.Pairs{<:Integer, <:Any, <:Any, T}, toplevel) where T<:AbstractArray
function Base.showarg(io::IO, r::Iterators.Pairs{Symbol, <:Any, <:Any, T}, toplevel) where {T <: NamedTuple}
function Base.showarg(io::IO, v::Adjoint, toplevel)
function Base.showarg(io::IO, v::SubArray, toplevel)
function Base.showarg(io::IO, v::Transpose, toplevel)
function Base.showerror(io::IO, err::InvalidFormatStringError)
function Base.showerror(io::IO, err::ParserError)
function Base.showerror(io::IO, ex::FallbackTestSetException, bt; backtrace=true)
function Base.showerror(io::IO, ex::PosDefException)
function Base.showerror(io::IO, ex::TestSetException, bt; backtrace=true)
function Base.showerror(io::IO, ex::ZeroPivotException)
function Base.showerror(io::IO, exc::StringIndexError)
function Base.shred!(cred::GitCredential)
function Base.shred!(cred::SSHCredential)
function Base.shred!(cred::UserPasswordCredential)
function Base.shred!(p::CachedCredentials)
function Base.shred!(p::CredentialPayload)
function Base.similar(::Type{T}, shape::Tuple{OffsetAxisKnownLength,Vararg{OffsetAxisKnownLength}}) where {T<:AbstractArray}
function Base.similar(A::AbstractArray, ::Type{T}, shape::Tuple{OffsetAxisKnownLength,Vararg{OffsetAxisKnownLength}}) where T
function Base.similar(bc::Broadcasted{StructuredMatrixStyle{T}}, ::Type{ElType}) where {T,ElType}
function Base.sinh(a::Float16)
function Base.sort!(v::AbstractVector, lo::Integer, hi::Integer, ::DispatchLoopTestAlg, order::Base.Order.Ordering)
function Base.sort!(v::AbstractVector{Int}, lo::Integer, hi::Integer, ::MyFirstAlg, o::Base.Order.Ordering)
function Base.sort!(v::AbstractVector{Int}, lo::Integer, hi::Integer, ::MyFirstAlg, o::Base.Order.Ordering)
function Base.sort!(w::GitRevWalker; by::Cint = Consts.SORT_NONE, rev::Bool=false)
function Base.startswith(io::IO, prefix::Base.Chars)
function Base.startswith(io::IO, prefix::Union{String,SubString{String}})
function Base.steprange_last(start::T, step, stop) where T<:TimeType
function Base.strides(A::PermutedDimsArray{T,N,perm}) where {T,N,perm}
function Base.string(t::Time)
function Base.string(x::CompoundPeriod)
function Base.string(x::T) where {T <: Base.IEEEFloat}
function Base.timedwait(testcb, timeout::Period; pollint::Period=Millisecond100)
function Base.to_index(r::OffsetUnitRange{<:Union{Int,BigInt}})
function Base.tryparse(::Type{Platform}, triplet::AbstractString)
function Base.tryparse(::Type{T}, str::AbstractString, df::DateFormat=default_format) where T<:TimeType
function Base.tryparse(::Type{UUID}, s::AbstractString)
function Base.unsafe_convert(::Type{Ptr{DiffOptionsStruct}}, rr::Tuple{Ref{DiffOptionsStruct}, Ref{Cstring}})
function Base.unsafe_convert(::Type{Ptr{StrArrayStruct}}, rr::Tuple{Ref{StrArrayStruct}, Ref{Cstring}})
function Base.unsafe_convert(::Type{Ref{BigFloat}}, x::Ref{BigFloat})
function Base.unsafe_convert(::Type{SpillPint}, vr)
function Base.unsafe_read(pipe::Base64DecodePipe, ptr::Ptr{UInt8}, n::UInt)
function Base.unsafe_write(pipe::Base64EncodePipe, ptr::Ptr{UInt8}, n::UInt)::Int
function Base.uvfinalize(t::UvTestIdle)
function Base.wait(idle::UvTestIdle)
function Base.write(io::IO, cred::GitCredential)
function Base.write(pipe::Base64EncodePipe, x::UInt8)
function Base64DecodePipe(io::IO)
function Base64EncodePipe(io::IO)
function BasicBlock(stmts::StmtRange)
function Bidiagonal(A::AbstractMatrix, uplo::Symbol)
function Bidiagonal(dv::V, ev::V, uplo::AbstractChar) where {T,V<:AbstractVector{T}}
function Bidiagonal(dv::V, ev::V, uplo::Symbol) where {T,V<:AbstractVector{T}}
function Bidiagonal(dv::Vector{T}, ev::Vector{S}, uplo::Symbol) where {T,S}
function BigFloat( precision::Integer=DEFAULT_PRECISION[])
function BigFloat(x::BigFloat, r::MPFRRoundingMode=ROUNDING_MODE[]; precision::Integer=DEFAULT_PRECISION[])
function BigFloat(x::BigInt, r::MPFRRoundingMode=ROUNDING_MODE[]; precision::Integer=DEFAULT_PRECISION[])
function BigFloat(x::Float64, r::MPFRRoundingMode=ROUNDING_MODE[]; precision::Integer=DEFAULT_PRECISION[])
function BigFloat(x::Rational, r::MPFRRoundingMode=ROUNDING_MODE[]; precision::Integer=DEFAULT_PRECISION[])
function BigInt( nbits::Integer=0)
function BigInt(x::BigFloat)
function BigInt(x::Float64)
function BigInt(x::Integer)
function Binding(m::Module, v::Symbol)
function BitArray(undef, dims::Int...)
function BitMaskedBitArray(parent::BitArray{N}, mask::BitArray{M}) where {N,M}
function BitPerm(p::NTuple{8,UInt8})
function BitSetBoundedMinPrioritySet(max::Int)
function BitVector(nt::Tuple{Vararg{Bool}})
function Bool(x::BigFloat)
function Broadcast.broadcasted(::typeof(Base.literal_pow), ::typeof(^), J::UniformScaling, x::Val)
function BroadcastStyle(a::A, b::B) where {A<:AbstractArrayStyle{M},B<:AbstractArrayStyle{N}} where {M,N}
function Broadcasted(f::F, args::Tuple, axes=nothing) where {F}
function Broadcasted(style::Union{Nothing,BroadcastStyle}, f::F, args::Tuple, axes=nothing) where {F}
function CC.add_remark!(interp::MTOverlayInterp, ::CC.InferenceState, remark)
function CC.cache_result!(interp::EscapeAnalyzer, result::InferenceResult)
function CC.code_cache(interp::EscapeAnalyzer)
function CC.const_prop_argument_heuristic(interp::REPLInterpreter, arginfo::CC.ArgInfo, sv::CC.InferenceState)
function CC.optimize(interp::EscapeAnalyzer, opt::OptimizationState, caller::InferenceResult)
function CC.setindex!(wvc::WorldView{EscapeAnalyzerCacheView}, ci::CodeInstance, mi::MethodInstance)
function CC.setindex!(wvc::WorldView{InvalidationTesterCacheView}, ci::CodeInstance, mi::MethodInstance)
function CFGInliningState(ir::IRCode)
function CFGTransformState!(blocks::Vector{BasicBlock}, allow_cfg_transforms::Bool=false)
function CacheFlags(f::UInt8)
function CachedTOMLDict(p::TOML.Parser, path::String)
function CapturedException(ex, bt_raw::Vector)
function CartesianIndices(inds::NTuple{N,OrdinalRange{<:Integer, <:Integer}}) where {N}
function Channel(func::Function; ctype=nothing, csize=nothing, taskref=nothing, spawn=nothing, threadpool=nothing)
function CompactPeekIterator(compact::IncrementalCompact, start_idx::Int)
function CompoundPeriod(p::Vector{Period})
function Consts.OBJECT(ptr::Ptr{Cvoid})
function Core.kwcall(kwargs::NamedTuple, ::typeof(invoke), f, T, args...)
function CredentialPayload(cache::CachedCredentials; kwargs...)
function CredentialPayload(credential::AbstractCredential; kwargs...)
function CyclePadding(T::DataType)
function DFS!(D::DFSTree, blocks::Vector{BasicBlock}, is_post_dominator::Bool)
function DFSTree(n_blocks::Int)
function DILineInfoPrinter(linetable::Vector, showtypes::Bool=false)
function DataTypeFieldDesc(dt::DataType)
function Date(d::AbstractString, format::AbstractString; locale::Locale=ENGLISH)
function Date(func::Function, y, m=1, d=1; step::Period=Day1, limit::Int=10000)
function Date(period::Period, periods::Period...)
function Date(y::Int64, m::Int64=1, d::Int64=1)
function DateFormat(f::AbstractString, locale::AbstractString)
function DateFormat(f::AbstractString, locale::DateLocale=ENGLISH)
function DateTime(dt::AbstractString, format::AbstractString; locale::Locale=ENGLISH)
function DateTime(dt::Date, t::Time)
function DateTime(func::Function, y, m, d, h, mi, s; step::Period=Millisecond1, limit::Int=10000)
function DateTime(func::Function, y, m, d, h, mi; step::Period=Second1, limit::Int=10000)
function DateTime(func::Function, y, m, d, h; step::Period=Minute1, limit::Int=10000)
function DateTime(func::Function, y, m, d; step::Period=Hour1, limit::Int=10000)
function DateTime(func::Function, y, m=1; step::Period=Da1, limit::Int=10000)
function DateTime(period::Period, periods::Period...)
function DefaultTestSet(desc::AbstractString; verbose::Bool = false, showtiming::Bool = true, failfast::Union{Nothing,Bool} = nothing, source = nothing)
function Demo_20254(arr::AbstractArray=Any[])
function DoAllocNoEscapeBranch(val::Int)
function DoAllocNoEscapeSparam(x::T) where {T}
function DoAllocWithField(x::Int)
function Docs.formatdoc(buffer, docstr, ::Type{__FIELDS__})
function Documenter.Writers.HTMLWriter.expand_versions(dir::String, v::Versions)
function Documenter.deploy_folder(::BuildBotConfig; devurl, repo, branch, kwargs...)
function Drop(xs::I, n::Integer) where {I}
function EmissionParams( emit_metadata::Bool=true)
function Error(test_type::Symbol, orig_expr, value, bt, source::LineNumberNode)
function EscapeState(nargs::Int, nstmts::Int, arrayinfo::Union{Nothing,ArrayInfo})
function FDWatcher(fd::RawFD, mask::FDEvent)
function FDWatcher(fd::RawFD, readable::Bool, writable::Bool)
function FDWatcher(fd::WindowsRawSocket, mask::FDEvent)
function FDWatcher(fd::WindowsRawSocket, readable::Bool, writable::Bool)
function FILE(fd::RawFD, mode)
function FILE(s::IO)
function FOO_19322(Y::AbstractMatrix; frac::Float64=0.3, nbins::Int=100, n_sims::Int=100)
function Fail(test_type::Symbol, orig_expr, data, value, context, source::LineNumberNode, message_only::Bool, backtrace=nothing)
function FileMonitor(file::String)
function FileRedirect(filename::String, append::Bool)
function Float32(x::Int128)
function Float32(x::UInt128)
function Float64(x::Int128)
function Float64(x::UInt128)
function FolderMonitor(folder::String)
function Format(f::AbstractString)
function FormatMessage(e::UInt32=GetLastError)
function GC_Diff(new::GC_Num, old::GC_Num)
function GitAnnotated(repo::GitRepo, commit_id::GitHash)
function GitAnnotated(repo::GitRepo, committish::AbstractString)
function GitAnnotated(repo::GitRepo, fh::FetchHead)
function GitAnnotated(repo::GitRepo, ref::GitReference)
function GitBlame(repo::GitRepo, path::AbstractString; options::BlameOptions=BlameOptions)
function GitConfig(level::Consts.GIT_CONFIG = Consts.CONFIG_LEVEL_DEFAULT)
function GitConfig(repo::GitRepo)
function GitConfigIter(cfg::GitConfig)
function GitConfigIter(cfg::GitConfig, name::AbstractString)
function GitConfigIter(cfg::GitConfig, name::AbstractString, value::Regex)
function GitConfigIter(cfg::GitConfig, name::Regex)
function GitCredential(cfg::GitConfig, url::AbstractString)
function GitCredential(user_pass_cred::UserPasswordCredential, url::AbstractString)
function GitDescribeResult(repo::GitRepo; options::DescribeOptions=DescribeOptions)
function GitDiffStats(diff::GitDiff)
function GitError(err_code::Code)
function GitHash(ann::GitAnnotated)
function GitHash(id::AbstractString)
function GitHash(id::Array{UInt8,1})
function GitHash(obj::GitObject)
function GitHash(ptr::Ptr{UInt8})
function GitHash(ref::GitReference)
function GitHash(repo::GitRepo, ref_name::AbstractString)
function GitIndex(repo::GitRepo)
function GitObject(repo::GitRepo, ptr::Ptr{Cvoid})
function GitReference(repo::GitRepo, refname::AbstractString)
function GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString)
function GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString, fetch_spec::AbstractString)
function GitRemoteAnon(repo::GitRepo, url::AbstractString)
function GitRemoteDetached(url::AbstractString)
function GitRemoteHead(head::_GitRemoteHead)
function GitRepo(path::AbstractString)
function GitRevWalker(repo::GitRepo)
function GitShortHash(buf::Buffer)
function GitShortHash(id::AbstractString)
function GitShortHash(obj::GitObject)
function GitSignature(ptr::Ptr{SignatureStruct})
function GitStatus(repo::GitRepo; status_opts=StatusOptions)
function GitTree(c::GitCommit)
function Hermitian(A::AbstractMatrix, uplo::Symbol)
function HostPlatform(p::AbstractPlatform)
function I13636.foo(y::Int;k::Int=1)
function IOContext(io::IO, KV::Pair)
function IOContext(io::IO, dict::ImmutableDict)
function IOStream(name::AbstractString, finalize::Bool)
function IPv4(a::Integer,b::Integer,c::Integer,d::Integer)
function IPv4(host::Integer)
function IPv6(host::Integer)
function IRCode(ir::IRCode, stmts::InstructionStream, cfg::CFG, new_nodes::NewNodeStream)
function IRCode(stmts::InstructionStream, cfg::CFG, linetable::Vector{LineInfoNode}, argtypes::Vector{Any}, meta::Vector{Expr}, sptypes::Vector{VarState})
function IdOffsetRange( values::AbstractUnitRange{<:Integer}, indices::AbstractUnitRange{<:Integer})
function IncrementalCompact(code::IRCode, allow_cfg_transforms::Bool=false)
function IncrementalCompact(code::IRCode, cfg_transform::CFGTransformState)
function IncrementalCompact(parent::IncrementalCompact, code::IRCode, result_offset)
function IndexStyle(::Type{ReinterpretArray{T,N,S,A,true}}) where {T,N,S,A<:AbstractArray{S}}
function InferenceResult(linfo::MethodInstance, cache_argtypes::Vector{Any}, overridden_by_const::BitVector)
function InferenceState(result::InferenceResult, cache_mode::UInt8, interp::AbstractInterpreter)
function InliningState(interp::AbstractInterpreter)
function InliningState(sv::InferenceState, interp::AbstractInterpreter)
function InliningTodo(mi::MethodInstance, ir::IRCode, effects::Effects)
function InstructionStream(len::Int)
function Issue51499CompletionDict(inner::Dict, leaf_func=identity)
function IteratorEltype(::Type{ProductIterator{T}}) where {T<:Tuple}
function IteratorSize(::Type{PartitionIterator{T}}) where {T}
function JLD2_hash(k::Ptr{UInt8}, n::Integer=length, initval::UInt32=UInt32)
function LBTConfig(config::lbt_config_t)
function LBTLibraryInfo(lib_info::lbt_library_info_t, num_exported_symbols::UInt32)
function Libc.getpid(p::Process)
function LinRange(start, stop, len::Integer)
function LineEdit.accept_result_newmode(hist::REPLHistoryProvider)
function LinearAlgebra.rdiv!(B::AbstractMatrix, C::CholeskyPivoted)
function Logging.shouldlog(logger::TestLogger, level, _module, group, id)
function MD(cfg::Config, xs...)
function Markdown.term(io::IO, msg::Message, columns)
function Matrix(A::Hermitian)
function Matrix(A::Symmetric)
function MethodList(mt::Core.MethodTable)
function MulAddMul(alpha::TA, beta::TB) where {TA,TB}
function MultiSelectMenu(options::Array{String,1}; pagesize::Int=10, selected=Int[], warn::Bool=true, kwargs...)
function NewEntity(components::Type{T}...) where T<:Component
function OffsetArray(A::AbstractArray, offsets::Tuple{Vararg{Integer}}; kw...)
function OpaqueClosureCreateInfo(unspec::CallMeta)
function OptimizationState(linfo::MethodInstance, interp::AbstractInterpreter)
function OptimizationState(linfo::MethodInstance, src::CodeInfo, interp::AbstractInterpreter)
function OptimizationState(sv::InferenceState, interp::AbstractInterpreter)
function Pager(text::AbstractString; pagesize::Int=10, kwargs...)
function Parser(str::String; filepath=nothing)
function Pass(test_type::Symbol, orig_expr, data, thrown, source::Union{Nothing,LineNumberNode}=nothing, message_only::Bool=false)
function PermutedDimsArray(data::AbstractArray{T,N}, perm) where {T,N}
function PersistentDict(dict::PersistentDict{K,V}, key, val) where {K,V}
function PersistentDict(kv::Pair, rest::Pair...)
function PipeEndpoint(fd::OS_HANDLE)
function PipeEndpoint(handle::Ptr{Cvoid}, status)
function PipeServer(handle::Ptr{Cvoid}, status)
function PkgId(m::Module, name::String)
function PostOptAnalysisState(result::InferenceResult, ir::IRCode)
function Process(cmd::Cmd, handle::Ptr{Cvoid})
function Profile.print(io::IO, data::AllocResults, fmt::ProfileFormat, format::Symbol)
function RadioMenu(options::Array{String,1}; pagesize::Int=10, warn::Bool=true, keybindings::Vector{Char}=Char[], kwargs...)
function Random.rand!(S::SharedArray{T}) where T
function Random.randn!(S::SharedArray)
function RawBigIntRoundingIncrementHelper(n::RawBigInt{T}, len::Int) where {T<:Unsigned}
function Regex(pattern::AbstractString, flags::AbstractString)
function RemoteCallbacks(c::Callbacks)
function SHA1(bytes::Vector{UInt8})
function SNCA!(domtree::GenericDomTree{IsPostDom}, blocks::Vector{BasicBlock}, max_pre::PreNumber) where {IsPostDom}
function Sampler(::Type{RNG}, ::Type{Pair{A, B}}, n::Repetition) where {RNG<:AbstractRNG, A, B}
function Sampler(::Type{RNG}, ::Type{Tuple{Vararg{T, N}}}, n::Repetition) where {T, N, RNG<:AbstractRNG}
function Sampler(::Type{RNG}, ::Type{T}, n::Repetition) where {T<:Tuple, RNG<:AbstractRNG}
function Sampler(::Type{RNG}, t::Dict, ::Repetition) where RNG<:AbstractRNG
function Sampler(RNG::Type{<:AbstractRNG}, t::BitSet, n::Repetition)
function SamplerRangeFast(r::AbstractUnitRange{T}, ::Type{U}) where {T,U}
function SamplerRangeInt(r::AbstractUnitRange{T}, ::Type{U}) where {T,U}
function SamplerRangeNDL(r::AbstractUnitRange{T}) where {T}
function Scope(parent::Union{Nothing, Scope}, key::ScopedValue{T}, value) where T
function Scope(scope, pairs::Pair{<:ScopedValue}...)
function SecretBuffer!(d::AbstractVector{UInt8})
function SecretBuffer(str::String)
function Serialization.serialize(s::Serialization.AbstractSerializer, t::Broken)
function Serialization.serialize(s::Serialization.AbstractSerializer, t::Pass)
function SharedArray(A::Array)
function Signature(name::AbstractString, email::AbstractString)
function Signature(ptr::Ptr{SignatureStruct})
function Signature(repo::GitRepo)
function SimdLoop.simd_index(::SCartesianIndices2{K}, Ilast::Int, I1::Int) where {K}
function Slices(A::P, slicemap::SM, ax::AX) where {P,SM,AX}
function Stateful(itr::T) where {T}
function Strider(vec::AbstractArray{T}, strides::NTuple{N}, size::NTuple{N}) where {T,N}
function String(a::AbstractVector{Char})
function String(chars::AbstractVector{<:AbstractChar})
function String(l::LazyString)
function String(s::SubString{String})
function SubArray(::IndexCartesian, parent::P, indices::I, ::NTuple{N,Any}) where {P,I,N}
function SubArray(::IndexLinear, parent::P, indices::I, ::NTuple{N,Any}) where {P,I,N}
function SubArray(parent::AbstractArray, indices::Tuple)
function SymTridiagonal(A::AbstractMatrix)
function SymTridiagonal(F::LDLt{<:Any, <:SymTridiagonal})
function Symbol(a::Array{UInt8, 1})
function Symbol(s::String)
function Symbol(s::SubString{String})
function Symmetric(A::AbstractMatrix, uplo::Symbol)
function TCPServer(handle::Ptr{Cvoid}, status)
function TCPSocket(fd::OS_HANDLE)
function TCPSocket(handle::Ptr{Cvoid}, status)
function TTY(fd::OS_HANDLE)
function TTY(handle::Ptr{Cvoid}, status)
function Take(xs::I, n::Integer) where {I}
function TermInfo(raw::TermInfoRaw)
function TerminalMenus.keypress(menu::MultiSelectWithSkipMenu, key::UInt32)
function TerminalMenus.pick(menu::MultiSelectWithSkipMenu, cursor::Int)
function TerminalMenus.writeLine(buf::IOBuffer, menu::MultiSelectMenu{<:Dict}, idx::Int, cursor::Bool)
function TerminalMenus.writeline(buf::IO, m::DynamicMenu, idx::Int, iscursor::Bool)
function TestInnerConstructor(a::String)
function Threads.threadpool(t::Task)
function Time(func::Function, h, mi, s, ms, us; step::Period=Nanosecond1, limit::Int=10000)
function Time(func::Function, h, mi, s, ms; step::Period=Microsecond1, limit::Int=10000)
function Time(func::Function, h, mi, s; step::Period=Millisecond1, limit::Int=10000)
function Time(func::Function, h, mi=0; step::Period=Second1, limit::Int=10000)
function Time(h::Int64, mi::Int64=0, s::Int64=0, ms::Int64=0, us::Int64=0, ns::Int64=0, ampm::AMPM=TWENTYFOURHOUR)
function Time(period::TimePeriod, periods::TimePeriod...)
function Time(t::AbstractString, format::AbstractString; locale::Locale=ENGLISH)
function Timer(cb::Function, timeout; kwargs...)
function Timer(timeout::Real; interval::Real = 0.0)
function TmStruct(t::Real)
function Tridiagonal(F::LU{T,Tridiagonal{T,V}}) where {T,V}
function TwoPhaseDefUseMap(nssas::Int)
function UDPSocket(handle::Ptr{Cvoid}, status)
function UndefVarError_hint(io::IO, ex::UndefVarError)
function VNorNothing(d::Dict, key)
function ZeroBasedUnitRange(a::AbstractUnitRange{T}) where {T}
function \(B::Bidiagonal, D::Diagonal)
function \(B::Bidiagonal, H::UpperHessenberg)
function \(D::Diagonal, B::AbstractVector)
function \(U::UnitUpperTriangular, H::UpperHessenberg)
function \(U::UpperTriangular, H::UpperHessenberg)
function ^(A::Hermitian, p::Integer)
function ^(A::Hermitian{T}, p::Real) where T
function ^(A::Symmetric{<:Complex}, p::Real)
function ^(A::Symmetric{<:Real}, p::Real)
function ^(x::BigFloat, y::BigFloat)
function ^(x::BigFloat, y::BigInt)
function ^(x::BigFloat, y::ClongMax)
function ^(x::BigFloat, y::CulongMax)
function ^(x::Float32, n::Integer)
function ^(x::Rational, n::Integer)
function ^(z::Complex{<:Rational}, n::Integer)
function ^(z::Complex{T}, p::S) where {T<:Real,S<:Real}
function ^(z::T, p::Complex{S}) where {T<:Real,S<:Real}
function _CaptureInCtor(list_file::AbstractString)
function _FDWatcher(fd::RawFD, readable::Bool, writable::Bool)
function _FDWatcher(fd::RawFD, readable::Bool, writable::Bool)
function _FDWatcher(fd::WindowsRawSocket, readable::Bool, writable::Bool)
function _Set(itr, ::EltypeUnknown)
function _UVError(pfx::AbstractString, code::Integer)
function _UVError(pfx::AbstractString, code::Integer, sfxs::AbstractString...)
function __binrepr(m::MIME, x, context)
function __convertSRL(::Type{StepRangeLen{T,R,S,L}}, r::AbstractRange{U}) where {T,R,S,L,U}
function __convertSRL(::Type{StepRangeLen{T,R,S,L}}, r::StepRangeLen{U}) where {T,R,S,L,U}
function __convert_digit(_c::UInt32, base::UInt32)
function __dec(state::Tuple{Int,Int,Vararg{Int}}, indices::Tuple{OrdinalRangeInt,OrdinalRangeInt,Vararg{OrdinalRangeInt}})
function __dec(state::Tuple{Int}, indices::Tuple{OrdinalRangeInt})
function __doc__!(source, mod, meta, def, define::Bool)
function __dot__(x::Expr)
function __inbounds_setindex!(A::Array{T}, x, i1::Int, i2::Int, I::Int...) where {T}
function __inbounds_setindex!(A::Array{T}, x, i::Int) where {T}
function __inbounds_setindex!(A::Memory{T}, x, i1::Int) where {T}
function __inbounds_setindex!(A::Memory{T}, x, i1::Int, i2::Int, I::Int...) where {T}
function __inc(state::Tuple{Int,Int,Vararg{Int}}, indices::Tuple{OrdinalRangeInt,OrdinalRangeInt,Vararg{OrdinalRangeInt}})
function __inc(state::Tuple{Int}, indices::Tuple{OrdinalRangeInt})
function __muldiag!(out, A, D::Diagonal, _add::MulAddMul{ais1,bis0}) where {ais1,bis0}
function __muldiag!(out, D1::Diagonal, D2::Diagonal, _add::MulAddMul{ais1,bis0}) where {ais1,bis0}
function __muldiag!(out, D::Diagonal, B, _add::MulAddMul{ais1,bis0}) where {ais1,bis0}
function __muldiag!(out::Diagonal, D1::Diagonal, D2::Diagonal, _add::MulAddMul{ais1,bis0}) where {ais1,bis0}
function __normalize!(a::AbstractArray, nrm)
function __precompile__(isprecompilable::Bool=true)
function __require(into::Module, mod::Symbol)
function __require_prelocked(uuidkey::PkgId, env=nothing)
function __reshape(p::Tuple{AbstractArray,IndexLinear}, dims::Dims)
function __reshape(p::Tuple{AbstractArray,IndexStyle}, dims::Dims)
function __reshape(p::Tuple{AbstractArray{<:Any,0},IndexCartesian}, dims::Dims)
function __unsafe_string!(out, c::Char, offs::Integer) 
function __unsafe_string!(out, s::SubString{String}, offs::Integer)
function _accumulate!(op, B, A, dims::Integer, init::Union{Nothing, Some})
function _accumulate!(op, B, A, dims::Nothing, init::Union{Nothing, Some})
function _accumulate!(op, B, A::AbstractVector, dims::Nothing, init::Nothing)
function _accumulate!(op, B, A::AbstractVector, dims::Nothing, init::Some)
function _accumulate1!(op, B, v1, A::AbstractVector, dim::Integer)
function _accumulate_pairwise!(op::Op, c::AbstractVector{T}, v::AbstractVector, s, i1, n)::T where {T,Op}
function _accumulaten!(op, B, A, R1, ind, R2, init::Nothing)
function _accumulaten!(op, B, A, R1, ind, R2, init::Some)
function _advance_F!(r::MersenneTwister, adv_vals, idxF, work)
function _advance_I!(r::MersenneTwister, adv_ints, idxI, work)
function _advance_bsbmp!(bsbmp::BitSetBoundedMinPrioritySet)
function _advance_n!(r::MersenneTwister, n::Int64, work::Vector{Float64})
function _advance_to!(r::MersenneTwister, adv::Int64, work)
function _all_match_first(f::F, inds, A, B...) where F<:Function
function _alloftype(ofdesiredtype::Tuple{Vararg{D}}, accumulated, d::Tuple{D,Vararg}, others...) where D
function _annotatedmatch(m::RegexMatch{S}, str::AnnotatedString{S}) where {S<:AbstractString}
function _append!(a::AbstractVector, ::IteratorSize, iter)
function _append!(a::AbstractVector, ::Union{HasLength,HasShape}, iter)
function _apply_permutation!(F::QRPivoted, B::AbstractVecOrMat)
function _approx_cbrt(x::T) where {T<:Union{Float32,Float64}}
function _approx_iter_type(itrT::Type, vstate::Type)
function _atexit(exitcode::Cint)
function _atexit_tests_gen_cmd_eval(expr::String)
function _atexit_tests_gen_cmd_script(temp_dir::String, expr::String)
function _base(base::Integer, x::Integer, pad::Int, neg::Bool)
function _bcs(shape::Tuple, newshape::Tuple)
function _bind(sock::UDPSocket, host::Union{IPv4, IPv6}, port::UInt16, flags::UInt32=UInt32)
function _bind(sock::Union{TCPServer, TCPSocket}, host::Union{IPv4, IPv6}, port::UInt16, flags::UInt32=UInt32)
function _bitreshape(B::BitArray, dims::NTuple{N,Int}) where N
function _bits2float(x::UInt64, ::Type{Float32})
function _bits_findnext(b::Bits, start::Int)
function _bits_findprev(b::Bits, start::Int)
function _bits_getindex(b::Bits, n::Int, offset::Int)
function _bool_check(::Type{Bool}, r, offset)
function _bufcmp(data1::Memory{UInt8}, data2::Memory{UInt8}, sz::Int)
function _builtin_nothrow(ð•ƒ::AbstractLattice, f, argtypes::Vector{Any}, rt)
function _byte_string_classify_nonascii(bytes::AbstractVector{UInt8}, first::Int, last::Int)
function _cat(dims::Int, X::Union{BitArray, Bool}...)
function _cat_t(dims, ::Type{T}, X...) where {T}
function _ccallable(rt::Type, sigt::Type)
function _check0(a::Vector{UInt64}, b::Int, e::Int)
function _check_bitarray_consistency(B::BitArray{N}) where N
function _checked_mul_dims(m::Int, d::Int...)
function _checked_mul_dims(m::Int, n::Int)
function _checked_strides(stp::Tuple, els::Integer, elp::Integer)
function _checkindices(N::Integer, indices, label)
function _chol!(A::AbstractMatrix, ::Type{LowerTriangular})
function _chol!(A::AbstractMatrix, ::Type{UpperTriangular})
function _chol!(A::StridedMatrix{<:BlasFloat}, ::Type{LowerTriangular})
function _chol!(A::StridedMatrix{<:BlasFloat}, ::Type{UpperTriangular})
function _chol!(x::Number, _)
function _circshift_int!(dest::BitVector, src::BitVector, i::Int)
function _cleanup_locked(h::WeakKeyDict)
function _clear_input_area(terminal::AbstractTerminal, state::InputAreaState)
function _cmp_(x::Union{Int64,UInt64}, y::Float64)
function _collect(::Type{T}, itr, isz::SizeUnknown) where T
function _collect(c, itr, ::EltypeUnknown, isz::Union{HasLength,HasShape})
function _collect(cont, itr, ::HasEltype, isz::SizeUnknown)
function _colon(start::T, step, stop::T) where T
function _complete_methods(ex_org::Expr, context_module::Module, shift::Bool)
function _convertSRL(::Type{StepRangeLen{T,R,S,L}}, r::AbstractRange{<:Integer}) where {T,R,S,L}
function _convertSRL(::Type{StepRangeLen{T,R,S,L}}, r::AbstractRange{U}) where {T,R,S,L,U}
function _convertSRL(::Type{StepRangeLen{T,R,S,L}}, r::StepRangeLen{<:Integer}) where {T,R,S,L}
function _copy!(P::PermutedDimsArray{T,N,perm}, src) where {T,N,perm}
function _copy_item!(a::Vector, p, q)
function _copyfrompacked!(ptr_out::Ptr{Out}, ptr_in::Ptr{In}) where {Out, In}
function _copyline(out::IO, io::GenericIOBuffer; keep::Bool=false)
function _copyto_bitarray!(B::BitArray, A::AbstractArray)
function _copyto_impl!(dest::Union{Array,Memory}, doffs::Integer, src::Union{Array,Memory}, soffs::Integer, n::Integer)
function _copyto_int!(dest::BitArray, doffs::Int, src::Union{BitArray,Array}, soffs::Int, n::Int)
function _copytopacked!(ptr_out::Ptr{Out}, ptr_in::Ptr{In}) where {Out, In}
function _copyuntil(out, s::IO, delim::T, keep::Bool) where T
function _cosc(x::Number)
function _cpow(z::Union{T,Complex{T}}, p::Union{T,Complex{T}}) where T
function _cpu_summary(io::IO, cpu::AbstractVector{CPUinfo}, i, j)
function _crc32c(io::IO, nb::Integer, crc::UInt32=0x00000000)
function _crc32c(io::IOBuffer, nb::Integer, crc::UInt32=0x00000000)
function _crc32c(s::Union{String, SubString{String}}, crc::UInt32=0x00000000)
function _cshp(ndim::Int, ::Tuple{}, shape, ::Tuple{})
function _cshp(ndim::Int, ::Tuple{}, shape, nshape)
function _cshp(ndim::Int, dims, shape, nshape)
function _cumsum!(out::AbstractArray, v, dim, ::ArithmeticUnknown)
function _cumsum!(out::AbstractArray{T}, v, dim, ::ArithmeticRounds) where {T}
function _cumsum!(out::AbstractArray{T}, v, dim, ::ArithmeticStyle) where {T}
function _decompose_char!(codepoint::Union{Integer,Char}, dest::Vector{UInt32}, options::Integer)
function _delete!(h::Dict{K,V}, index) where {K,V}
function _deleteat!(B::BitVector, i::Int)
function _deleteat!(a::Vector, i::Integer, delta::Integer)
function _deleteat!(a::Vector, inds, dltd=Nowhere)
function _deletebeg!(a::Vector, delta::Integer)
function _deleteend!(a::Vector, delta::Integer)
function _diag(A::Bidiagonal, k)
function _diagm(size, kv::Pair{<:Integer,<:AbstractVector}...)
function _dim_stack!(::Val{dims}, B::AbstractArray, x1, xrest) where {dims}
function _dominates(domtree::GenericDomTree, bb1::BBNumber, bb2::BBNumber)
function _dropdims(A::AbstractArray, dims::Dims)
function _duplicate(x::BigFloat)
function _eachmethod(f, m::Module, visited, vmt)
function _eachslice(A::AbstractArray, dim::Integer, drop::Bool)
function _eq(t1::Any32, t2::Any32)
function _eq(t1::Tuple, t2::Tuple)
function _eq_missing(t1::Tuple, t2::Tuple)
function _evalpoly(z::Complex, p)
function _exponent_finite_nonzero(x::T) where T<:IEEEFloat
function _extrema_rf(x::NTuple{2,T}, y::NTuple{2,T}) where {T<:IEEEFloat}
function _factorize(A::HermOrSym{T}; check::Bool=true) where T
function _fast(::typeof(max), x::AbstractFloat, y::AbstractFloat)
function _fast(::typeof(min),x::AbstractFloat, y::AbstractFloat)
function _fd(x::Union{LibuvStream, LibuvServer})
function _fieldindex_maythrow(T::DataType, name::Symbol)
function _fieldindex_nothrow(T::DataType, name::Symbol)
function _fieldtype_tfunc(ð•ƒ::AbstractLattice, s, name, exact::Bool)
function _find_root_impl!(parents::Vector{T}, x::Integer) where {T<:Integer}
function _findfirst_loop(f::Function, t)
function _findin(a::Union{AbstractArray, Tuple}, b)
function _findin(r::AbstractRange{<:Integer}, span::AbstractUnitRange{<:Integer})
function _findlast_loop(f::Function, t)
function _findlast_rec(f::Function, x::Tuple)
function _findminmax_inittype(f, A::AbstractArray)
function _findnext_int(testf::Function, B::BitArray, start::Int)
function _findnext_re(re::Regex, str, idx::Integer, match_data::Ptr{Cvoid})
function _findprev_int(testf::Function, B::BitArray, start::Int)
function _foldl_impl(op, init, itr::Union{Tuple,NamedTuple})
function _foldl_impl(op::OP, init, itr) where {OP}
function _foldl_iter(rf, val::T, iter, state) where {T}
function _foldoneto(op, acc, ::Val{N}) where N
function _generate_unsafe_getindex!_body(N::Int)
function _generate_unsafe_setindex!_body(N::Int)
function _generated_stub(gen::Symbol, args::Core.SimpleVector, params::Core.SimpleVector, expand_early::Bool)
function _getfield_fieldindex(s::DataType, name::Const)
function _getfield_tfunc(ð•ƒ::AnyConditionalsLattice, s00, name, setfield::Bool)
function _getfield_tfunc(ð•ƒ::AnyMustAliasesLattice, s00, name, setfield::Bool)
function _getfield_tfunc(ð•ƒ::ConstsLattice, s00, name, setfield::Bool)
function _getfield_tfunc(ð•ƒ::InferenceLattice, s00, name, setfield::Bool)
function _getfield_tfunc(ð•ƒ::JLTypeLattice, s00, name, setfield::Bool)
function _getfield_tfunc(ð•ƒ::PartialsLattice, s00, name, setfield::Bool)
function _getindex(::IndexCartesian, A::AbstractArray, I::Vararg{Int,M}) where M
function _getindex(::IndexCartesian, A::AbstractArray{T,N}, I::Vararg{Int, N}) where {T,N}
function _getindex(::IndexLinear, A::AbstractArray, I::Vararg{Int,M}) where M
function _getindex(::IndexSCartesian2, A::AbstractArray{T,N}, I::Vararg{Int, N}) where {T,N}
function _getindex(::IndexSCartesian2, A::AbstractArray{T,N}, ind::SCartesianIndex2) where {T,N}
function _getindex(Q::AbstractQ, ::Colon, J::AbstractVector{<:Integer})
function _getindex(Q::AbstractQ, ::Colon, j::Int)
function _getindex(l::IndexStyle, A::AbstractArray, I::Union{Real, AbstractArray}...)
function _getindex(r, s::AbstractUnitRange)
function _getindex(r, s::AbstractUnitRange{Bool})
function _getindex(r, s::StepRange)
function _getindex(r, s::StepRange{Bool})
function _getindex(tree::GitTree, target::AbstractString)
function _getindex(v::AbstractRange, i::Integer)
function _getindex(v::UnitRange{T}, i::Integer) where T
function _getindex(v::UnitRange{T}, i::Integer) where {T<:OverflowSafe}
function _getindex_hiprec(r::StepRangeLen, i::Integer) 
function _getindex_hiprec(r::StepRangeLen{<:Any,<:TwicePrecision,<:TwicePrecision}, i::Integer)
function _getindex_ptr(a::ReinterpretArray{T}, inds...) where {T}
function _getmeta(body::Array{Any,1}, sym::Symbol, delete::Bool)
function _getmeta(body::Expr, sym::Symbol, delete::Bool)
function _groupedunique!(A::AbstractVector)
function _grow!(pred!, v::AbstractVector, itrs)
function _growat!(a::Vector, i::Integer, delta::Integer)
function _growbeg!(a::Vector, delta::Integer)
function _growbeg0!(b::Bits, nchunks::Int)
function _growend!(a::Vector, delta::Integer)
function _growend0!(b::Bits, nchunks::Int)
function _hasmethod_tfunc(interp::AbstractInterpreter, argtypes::Vector{Any}, sv::AbsIntState)
function _helpmode(io::IO, line::AbstractString, mod::Module=Main, internal_accesses::Union{Nothing, Set{Pair{Module,Symbol}}}=nothing)
function _hermitianpart!(A::AbstractMatrix)
function _hvcat(rows::Tuple{Vararg{Int}}, A::Union{AbstractArray,AbstractQ,UniformScaling,Number}...; array_type = promote_to_array_type)
function _hypot(x::Float16, y::Float16)
function _hypot(x::Float32, y::Float32)
function _hypot(x::NTuple{N,<:IEEEFloat}) where {N}
function _hypot(x::NTuple{N,<:Number}) where {N}
function _improve_cbrt(x::Float32, t::Float32)
function _improve_cbrt(x::Float64, t::Float64)
function _in_range(x, r::AbstractRange)
function _include(mapexpr::Function, mod::Module, _path::AbstractString)
function _include_dependency(mod::Module, _path::AbstractString; track_content=true)
function _include_from_serialized(pkg::PkgId, path::String, ocachepath::Union{Nothing, String}, depmods::Vector{Any})
function _ind2sub(A::AbstractArray, ind)
function _ind2sub(inds::Union{DimsInteger{N},Indices{N}}, ind::AbstractVector{<:Integer}) where N
function _ind2sub_recurse(indslast::NTuple{1}, ind)
function _indexedby(r::AbstractUnitRange{<:Integer}, ax::AbstractUnitRange)
function _indices_sub(i1::AbstractArray, I...)
function _indicesmightoverlap(A::Tuple{AbstractArray, Vararg{Any}}, B::Tuple{AbstractArray, Vararg{Any}})
function _indicesmightoverlap(A::Tuple{AbstractRange, Vararg{Any}}, B::Tuple{AbstractRange, Vararg{Any}})
function _indicesmightoverlap(A::Tuple{AbstractUnitRange, Vararg{Any}}, B::Tuple{AbstractUnitRange, Vararg{Any}})
function _insert_extension_triggers(parent::PkgId, extensions::Dict{String, Any}, weakdeps::Dict{String, Any})
function _insert_int!(B::BitVector, i::Int, item)
function _inv(A::HermOrSym)
function _ipiv2perm_bk(v::AbstractVector{T}, maxi::Integer, uplo::AbstractChar, rook::Bool) where T
function _ipiv_cols!(A::LU, order::OrdinalRange, B::AbstractVecOrMat)
function _ipiv_rows!(A::LU, order::OrdinalRange, B::AbstractVecOrMat)
function _is_declared_inline(method::Method, inline::Bool)
function _is_link(s::AbstractString)
function _is_mailto(s::AbstractString)
function _isascii(code_units::AbstractVector{CU}, first, last) where {CU}
function _isequal(t1::Any32, t2::Any32)
function _isequal(t1::Tuple{Any,Vararg{Any}}, t2::Tuple{Any,Vararg{Any}})
function _isone_cachefriendly(A::AbstractMatrix, m::Int)
function _isone_triacheck(A::AbstractMatrix, m::Int)
function _isself(ft::DataType)
function _issorted(v::AbstractVector, lo::Integer, hi::Integer, o::Ordering)
function _istril(A::AbstractMatrix, k)
function _istriu(A::AbstractMatrix, k)
function _isvalid_utf8_dfa(state::_UTF8DFAState, bytes::AbstractVector{UInt8}, first::Int = firstindex(bytes), last::Int = lastindex(bytes))
function _iterate(r::IdOffsetRange, i...)
function _keepat!(a::AbstractVector, inds)
function _keepat!(a::AbstractVector, m::AbstractVector{Bool})
function _kron!(C, A::AbstractMatrix, B::AbstractMatrix)
function _kron!(C, A::AbstractMatrix, b::AbstractVector)
function _kron!(C, a::AbstractVector, B::AbstractMatrix)
function _lift_one_interp_helper(expr::Expr, in_quote_context, letargs)
function _lift_svec_ref(def::Expr, compact::IncrementalCompact)
function _linspace(::Type{T}, start_n::Integer, stop_n::Integer, len::Integer, den::Integer) where T<:IEEEFloat
function _linspace(start::T, stop::T, len::Integer) where {T<:IEEEFloat}
function _linspace1(::Type{T}, start, stop, len::Integer) where T<:IEEEFloat
function _log(x::Float32, base, func)
function _log(x::Float64, base, func)
function _lookup_corrected(ip::UInt)
function _lucopy(A::SymTridiagonal, T)
function _make_makeargs(args::Tuple, n::Int)
function _make_makeargs1(bc::Broadcasted, n::Int)
function _mapreduce(f, op, ::IndexLinear, A::AbstractArrayOrBroadcasted)
function _mapreduce(f, op, ::IndexLinear, itr::SkipMissing{<:AbstractArray})
function _mapreduce(f::F, op::OP, style::IndexSCartesian2{K}, A::AbstractArrayOrBroadcasted) where {F,OP,K}
function _mapreduce_prod(f, x, D::Diagonal, y)
function _mapreducedim!(f, op, R::AbstractArray, A::AbstractArrayOrBroadcasted)
function _matched_map!(f, s1::BitSet, s2::BitSet)
function _maxlength(t::Tuple, t2::Tuple, t3::Tuple...)
function _maxndims(::Type{<:Tuple{T, S}}) where {T, S}
function _maybe_reindex(V, I, ::Tuple{})
function _memcmp(a::Union{Ptr{UInt8},AbstractString}, b::Union{Ptr{UInt8},AbstractString}, len::Int)
function _memory_offset(x::AbstractArray, I::Vararg{Any,N}) where {N}
function _memoryref_isassigned_tfunc(ð•ƒ::AbstractLattice, mem, order, boundscheck)
function _memoryrefget_tfunc(ð•ƒ::AbstractLattice, mem, order, boundscheck)
function _mul!(C::AbstractMatrix, A::AbstractMatrix, B::BiTriSym, _add::MulAddMul = MulAddMul)
function _mul!(C::AbstractMatrix, A::BiTriSym, B::BiTriSym, _add::MulAddMul = MulAddMul)
function _mul!(C::AbstractMatrix, A::BiTriSym, B::Diagonal, _add::MulAddMul = MulAddMul)
function _mul!(C::AbstractMatrix, A::Diagonal, B::BiTriSym, _add::MulAddMul = MulAddMul)
function _mul!(C::AbstractVecOrMat, A::BiTriSym, B::AbstractVecOrMat, _add::MulAddMul = MulAddMul)
function _mul_high(a::Int128, b::Int128)
function _mul_high(a::T, b::T) where {T<:Union{Signed, Unsigned}}
function _mul_high(a::UInt128, b::UInt128)
function _newindexer(indsA::Tuple)
function _nextind_str(s, i::Int)
function _nloops(N::Int, itersym::Symbol, arraysym::Symbol, args::Expr...)
function _nloops(N::Int, itersym::Symbol, rangeexpr::Expr, args::Expr...)
function _nthreads_in_pool(tpid::Int8)
function _ntuple(f::F, n) where F
function _one(unit::T, x::AbstractMatrix) where T
function _oracle_check(compact::IncrementalCompact)
function _overlapping_range_isdisjoint(a::AbstractRange{T}, b::AbstractRange{T}) where T<:Integer
function _parse(stream::IO; greedy::Bool = true, raise::Bool = true)
function _parse_input_line_core(s::String, filename::String)
function _parse_key(l::Parser)
function _parse_local_time(l::Parser, skip_hour=false)::Err{NTuple{4, Int64}}
function _permutedims!(P::PermutedDimsArray, src, R1, R2, R3, ds, dp)
function _permutedims!(P::PermutedDimsArray, src, R1::CartesianIndices{0}, R2, R3, ds, dp)
function _pop!(h::Dict, index)
function _precision(x, base::Integer=2)
function _precision(x::BigFloat)  
function _prepend!(a::Vector, ::IteratorSize, iter)
function _prepend!(a::Vector, ::Union{HasLength,HasShape}, iter)
function _prettify_bigfloat(s::String)::String
function _promote(x::T, y::S) where {T,S}
function _push_deleted!(dltd, a::Vector, ind)
function _rand!(r::MersenneTwister, A::Array{T}, n64::Int, I::FloatInterval_64) where T
function _rand!(rng::AbstractRNG, z::BigFloat, sp::SamplerBigFloat)
function _rand!(rng::AbstractRNG, z::BigFloat, sp::SamplerBigFloat, ::CloseOpen01{BigFloat})
function _rand!(rng::AbstractRNG, z::BigFloat, sp::SamplerBigFloat, ::CloseOpen12{BigFloat})
function _rand(A::Type{<: AbstractArray}, shape)
function _rand(A::Type{<:Array}, shape)
function _rand128(r::AbstractRNG, ::Type{Float64})
function _rand_filename(len::Int=4) 
function _rand_max383!(r::MersenneTwister, A::UnsafeView{Float64}, I::FloatInterval_64)
function _randexp(rng::AbstractRNG, ri::UInt64)
function _randjump(r::MersenneTwister, jumppoly::DSFMT.GF2X)
function _randn(rng::AbstractRNG, r::UInt64)
function _rdiv!(B::AbstractVecOrMat, A::AbstractVecOrMat, D::Diagonal)
function _rdiv!(C::AbstractMatrix, A::AbstractMatrix, B::Bidiagonal)
function _rdiv!(Dc::Diagonal, Db::Diagonal, Da::Diagonal)
function _rdiv!(T::Tridiagonal, S::Union{SymTridiagonal,Tridiagonal}, D::Diagonal)
function _read_dependency_src(io::IO, filename::AbstractString, includes::Vector{CacheHeaderIncludes}=CacheHeaderIncludes[])
function _readkey(stream::IO=stdin)
function _redirect_io_global(io, unix_fd::Int)
function _redirect_io_libc(stream, unix_fd::Int)
function _reformat_bt(bt::Array{Ptr{Cvoid},1}, bt2::Array{Any,1})
function _reinterpret(::Type{Out}, x::In) where {Out, In}
function _repl(x, brief::Bool=true, mod::Module=Main, internal_accesses::Union{Nothing, Set{Pair{Module,Symbol}}}=nothing)
function _replace!(new::Callable, res::AbstractArray, A::AbstractArray, count::Int)
function _replace!(new::Callable, t::Dict{K,V}, A::AbstractDict, count::Int) where {K,V}
function _replace!(new::Callable, t::Set{T}, ::AbstractSet, count::Int) where {T}
function _replace(f::Callable, t::Tuple, count::Int)
function _replace(io, repl_s::SubstitutionString, str, r, re)
function _replace(t::Tuple, count::Int, old_new::Tuple{Vararg{Pair}})
function _replace_(io::IO, str, pat_repl::NTuple{N, Pair}, count::Int) where N
function _replace_(str, pat_repl::NTuple{N, Pair}, count::Int) where N
function _replace_init(str, pat_repl::NTuple{N, Pair}, count::Int) where N
function _require(pkg::PkgId, env=nothing)
function _require_from_serialized(uuidkey::PkgId, path::String, ocachepath::Union{String, Nothing})
function _require_prelocked(uuidkey::PkgId, env=nothing)
function _reshape(A::AbstractVector, inds::Tuple{OffsetAxis})
function _reshape(parent::AbstractArray, dims::Dims)
function _reshape(v::AbstractVector, dims::Dims{1})
function _reshaped_strides(::Dims{0}, reshaped::Int, msz::Int, ::Int, ::Int, ::Dims, ::Dims)
function _reshaped_strides(sz::Dims, reshaped::Int, msz::Int, mst::Int, n::Int, apsz::Dims, apst::Dims)
function _resize_int!(B::BitVector, n::Int)
function _return_type(interp::AbstractInterpreter, t::DataType)
function _reverse!(A::AbstractArray{<:Any,N}, dims::NTuple{M,Int}) where {N,M}
function _reverse!(B::BitVector, ::Colon)
function _reverse(A::BitArray, d::Int)
function _reverse(r::StepRangeLen, ::Colon)
function _rm_strings_and_comments(code::Union{String,SubString{String}})
function _rmul_or_fill!(C::AbstractArray, beta::Number)
function _rot_mul_vecormat(R::AbstractRotation{T}, A::AbstractVecOrMat{S}) where {T,S}
function _round_digits(x, r::RoundingMode, digits::Integer, base)
function _round_invstep(x, invstep, r::RoundingMode)
function _round_invstepsqrt(x, invstepsqrt, r::RoundingMode)
function _round_sigdigits(x, r::RoundingMode, sigdigits::Integer, base)
function _round_step(x, step, r::RoundingMode)
function _rs_iterator(P, mi::NTuple{M}) where M
function _rsearch(a::ByteArray, b::AbstractChar, i::Integer = length(a))
function _rsearch(a::Union{String,ByteArray}, b::Union{Int8,UInt8}, i::Integer = sizeof(a))
function _rsearchindex(s::AbstractVector{<:Union{Int8,UInt8}}, t::AbstractVector{<:Union{Int8,UInt8}}, _k::Integer)
function _rsearchindex(s::String, t::String, i::Integer)
function _search(a::ByteArray, b::AbstractChar, i::Integer = 1)
function _search(a::Union{String,ByteArray}, b::Union{Int8,UInt8}, i::Integer = 1)
function _searchindex(s::String, t::String, i::Integer)
function _send_async(sock::UDPSocket, ipaddr::Union{IPv4, IPv6}, port::UInt16, buf)
function _setbit(x::UInt128, i)
function _setenv(svar::AbstractString, sval::AbstractString, overwrite::Bool=true)
function _setenv(var::AbstractString, val::AbstractString, overwrite::Bool=true)
function _setindex!(::IndexCartesian, A::AbstractArray, v, I::Vararg{Int,M}) where M
function _setindex!(::IndexCartesian, A::AbstractArray{T,N}, v, I::Vararg{Int, N}) where {T,N}
function _setindex!(::IndexLinear, A::AbstractArray, v, I::Vararg{Int,M}) where M
function _setindex!(::IndexSCartesian2, A::AbstractArray{T,N}, v, I::Vararg{Int, N}) where {T,N}
function _setindex!(::IndexSCartesian2, A::AbstractArray{T,N}, v, ind::SCartesianIndex2) where {T,N}
function _setindex!(l::IndexStyle, A::AbstractArray, x, I::Union{Real, AbstractArray}...)
function _setindex(v, i::Integer, args::Vararg{Any,N}) where {N}
function _setindex_ptr!(a::ReinterpretArray{T}, v, inds...) where {T}
function _setint!(s::BitSet, idx::Int, b::Bool)
function _show_content(io::IO, d::DatePart{c}) where c
function _show_content(io::IO, d::Delim)
function _show_content(io::IO, d::Delim{<:AbstractChar, N}) where N
function _show_cpuinfo(io::IO, info::Sys.CPUinfo, header::Bool=true, prefix::AbstractString)
function _show_empty(io::IO, X::Array)
function _show_nd_label(io::IO, a::AbstractArray, idxs)
function _show_nonempty(io::IO, X::AbstractArray, prefix::String)
function _shrink!(shrinker!::F, v::AbstractVector, itrs) where F
function _shrink(shrinker!::F, itr, itrs) where F
function _simple_count(::typeof(identity), x::Array{Bool}, init::T=0) where {T}
function _slice_index(s::Slices, c...)
function _sort!(v::AbstractVector, ::InsertionSortAlg, o::Ordering, kw)
function _sort!(v::AbstractVector, a::Algorithm, o::Ordering, kw)
function _sort!(v::AbstractVector, a::CheckSorted, o::Ordering, kw)
function _sort!(v::AbstractVector, a::ComputeExtrema, o::Ordering, kw)
function _sort!(v::AbstractVector, a::ConsiderRadixSort, o::DirectOrdering, kw)
function _sort!(v::AbstractVector, a::IEEEFloatOptimization, o::Ordering, kw)
function _sort!(v::AbstractVector, a::IsUIntMappable, o::Ordering, kw)
function _sort!(v::AbstractVector, a::MissingOptimization, o::Ordering, kw)
function _sort!(v::AbstractVector, a::RadixSort, o::DirectOrdering, kw)
function _sort!(v::AbstractVector, a::Small{N}, o::Ordering, kw) where N
function _sort!(v::AbstractVector, a::StableCheckSorted, o::Ordering, kw)
function _sort!(v::AbstractVector{<:Integer}, ::CountingSort, o::DirectOrdering, kw)
function _sort!(v::AbstractVector{<:Integer}, a::ConsiderCountingSort, o::DirectOrdering, kw)
function _sort!(v::AbstractVector{Bool}, ::BoolOptimization, o::Ordering, kw)
function _sort(x::NTuple, o::Ordering)
function _sortedfindin(v::Union{AbstractArray, Tuple}, w)
function _sortperm(A::AbstractArray; alg, order, scratch, dims...)
function _sortslices(A::AbstractArray, d::Val{dims}; kws...) where dims
function _spawn(cmd::Cmd, stdios::SpawnIOs)
function _spawn(cmd::Cmd, stdios::SpawnIOs, chain::ProcessChain)
function _spawn(cmds::AbstractCmd, stdios::SpawnIOs)
function _spawn(cmds::AndCmds, stdios::SpawnIOs, chain::ProcessChain)
function _spawn(cmds::ErrOrCmds, stdios::SpawnIOs, chain::ProcessChain)
function _spawn(cmds::OrCmds, stdios::SpawnIOs, chain::ProcessChain)
function _spawn(redirect::CmdRedirect, stdios::SpawnIOs, args...)
function _spawn_primitive(file, cmd::Cmd, stdio::SpawnIOs)
function _spawn_set_thrpool(t::Task, tp::Symbol)
function _splice_int!(B::BitVector, r, ins)
function _split_rest(a::Union{AbstractArray, Core.SimpleVector}, n::Int)
function _split_rest(a::Union{Vector, BitVector}, n::Int)
function _split_rest(s::AbstractString, n::Int)
function _splitdir_nodrive(a::String, b::String)
function _sqrt_pow(a::Number, s)
function _stack(dims, ::Union{HasShape, HasLength}, iter)
function _stack_size_check(x, ax1::Tuple)
function _stmt(code::CodeInfo, idx::Int)
function _stmt(code::IRCode, idx::Int)
function _stmt(compact::IncrementalCompact, idx::Int)
function _string(a::Union{Char, String, SubString{String}, Symbol}...)
function _string(x::BigFloat, fmt::String)::String
function _sub2ind(A::AbstractArray, I...)
function _sub2ind(inds::Indices{1}, I1::AbstractVector{T}, I::AbstractVector{T}...) where T<:Integer
function _sub2ind_recurse(::Tuple{}, L, ind, i::Integer, I::Integer...)
function _sub2ind_recurse(inds, L, ind, i::Integer, I::Integer...)
function _sub2ind_vecs(inds, I::AbstractVector...)
function _subtypes_in!(mods::Array, x::Type)
function _summarize_exception(kws, io::IO, e::TaskFailedException)
function _summarize_task_exceptions(io::IO, exc, prefix = nothing)
function _svd!(A::StridedMatrix{T}, full::Bool, alg::QRIteration) where {T<:BlasFloat}
function _swap_cols!(B::AbstractMatrix, i::Integer, j::Integer)
function _swap_cols!(B::AbstractVector, i::Integer, j::Integer)
function _swap_rows!(B::AbstractMatrix, i::Integer, j::Integer)
function _swap_rows!(B::AbstractVector, i::Integer, j::Integer)
function _sym_to_tpid(tp::Symbol)
function _symbol(x::Enum)
function _term_header(io::IO, md, char, columns)
function _test_at_locals1(::Any, ::Any)
function _test_at_locals2(a::Any, ::Any, c::T) where T
function _test_flags(val, vflag::AbstractString, fmt::AbstractString, res::AbstractString, prefix::AbstractString)
function _thisind_str(s, i::Int)
function _to_float(number::U, ep) where {U<:Unsigned}
function _to_subscript_indices(A::AbstractArray{T,N}, I::Integer...) where {T,N}
function _totuple(::Type{T}, itr, s::Vararg{Any,N}) where {T,N}
function _totuple(T::Type{All32{E,N}}, itr) where {E,N}
function _tp_prod(t::TwicePrecision, x, y...)
function _tpid_to_sym(tpid::Int8)
function _trimdocs(md::Markdown.MD, brief::Bool)
function _triscale!(A::LowerOrUnitLowerTriangular, B::UnitLowerTriangular, c::Number, _add)
function _triscale!(A::LowerOrUnitLowerTriangular, c::Number, B::UnitLowerTriangular, _add)
function _triscale!(A::LowerTriangular, B::LowerTriangular, c::Number, _add)
function _triscale!(A::LowerTriangular, c::Number, B::LowerTriangular, _add)
function _triscale!(A::UpperOrUnitUpperTriangular, B::UnitUpperTriangular, c::Number, _add)
function _triscale!(A::UpperOrUnitUpperTriangular, c::Number, B::UnitUpperTriangular, _add)
function _triscale!(A::UpperTriangular, B::UpperTriangular, c::Number, _add)
function _triscale!(A::UpperTriangular, c::Number, B::UpperTriangular, _add)
function _truncate_at_width_or_chars(ignore_ANSI::Bool, str, width, rpad=false, chars, truncmark)
function _trylock(rl::ReentrantLock, ct::Task)
function _tryonce_download_from_cache(desired_url::AbstractString)
function _tryrequire_from_serialized(modkey::PkgId, build_id::UInt128)
function _tryrequire_from_serialized(modkey::PkgId, path::String, ocachepath::Union{Nothing, String}, sourcepath::String, depmods::Vector{Any})
function _tryrequire_from_serialized(pkg::PkgId, path::String, ocachepath::Union{Nothing, String})
function _trywait(t::Union{Timer, AsyncCondition})
function _type(code::CodeInfo, idx::Int)
function _type(code::IRCode, idx::Int)
function _type(compact::IncrementalCompact, idx::Int)
function _typed_hcat(::Type{T}, A::AbstractVecOrTuple{AbstractVecOrMat}) where T
function _typed_hvncat(::Type{T}, ::Val{N}) where {T, N}
function _typed_hvncat(::Type{T}, ::Val{N}, as...) where {T, N}
function _typed_hvncat(::Type{T}, ::Val{N}, as::AbstractArray...) where {T, N}
function _typed_hvncat(::Type{T}, dims::NTuple{N, Int}, row_first::Bool, xs::Number...) where {T, N}
function _typed_hvncat(T::Type, ::Val{N}, xs::Number...) where N
function _typed_hvncat(T::Type, dims::NTuple{N, Int}, row_first::Bool, as...) where {N}
function _typed_hvncat(T::Type, shape::NTuple{N, Tuple}, row_first::Bool, as...) where {N}
function _typed_hvncat(T::Type, shape::Tuple{Tuple}, row_first::Bool, xs...)
function _typed_hvncat_1d(::Type{T}, ds::Int, ::Val{row_first}, as...) where {T, row_first}
function _typed_hvncat_dims(::Type{T}, dims::NTuple{N, Int}, row_first::Bool, as::Tuple) where {T, N}
function _typed_hvncat_shape(::Type{T}, shape::NTuple{N, Tuple}, row_first, as::Tuple) where {T, N}
function _typed_stack(::Colon, ::Type{T}, ::Type{S}, A, Aax=_iterator_axes) where {T, S}
function _typed_stack(dims::Integer, ::Type{T}, ::Type{S}, ::HasShape{N}, A) where {T,S,N}
function _typed_vcat!(a::AbstractVector{T}, V::AbstractVecOrTuple{AbstractVector}) where T
function _typed_vcat(::Type{T}, A::AbstractVecOrTuple{AbstractVecOrMat}) where T
function _typeddict(d::AbstractDict, others::AbstractDict...)
function _typeinf(interp::AbstractInterpreter, frame::InferenceState)
function _typeinf_identifier(frame::Core.Compiler.InferenceState)
function _typename(a::Union)
function _typeof_tfunc(ð•ƒ::AbstractLattice, t)
function _unchecked_cast(::Type{BigInt}, x::BigFloat, r::MPFRRoundingMode)
function _unchecked_cast(::Type{Int64}, x::BigFloat, r::MPFRRoundingMode)
function _unchecked_cast(::Type{T}, x::BigFloat, r::MPFRRoundingMode) where T<:Union{Signed, Unsigned}
function _unchecked_cast(::Type{UInt64}, x::BigFloat, r::MPFRRoundingMode)
function _unique!(f, A::AbstractVector, seen::Set, current::Integer, i::Integer)
function _unique!(f, out::AbstractVector, C, seen::Set, i)
function _unsafe_bitsetindex!(Bc::Array{UInt64}, x::Bool, i1::Int, i2::Int)
function _unsafe_getindex!(X::BitArray, B::BitArray, I0::Union{AbstractUnitRange{Int},Slice})
function _unsafe_getindex(::IndexStyle, A::AbstractArray, I::Vararg{Union{Real, AbstractArray}, N}) where N
function _unsafe_getindex(A::ReshapedArray{T,N}, indices::Vararg{Int,N}) where {T,N}
function _unsafe_setindex!(A::ReshapedArray{T,N}, val, indices::Vararg{Int,N}) where {T,N}
function _unsafe_setindex!(B::BitArray, X::AbstractArray, I::BitArray)
function _unsetenv(svar::AbstractString)
function _unsetenv(var::AbstractString)
function _unsetindex!(A::Array, i::Int)
function _unsetindex!(A::MemoryRef{T}) where T
function _uv_hook_close(proc::Process)
function _uv_hook_close(sock::UDPSocket)
function _uv_hook_close(t::Union{Timer, AsyncCondition})
function _uv_hook_close(uv::FileMonitor)
function _uv_hook_close(uv::FolderMonitor)
function _uv_hook_close(uv::PollingFileWatcher)
function _uv_hook_close(uv::Union{LibuvStream, LibuvServer})
function _uv_hook_close(uv::_FDWatcher)
function _vecormat_mul_rot(A::AbstractVecOrMat{T}, R::AbstractRotation{S}) where {T,S}
function _vectorpinv(dualfn::Tf, v::AbstractVector{Tv}, tol) where {Tv,Tf}
function _views(ex::Expr)
function _wait(fdw::_FDWatcher, mask::FDEvent)
function _wait(t::Task)
function _wait2(c::GenericCondition, waiter::Task, first::Bool=false)
function _wait2(t::Task, waiter::Task)
function _wide_qr_ldiv!(A::QR{T}, B::AbstractMatrix{T}) where T
function _win_mkstemp(temppath::AbstractString)
function _write_capture(io::IO, group::Int, str, r, re)
function _write_capture(io::IO, group::Int, str, r, re::RegexAndMatchData)
function _xfadjoint_unwrap(itr::Filter)
function _xfadjoint_unwrap(itr::Flatten)
function _xfadjoint_unwrap(itr::Generator)
function _zip_iterate_interleave(xs1, xs2, ds::Tuple{Bool,Vararg{Any}})
function abmult(r::Int, x0)
function abmult2(r0::Int, x0)
function abort(rb::GitRebase)
function absdiff(x::T,y::T) where {T<:Signed}
function absdiff(x::T,y::T) where {T<:Unsigned}
function abspath(a::String)::String
function abspaths(A::Vector)
function abstract_call(interp::AbstractInterpreter, arginfo::ArgInfo, irsv::IRInterpretationState)
function abstract_call(interp::AbstractInterpreter, arginfo::ArgInfo, sv::InferenceState)
function abstract_call_unionall(interp::AbstractInterpreter, argtypes::Vector{Any}, call::CallMeta)
function abstract_eval_cfunction(interp::AbstractInterpreter, e::Expr, vtypes::Union{VarTable,Nothing}, sv::AbsIntState)
function abstract_eval_foreigncall(interp::AbstractInterpreter, e::Expr, vtypes::Union{VarTable,Nothing}, sv::AbsIntState)
function abstract_eval_globalref(interp::AbstractInterpreter, g::GlobalRef, sv::AbsIntState)
function abstract_eval_globalref_type(g::GlobalRef)
function abstract_eval_phi(interp::AbstractInterpreter, phi::PhiNode, vtypes::Union{VarTable,Nothing}, sv::AbsIntState)
function abstract_eval_phi_stmt(interp::AbstractInterpreter, phi::PhiNode, ::Int, irsv::IRInterpretationState)
function abstract_eval_ssavalue(s::SSAValue, ssavaluetypes::Vector{Any})
function abstract_eval_value_expr(interp::AbstractInterpreter, e::Expr, vtypes::Union{VarTable,Nothing}, sv::AbsIntState)
function abstract_finalizer(interp::AbstractInterpreter, argtypes::Vector{Any}, sv::AbsIntState)
function abstract_modifyfield!(interp::AbstractInterpreter, argtypes::Vector{Any}, si::StmtInfo, sv::AbsIntState)
function accept(callback, server::LibuvServer)
function accept(l::Parser, f::Union{Function, Char})::Bool
function accept(server::LibuvServer, client::LibuvStream)
function accept_batch(l::Parser, f::F)::Bool where {F}
function accept_batch_underscore(l::Parser, f::ValidSigs, fail_if_underscore=true)::Err{Tuple{Bool, Bool}}
function accept_n(l::Parser, n, f::F)::Bool where {F}
function accept_nonblock(server::PipeServer)
function accept_nonblock(server::PipeServer, client::PipeEndpoint)
function accept_nonblock(server::TCPServer)
function accept_nonblock(server::TCPServer, client::TCPSocket)
function accept_result(s::MIState, p::TextInterface)
function access_env(onError::Function, str::AbstractString)
function access_env(onError::Function, var::AbstractString)
function accumulate!(op, B, A; dims::Union{Integer, Nothing} = nothing, kw...)
function accumulate(op, A; dims::Union{Nothing,Integer}=nothing, kw...)
function accumulate(op, xs::Tuple; init = _InitialValue)
function accumulate_pairwise!(op::Op, result::AbstractVector, v::AbstractVector) where Op
function accumulate_pairwise(op, v::AbstractVector{T}) where T
function acos(A::AbstractMatrix)
function acos(x::T) where T <: Union{Float32, Float64}
function acos(z::Complex)
function acosh(A::AbstractMatrix)
function acosh(A::HermOrSym{<:Real})
function acosh(A::Hermitian{<:Complex})
function acosh(x::T) where T <: Union{Float32, Float64}
function acosh(z::Complex)
function acquire(f, s::Semaphore)
function acquire(s::Semaphore)
function activate(mod::Module=Main)
function activate(p::TextInterface, s::MIState, termbuf::AbstractTerminal, term::TextTerminal)
function activate(p::TextInterface, s::ModeState, termbuf::AbstractTerminal, term::TextTerminal)
function activate_module(s::MIState)
function activate_region(s::PromptState, state::Symbol)
function active_project(search_load_path::Bool=true)
function adce_erase!(phi_uses::Vector{Int}, extra_worklist::Vector{Int}, compact::IncrementalCompact, idx::Int, in_worklist::Bool)
function adce_pass!(ir::IRCode, inlining::Union{Nothing,InliningState}=nothing)
function add!(p::Foo30594, off::Foo30594)
function add!(z::Rational{BigInt}, x::Rational{BigInt}, y::Rational{BigInt})
function add12(x::T, y::T) where {T}
function add1234(x::Tuple{Int32,Int32,Int32,Int32})
function add22condh(xh::Float64, xl::Float64, yh::Float64, yl::Float64)
function add_backedge!(caller::InferenceState, mi::MethodInstance)
function add_backedge!(irsv::IRInterpretationState, mi::MethodInstance)
function add_cycle_backedge!(caller::InferenceState, frame::InferenceState, currpc::Int)
function add_dependency!(ll::LazyLibrary, dep::LazyLibrary)
function add_fetch!(repo::GitRepo, rmt::GitRemote, fetch_spec::String)
function add_flag(newinst::NewInstruction, newflag::UInt32)
function add_history(hist::REPLHistoryProvider, s::PromptState)
function add_inst!(new::NewNodeStream, pos::Int, attach_after::Bool)
function add_nested_key!(keymap::Dict{Char, Any}, key::Union{String, Char}, value; override::Bool = false)
function add_new_idx!(is::InstructionStream)
function add_pending!(compact::IncrementalCompact, pos::Int, attach_after::Bool)
function add_preds!(all_new_preds::Vector{Int32}, bbs::Vector{BasicBlock}, bb_rename_pred::Vector{Int}, old_edge::Int32)
function add_push!(repo::GitRepo, rmt::GitRemote, push_spec::String)
function add_specialisations(dict::Dict{Char,Any}, subdict::Dict{Char,Any}, level::Int)
function add_tag!(tags::Dict{String,String}, tag::String, value::String)
function add_with_overflow(x::T, y::T) where T<:BrokenSignedInt
function add_with_overflow(x::T, y::T) where T<:BrokenUnsignedInt
function addblob!(repo::GitRepo, path::AbstractString)
function addenv(cmd::Cmd, env::Dict; inherit::Bool = true)
function addenv(cmd::Cmd, env::Vector{<:AbstractString}; inherit::Bool = true)
function addenv(cmd::Cmd, pairs::Pair{<:AbstractString}...; inherit::Bool = true)
function adjoint!(B::AbstractMatrix, A::AbstractVector)
function adjoint!(B::AbstractVector, A::AbstractMatrix)
function adjoint(B::BunchKaufman)
function adjoint(F::SVD)
function adjust(df::DateFunction, start, step, limit)
function adjust(func::Function, start; step::Period=Day1, limit::Int=10000)
function adjust_ENV!(env::Dict, PATH::String, LIBPATH::String, adjust_PATH::Bool, adjust_LIBPATH::Bool)
function adjust_ENV!(env::Dict, PATH::String, LIBPATH::String, adjust_PATH::Bool, adjust_LIBPATH::Bool)
function adjust_effects(sv::InferenceState)
function adjusthour(h::Int64, ampm::AMPM)
function admonition(stream::IO, block::MD)
function advance!(r::MersenneTwister, adv_jump, adv, adv_vals, idxF, adv_ints, idxI)
function afterusing(string::String, startpos::Int)
function alignment(io::IO, x::AbstractIrrational)
function alignment(io::IO, x::Complex)
function alignment(io::IO, x::Pair)
function alignment(io::IO, x::Rational)
function alignment(io::IO, x::Real)
function all(B::BitArray)
function all(f, itr::Tuple)
function allindices!(I, B::BitArray)
function allindices!(I, B::BitMatrix)
function allindices!(I, B::BitVector)
function alloc_buf_hook(stream::LibuvStream, size::UInt)
function alloc_request(buffer::IOBuffer, recommended_size::UInt)
function allsubtypes!(m::Module, x::DataType, sts::Set)
function allunique(t::Tuple)
function already_inserted(compact::IncrementalCompact, old::OldSSAValue)
function analyze_escapes(ir::IRCode, nargs::Int, get_escape_cache)
function and_int_tfunc(ð•ƒ::ConstsLattice, x, y)
function annotatedstring_optimize!(s::AnnotatedString)
function annotations(s::AnnotatedString, pos::UnitRange{<:Integer})
function any(B::BitArray)
function any(f, itr::Tuple)
function any_refinable(sv::PostOptAnalysisState)
function any_stmt_may_throw(ir::IRCode, bb::Int)
function append!(B::BitVector, items::BitVector)
function append!(a::Vector, items::AbstractVector)
function append!(bsbmp::BitSetBoundedMinPrioritySet, itr)
function append_c_digits(olength::Int, digits::Unsigned, buf, pos::Int)
function append_c_digits_fast(olength::Int, digits::Unsigned, buf, pos::Int)
function append_d_digits(olength::Int, digits::Unsigned, buf, pos::Int, decchar)
function append_nine_digits(digits::Unsigned, buf, pos::Int)
function append_sign(x, plus::Bool, space::Bool, buf, pos::Int)
function apply_type_tfunc(ð•ƒ::AbstractLattice, headtypetype, args...)
function approve(cache::CachedCredentials, cred::AbstractCredential, url::AbstractString)
function approve(cfg::GitConfig, cred::UserPasswordCredential, url::AbstractString)
function approve(p::CredentialPayload; shred::Bool=true)
function apropos(io::IO, needle::Regex)
function arg_decl_parts(m::Method, html=false)
function arg_gen(cmd::Cmd)
function argmax(r::AbstractRange)
function argmin(r::AbstractRange)
function argtype(expr::Expr)
function argtype_by_index(argtypes::Vector{Any}, i::Int)
function argtype_tail(argtypes::Vector{Any}, i::Int)
function array_new_memory(mem::Memory{UInt8}, newlen::Int)
function array_summary(io::IO, a, inds)
function array_summary(io::IO, a, inds::Tuple{Vararg{OneTo}})
function arrayset_unknown_dim(::Type{T}, n) where T
function artifact_exists(hash::SHA1; honor_overrides::Bool=true)
function artifact_path(hash::SHA1; honor_overrides::Bool=true)
function artifact_paths(hash::SHA1; honor_overrides::Bool=true)
function as_cpumask(cpus::Vector{UInt16})
function as_sub(x::AbstractArray{T,3}) where T
function as_sub(x::AbstractMatrix)
function as_sub(x::AbstractVector)
function ascend_eliminated_preds(bbs::Vector{BasicBlock}, pred::Int)
function ascii(s::String)
function asin(A::AbstractMatrix)
function asin(x::T) where T<:Union{Float32, Float64}
function asin(z::Complex)
function asin_kernel(t::Float32, x::Float32)
function asin_kernel(t::Float64, x::Float64)
function asinh(A::AbstractMatrix)
function asinh(x::T) where T <: Union{Float32, Float64}
function asinh(z::Complex)
function assemble_inline_todo!(ir::IRCode, state::InliningState)
function asterisk_bold(stream::IO, md::MD)
function asterisk_italic(stream::IO, md::MD)
function astname(x::Expr, ismacro::Bool)
function asum(x::AbstractArray)
function asyncmap(f, b::BitArray; kwargs...)
function asyncmap(f, s::AbstractString; kwargs...)
function atan(A::AbstractMatrix)
function atan(x::T) where T<:Union{Float32, Float64}
function atan(y::BigFloat, x::BigFloat)
function atan(y::T, x::T) where T<:Union{Float32, Float64}
function atan(z::Complex)
function atand(y::BigFloat, x::BigFloat)
function atanh(A::AbstractMatrix)
function atanh(x::T) where T <: Union{Float32, Float64}
function atanh(z::Complex{T}) where T
function atexit(f::Function)
function atomic_fence_tfunc(ð•ƒ::AbstractLattice, order)
function atomic_pointermodify_tfunc(ð•ƒ::AbstractLattice, ptr, op, v, order)
function atomic_pointerref_tfunc(ð•ƒ::AbstractLattice, a, order)
function atomic_pointerreplace_tfunc(ð•ƒ::AbstractLattice, ptr, x, v, success_order, failure_order)
function atomic_pointerset_tfunc(ð•ƒ::AbstractLattice, a, v, order)
function atomic_pointerswap_tfunc(ð•ƒ::AbstractLattice, a, v, order)
function authenticate_ssh(libgit2credptr::Ptr{Ptr{Cvoid}}, p::CredentialPayload, username_ptr)
function authenticate_userpass(libgit2credptr::Ptr{Ptr{Cvoid}}, p::CredentialPayload)
function author(c::GitCommit)
function authors(repo::GitRepo)
function autolink(stream::IO, md::MD)
function avisit(f, e::Memory{Any})
function axes(A::AbstractArray{T,N}, d) where {T,N}
function axpy!(Î±, x::AbstractArray, y::AbstractArray)
function bail_out_const_call(interp::AbstractInterpreter, result::MethodCallResult, si::StmtInfo)
function banner(io::IO = stdout; short = false)
function bar(x::T) where T
function bar42190(r::Union{Nothing,Int}, n::Int)
function base64encode(f::Function, args...; context=nothing)
function basic_blocks_starts(stmts::Vector{Any})
function batch_inline!(ir::IRCode, todo::Vector{Pair{Int,Any}}, propagate_inbounds::Bool, params::OptimizationParams)
function beep(s::PromptState, duration::Real=options(s).beep_duration,
function bidiagzero(A::Bidiagonal{<:AbstractMatrix}, i, j)
function bigint_pow(x::BigInt, y::Integer)
function bin(x::Unsigned, pad::Int, neg::Bool)
function binary_trees(io, n::Int)
function bind(c::Channel, task::Task)
function bind(server::PipeServer, name::AbstractString)
function bind(sock::Union{TCPServer, UDPSocket, TCPSocket}, host::IPAddr, port::Integer; ipv6only = false, reuseaddr = false, kws...)
function binding_module(m::Module, s::Symbol)
function binomial(n::BigInt, k::Integer)
function binomial(x::Number, k::Integer)
function binpack(pkg::PkgId)
function binunpack(s::String)
function bit_map!(f::F, dest::BitArray, A::BitArray) where F
function bit_map!(f::F, dest::BitArray, A::BitArray, B::BitArray) where F
function bit_ndigits0z(x::Base.BitUnsigned64)
function bit_ndigits0z(x::UInt128)
function bitcount(Bc::Vector{UInt64}; init::T=0) where {T}
function bitreverse(x::BitInteger)
function bitshow(io::IO, B::BitArray)
function bitstring(x::T) where {T}
function blob(stack :: Stack)
function block_for_inst(compact::IncrementalCompact, idx::NewSSAValue)
function block_for_inst(compact::IncrementalCompact, idx::OldSSAValue)
function block_for_inst(compact::IncrementalCompact, idx::SSAValue)
function block_for_inst(index::Vector{BasicBlock}, inst::Int)
function block_for_inst(index::Vector{Int}, inst::Int)
function block_for_inst(ir::IRCode, inst::Int)
function blockinterp(stream::IO, md::MD)
function blockpower!(A::UpperTriangular, A0::UpperTriangular, p)
function blockquote(stream::IO, block::MD)
function blocktex(stream::IO, md::MD)
function bodyfunction(basemethod::Method)
function bracketed_paste(s::MIState; tabwidth::Int=options(s).tabwidth)
function branch(ref::GitReference)
function branch(repo::GitRepo)
function broadcasted(::AndAnd, a, bc::Broadcasted)
function broadcasted(::OrOr, a, bc::Broadcasted)
function broadcasted(::typeof(-), j::CartesianIndex{N}, I::CartesianIndices{N}) where N
function broadcasted(f::F, arg1, arg2, args...) where {F}
function broadcasted(f::F, arg1, args...) where {F}
function broadcasted(f::F, args...) where {F}
function bslash_completions(string::String, pos::Int)
function buffer_writes(s::LibuvStream, bufsize)
function buffercontents(buf::IOBuffer)
function bunchkaufman!(A::StridedMatrix{<:BlasFloat}, rook::Bool = false; check::Bool = true)
function busywork(n::Int)
function byte_string_classify(bytes::AbstractVector{UInt8})
function bytes2hex(io::IO, itr)
function cache_dependencies(cachefile::String)
function cache_dependencies(f::IO, cachefile::AbstractString)
function cache_file_entry(pkg::PkgId)
function cache_lookup(ð•ƒ::AbstractLattice, linfo::MethodInstance, given_argtypes::Vector{Any}, cache::Vector{InferenceResult})
function cache_result!(interp::AbstractInterpreter, result::InferenceResult)
function cached_return_type(code::CodeInstance)
function call_abi_str(p::AbstractPlatform)
function call_iota(n::Integer,t::DataType)
function call_sig(ir::IRCode, stmt::Expr)
function calldoc(__source__, __module__, str, def::Expr)
function callers(funcname::String, bt::Vector, lidict::LineInfoFlatDict; filename = nothing, linerange = nothing)
function callersf(matchfunc::Function, bt::Vector, lidict::LineInfoFlatDict)
function cancel_beep(s::PromptState)
function canonicalize(x::CompoundPeriod)
function canonicalize_typeassert!(compact::IncrementalCompact, idx::Int, stmt::Expr)
function captsp(x::T, y::S) where {T, S}
function captured_and_shadowed_sp(x::T) where T
function cat_shape(dims, shapes::Tuple)
function catch_inconsistent(x::T) where T
function catdoc(xs::HTML...)
function catdoc(xs::Text...)
function category_abbrev(c::AbstractChar)
function category_code(c::AbstractChar)
function category_code(x::Integer)
function cb22734(ptr::Ptr{Cvoid})
function cbrt(a::Float16)
function cbrt(x::Union{Float32,Float64})
function ccall_macro_parse(expr::Expr)
function ccall_reassigned_ptr(ptr::Ptr{Cvoid})
function cconvert(::Type{Cstring}, s::SecretBuffer)
function cconvert(::Type{Cwstring}, s::AbstractString)
function cconvert(::Type{Cwstring}, v::Vector{Cwchar_t})
function cd(dir::AbstractString)
function cd(f::Function, dir::AbstractString)
function cd(f::Function, dir::AbstractString)
function cdiv(a::Float64, b::Float64, c::Float64, d::Float64)
function ceilfloor(x::Float64)
function center(A::AbstractArray, r::RoundingMode=RoundDown)
function cfg_delete_edge!(cfg::CFG, from::Int, to::Int)
function cfg_inline_item!(ir::IRCode, idx::Int, todo::InliningTodo, state::CFGInliningState, from_unionsplit::Bool=false)
function cfg_insert_edge!(cfg::CFG, from::Int, to::Int)
function cfg_simplify!(ir::IRCode)
function cglobal_tfunc(ð•ƒ::AbstractLattice, fptr, t)
function challenge_prompt(cmd::Cmd, challenges)
function challenge_prompt(code::Expr, challenges)
function channeled_tasks(n::Int, funcs...; ctypes=fill(Any,n), csizes=fill(0,n))
function char_move_left(buf::IOBuffer)
function char_move_right(buf::IOBuffer)
function char_move_word_left(buf::IOBuffer, is_delimiter::Function=is_non_word_char)
function char_move_word_right(buf::IOBuffer, is_delimiter::Function=is_non_word_char)
function char_uplo(uplo::Symbol)
function character_codes(directives::Core.SimpleVector)
function check(node::Node)
function check(x::Herd{N,T}) where {N,T}
function checkUserAccess(u::User)
function checkUserAccess(u::User)
function check_allowed_add_key(l::Parser, d, check_defined=true)::Err{Nothing}
function check_body!(x::Expr)
function check_broadcast_shape(::Tuple{}, Ashp::Tuple)
function check_broadcast_shape(shp, Ashp::Tuple)
function check_channel_state(c::Channel)
function check_code_trampoline(f, t, n::Int)
function check_count(count::Integer)
function check_cp(orig_path::AbstractString, copied_path::AbstractString, follow_symlinks::Bool)
function check_cp_main(orig::AbstractString, copied::AbstractString, follow_symlinks::Bool)
function check_defuse(x::Union{Int,SSAUse})
function check_dir(orig_path::AbstractString, copied_path::AbstractString, follow_symlinks::Bool)
function check_for_hint(s::MIState)
function check_inconsistentcy!(sv::PostOptAnalysisState, scanner::BBScanner)
function check_merge(i::Vector{<:Dict}, o)
function check_minmax_consistency(old::Array{T,1}, m::T, start::T, o::Base.Ordering) where T
function check_open(f::File)
function check_open(x::Union{LibuvStream, LibuvServer})
function check_pids_all(S::SharedArray)
function check_pointer_strides(A::AbstractArray)
function check_range_nothrow(ir::IRCode, s::Int, e::Int)
function check_readable(a::ReinterpretArray{T, N, S} where N) where {T,S}
function check_src_module_wrap(pkg::PkgId, srcpath::String)
function check_strides(A::AbstractArray)
function check_top_bit(::Type{To}, x) where {To}
function check_writable(a::ReinterpretArray{T, N, S} where N) where {T,S}
function checkbounds(::Type{Bool}, A::AbstractArray, I...)
function checkbounds(::Type{Bool}, A::AbstractArray, i)
function checkbounds(::Type{Bool}, A::AbstractArray, i::Union{CartesianIndex, AbstractArray{<:CartesianIndex}})
function checkbounds(::Type{Bool}, A::AbstractArray{<:Any,N}, I::AbstractArray{Bool,N}) where N
function checkbounds(::Type{Bool}, v::StepRange{<:BitInteger64, <:BitInteger64}, i::BitInteger64)
function checkbounds(A::AbstractArray, I...)
function checkbounds_indices(::Type{Bool}, ::Tuple{}, I::Tuple)
function checkbounds_indices(::Type{Bool}, IA::Tuple, I::Tuple)
function checkdims_perm(P::AbstractArray{TP,N}, B::AbstractArray{TB,N}, perm) where {TP,TB,N}
function checked_abs(x::SignedInt)
function checked_add(x::T, y::T) where T<:Integer
function checked_den(::Type{T}, num::T, den::T) where T<:Integer
function checked_dims(d::Int...)
function checked_length(r::AbstractUnitRange{T}) where T
function checked_length(r::AbstractUnitRange{T}) where T<:Rational
function checked_length(r::OrdinalRange{T}) where T
function checked_length(r::OrdinalRange{T}) where T<:bigints
function checked_mul(x::T, y::T) where T<:Integer
function checked_neg(x::BrokenSignedInt)
function checked_neg(x::T) where T<:BrokenUnsignedInt
function checked_neg(x::T) where T<:Integer
function checked_sub(x::T, y::T) where T<:Integer
function checked_trunc_sint(::Type{To}, x::From) where {To,From}
function checked_trunc_uint(::Type{To}, x::From) where {To,From}
function checkedstride(x::AbstractArray)
function checkindex(::Type{Bool}, inds::AbstractUnitRange, I::AbstractArray)
function checkindex(::Type{Bool}, inds::AbstractUnitRange, r::AbstractRange)
function checkindex(::Type{Bool}, inds::Tuple, I::AbstractArray{<:CartesianIndex})
function checkmode(mode::Integer)
function checkout_head(repo::GitRepo; options::CheckoutOptions = CheckoutOptions)
function cherrypick(repo::GitRepo, commit::GitCommit; options::CherrypickOptions = CherrypickOptions)
function chkargsok(ret::BlasInt)
function chkdiag(diag::AbstractChar)
function chkfinite(A::AbstractMatrix)
function chkfullrank(C::CholeskyPivoted)
function chklapackerror(ret::BlasInt)
function chknonsingular(ret::BlasInt)
function chkposdef(ret::BlasInt)
function chkside(side::AbstractChar)
function chktrans(trans::AbstractChar)
function chkuplo(uplo::AbstractChar)
function chkuplofinite(A::AbstractMatrix, uplo::AbstractChar)
function chmod(path::AbstractString, mode::Integer; recursive::Bool=false)
function cholesky!(A::AbstractMatrix, ::NoPivot = NoPivot; check::Bool = true)
function cholesky!(A::AbstractMatrix, ::RowMaximum; tol = 0.0, check::Bool = true)
function cholesky!(A::Diagonal, ::NoPivot = NoPivot; check::Bool = true)
function cholesky!(A::RealHermSymComplexHerm, ::NoPivot = NoPivot; check::Bool = true)
function cholesky(A::AbstractMatrix{Float16}, ::NoPivot=NoPivot; check::Bool = true)
function cholesky(A::AbstractMatrix{Float16}, ::RowMaximum; tol = 0.0, check::Bool = true)
function cholesky(S::RealHermSymComplexHerm{<:Real,<:SymTridiagonal}, ::NoPivot = NoPivot; check::Bool = true)
function cholesky(S::SymTridiagonal, ::NoPivot = NoPivot; check::Bool = true)
function cholesky(x::Number, uplo::Symbol)
function chomp(s::AbstractString)
function chomp(s::String)
function chop(s::AbstractString; head::Integer = 0, tail::Integer = 1)
function chopprefix(s::AbstractString, prefix::AbstractString)
function chopprefix(s::AbstractString, prefix::Regex)
function chopsuffix(s::AbstractString, suffix::AbstractString)
function chopsuffix(s::AbstractString, suffix::Regex)
function chown(path::AbstractString, owner::Integer, group::Integer=-1)
function chunkedcopyto!(dest::BitArray, bc::Broadcasted)
function circshift!(a::AbstractVector, shift::Integer)
function circshift!(dest::AbstractArray{T,N}, src, shiftamt::DimsInteger) where {T,N}
function circshift(a::AbstractArray, shiftamt)
function circshift(a::AbstractArray, shiftamt::Real)
function cis(A::Union{RealHermSymComplexHerm,SymTridiagonal{<:Real}})
function cis(theta::Real)
function cis(z::Complex)
function cis_fast(x::T) where {T<:FloatTypes}
function cispi(z::Complex)
function clamp!(x::AbstractArray, lo, hi)
function cld(x::T, y::T) where T<:Integer
function cld(x::T, y::T) where T<:Unsigned
function cleanup!(node::StackFrameTree)
function cleanup!(node::StackFrameTree)
function cleanup(r::GitRepo)
function clear_hint(s::ModeState)
function clear_input_area(terminal::AbstractTerminal, s::PromptState)
function clipboard(x::AbstractString)
function close(f::File)
function close(io::GenericIOBuffer{T}) where T
function close(s::BufferStream)
function close(s::IOStream)
function close(stream::Union{LibuvStream, LibuvServer})
function close(t::FDWatcher)
function close(t::Union{FileMonitor, FolderMonitor, PollingFileWatcher})
function close(t::Union{Timer, AsyncCondition})
function close(t::_FDWatcher, readable::Bool, writable::Bool)
function close_chnl_on_taskdone(t::Task, c::Channel)
function close_pipe_sync(handle::RawFD)
function close_pipe_sync(handle::WindowsRawSocket)
function closewrite(io::GenericIOBuffer)
function closewrite(s::LibuvStream)
function cmp(A::AbstractVector, B::AbstractVector)
function cmp(a::AbstractString, b::AbstractString)
function cmp(a::Array{UInt8,1}, b::Array{UInt8,1})
function cmp(a::Memory{UInt8}, b::Memory{UInt8})
function cmp(a::String, b::String)
function cmp(a::SubString{String}, b::SubString{String})
function cmp(x::BigFloat, y::BigInt)
function cmp(x::BigFloat, y::CdoubleMax)
function cmp(x::BigFloat, y::ClongMax)
function cmp(x::BigFloat, y::CulongMax)
function codeunit(s::SubString, i::Integer)
function cody_waite_2c_pio2(x::Float64, fn, n)
function cody_waite_ext_pio2(x::Float64, xhp)
function coerce(T::Type, x)
function collect(itr::Generator)
function collect_argtypes(interp::AbstractInterpreter, ea::Vector{Any}, vtypes::Union{VarTable,Nothing}, sv::AbsIntState)
function collect_const_args(argtypes::Vector{Any}, start::Int)
function collect_preferences(project_toml::String, uuid::Union{UUID,Nothing})
function collect_to!(dest::AbstractArray{T}, itr, offs, st) where T
function collect_to_with_first!(dest::AbstractArray, v1, itr, st)
function combine_eltypes(f, args::Tuple)
function combine_styles(bc::Broadcasted)
function commit(rb::GitRebase, sig::GitSignature)
function commit_line(s::MIState)
function committer(c::GitCommit)
function common_prefix(completions::Vector{String})
function compact!(code::IRCode, allow_cfg_transforms::Bool=false)
function compact(io::GenericIOBuffer)
function compare_default(a::String, b::String, a_requested::Bool, b_requested::Bool)
function compare_inconsistent(x::T) where T
function compare_version_cap(a::String, b::String, a_requested::Bool, b_requested::Bool)
function compatible_vatuple(a::DataType, b::DataType)
function compile(pattern::AbstractString, options::Integer)
function compile(regex::Regex)
function compilecache(pkg::PkgId, internal_stderr::IO = stderr, internal_stdout::IO = stdout)
function compilecache_dir(pkg::PkgId)
function compiled_conv(::Type{T}, x) where T
function compilerbarrier_tfunc(ð•ƒ::AbstractLattice, setting, val)
function complete!(tpdum::TwoPhaseDefUseMap)
function complete(compact::IncrementalCompact)
function complete_any_methods(ex_org::Expr, callee_module::Module, context_module::Module, moreargs::Bool, shift::Bool)
function complete_expanduser(path::AbstractString, r)
function complete_from_list(T::Type, list::Vector{String}, s::Union{String,SubString{String}})
function complete_line(c::LatexCompletions, s)
function complete_line(c::REPLCompletionProvider, s::PromptState, mod::Module)
function complete_line(c::ShellCompletionProvider, s::PromptState)
function complete_line(s::MIState)
function complete_line(s::PromptState, repeats::Int, mod::Module)
function complete_line(s::SearchState, repeats, mod::Module)
function complete_methods(ex_org::Expr, context_module::Module=Main, shift::Bool=false)
function complete_methods_args(ex::Expr, context_module::Module, default_any::Bool, allow_broadcasting::Bool)
function completions(string::String, pos::Int, context_module::Module=Main, shift::Bool=true)
function complex(A::AbstractArray{T}) where T
function compute_basic_blocks(stmts::Vector{Any})
function compute_domtree_nodes!(domtree::GenericDomTree{IsPostDom}) where {IsPostDom}
function compute_frameinfo(ir::IRCode)
function compute_inlining_depth(linetable::Vector, iline::Int32)
function compute_ir_line_annotations(code::IRCode)
function compute_ir_rettype(ir::IRCode)
function compute_itspace(A, ::Val{dims}) where {dims}
function compute_linindex(f, s, IP::Tuple, I::Tuple{Any, Vararg{Any}})
function compute_linindex(parent, I::NTuple{N,Any}) where N
function compute_live_ins(cfg::CFG, defs::Vector{Int}, uses::Vector{Int})
function compute_live_ins(cfg::CFG, du::SSADefUse)
function compute_loc_stack(linetable::Vector, line::Int32)
function compute_oc_signature(ir::IRCode, nargs::Int, isva::Bool)
function compute_preds(bbs::Vector{BasicBlock}, result_bbs::Vector{Int}, bb_rename_pred::Vector{Int}, i::Int)
function compute_succs(merged_succ::Vector{Int}, bbs::Vector{BasicBlock}, result_bbs::Vector{Int}, bb_rename_succ::Vector{Int}, i::Int)
function compute_trycatch(code::Vector{Any}, ip::BitSet)
function compute_value_for_block(ir::IRCode, domtree::DomTree, allblocks::BitSet, du::SSADefUse, phinodes::IdDict{Int, SSAValue}, fidx::Int, curblock::Int)
function cond(A::AbstractMatrix, p::Real=2)
function cond(J::UniformScaling{T}) where T
function conditional_successors_may_throw(lazypostdomtree::LazyPostDomtree, ir::IRCode, bb::Int)
function conditionally_call_ambig(b::Bool, a)
function condskeel(A::AbstractMatrix, x::AbstractVector, p::Real=Inf)
function config(parsers::Function...)
function connect!(sock::PipeEndpoint, path::AbstractString)
function connect!(sock::TCPSocket, host::AbstractString, port::Integer)
function connect!(sock::TCPSocket, host::Union{IPv4, IPv6}, port::Integer)
function connect(sock::LibuvStream, args...)
function connected(rmt::GitRemote)
function const_prop_argument_heuristic(interp::AbstractInterpreter, arginfo::ArgInfo, sv::AbsIntState)
function const_prop_enabled(interp::AbstractInterpreter, sv::AbsIntState, match::MethodMatch)
function const_prop_entry_heuristic(interp::AbstractInterpreter, result::MethodCallResult, si::StmtInfo, sv::AbsIntState)
function constargs(A, B::Const)
function construct_domtree(blocks::Vector{BasicBlock})
function construct_postdomtree(blocks::Vector{BasicBlock})
function consumed!(buffer::Buffer, n::Integer)
function content(blob::GitBlob)
function contextual_prompt(repl::LineEditREPL, prompt::Union{String,Function})
function contractuser(path::AbstractString)
function convert(::Type{NTuple{2, UInt64}}, uuid::UUID)
function convert(::Type{NTuple{4, UInt32}}, uuid::UUID)
function convert(::Type{NT}, nt::NamedTuple{names}) where {names, NT<:NamedTuple{names}}
function convert(::Type{NamedTuple{names,T}}, nt::NamedTuple{names}) where {names,T<:Tuple}
function convert(::Type{Pair{A,B}}, x::Pair) where {A,B}
function convert(::Type{RoundingMode}, r::MPFRRoundingMode)
function convert(::Type{T}, A::AbstractMatrix) where T<:Diagonal
function convert(::Type{T}, x::AbstractDict) where T<:AbstractDict
function convert(::Type{T}, x::NTuple{N,Any}) where {N, T<:Tuple}
function convert_cache_mode(cache_mode::Symbol)
function convert_to_ircode(ci::CodeInfo, sv::OptimizationState)
function copy!(dest::BitSet, src::BitSet)
function copy!(dest::SecretBuffer, src::SecretBuffer)
function copy!(dst::AbstractArray, src::AbstractArray)
function copy!(dst::AbstractDict, src::AbstractDict)
function copy!(dst::AbstractSet, src::AbstractSet)
function copy!(dst::AbstractVector, src::AbstractVector)
function copy!(dst::DFSTree, src::DFSTree)
function copy!(dst::MersenneTwister, src::MersenneTwister)
function copy(a::AbstractArray)
function copy(b::GenericIOBuffer)
function copy(bc::Broadcasted)
function copy(bc::Broadcasted{Style{Tuple}})
function copy(c::CodeInfo)
function copy(is::InstructionStream)
function copy_chunks!(dest::Vector{UInt64}, pos_d::Int, src::Vector{UInt64}, pos_s::Int, numbits::Int)
function copy_chunks_rtol!(chunks::Vector{UInt64}, pos_d::Int, pos_s::Int, numbits::Int)
function copy_similar(A::AdjointAbsMat, ::Type{T}) where {T}
function copy_similar(A::TransposeAbsMat, ::Type{T}) where {T}
function copy_to_array(A::AbstractArray)
function copy_to_bitarray_chunks!(Bc::Vector{UInt64}, pos_d::Int, C::Array{Bool}, pos_s::Int, numbits::Int)
function copy_to_bitarray_chunks!(Bc::Vector{UInt64}, pos_d::Int, C::StridedArray, pos_s::Int, numbits::Int)
function copy_to_bitarray_chunks!(Bc::Vector{UInt64}, pos_d::Int, C::StridedArray{<:Real}, pos_s::Int, numbits::Int)
function copy_transpose!(B::AbstractMatrix, ir_dest::AbstractUnitRange{Int}, jr_dest::AbstractUnitRange{Int}, tM::AbstractChar, M::AbstractVecOrMat, ir_src::AbstractUnitRange{Int}, jr_src::AbstractUnitRange{Int})
function copybuf!(dst::IOBuffer, src::IOBuffer)
function copyline(out::GenericIOBuffer, s::IO; keep::Bool=false)
function copyline(out::IO, s::IO; keep::Bool=false)
function copymutable(a::AbstractArray)
function copysign(x::BigFloat, y::BigFloat)
function copyto!(A::AbstractMatrix, J::UniformScaling)
function copyto!(A::Diagonal, J::UniformScaling)
function copyto!(A::T, B::T) where {T<:Union{LowerTriangular,UnitLowerTriangular}}
function copyto!(A::T, B::T) where {T<:Union{UpperTriangular,UnitUpperTriangular}}
function copyto!(A::Tridiagonal, J::UniformScaling)
function copyto!(A::Union{Bidiagonal, SymTridiagonal}, J::UniformScaling)
function copyto!(B::AbstractVecOrMat, ir_dest::AbstractUnitRange{Int}, jr_dest::AbstractUnitRange{Int}, tM::AbstractChar, M::AbstractVecOrMat, ir_src::AbstractUnitRange{Int}, jr_src::AbstractUnitRange{Int})
function copyto!(S::SharedArray, R::SharedArray)
function copyto!(dest::AbstractArray, bc::Broadcasted{<:AbstractArrayStyle{0}})
function copyto!(dest::AbstractArray, bc::Broadcasted{Nothing})
function copyto!(dest::AbstractArray, dstart::Integer, src)
function copyto!(dest::AbstractArray, dstart::Integer, src, sstart::Integer)
function copyto!(dest::AbstractArray, dstart::Integer, src, sstart::Integer, n::Integer)
function copyto!(dest::AbstractArray, dstart::Integer, src::AbstractArray)
function copyto!(dest::AbstractArray, dstart::Integer, src::AbstractArray, sstart::Integer)
function copyto!(dest::AbstractArray, src)
function copyto!(dest::AbstractArray, src::AbstractArray)
function copyto!(dest::AbstractMatrix, src::AbstractQ)
function copyto!(dest::Bidiagonal, bc::Broadcasted{<:StructuredMatrixStyle})
function copyto!(dest::BitArray, bc::Broadcasted{Nothing})
function copyto!(dest::BitArray, src::Array)
function copyto!(dest::BitArray, src::BitArray)
function copyto!(dest::BitVector, bc::Broadcasted{Nothing})
function copyto!(dest::Diagonal, bc::Broadcasted{<:StructuredMatrixStyle})
function copyto!(dest::Hermitian, src::Hermitian)
function copyto!(dest::LowerTriangular, bc::Broadcasted{<:StructuredMatrixStyle})
function copyto!(dest::Memory, doffs::Integer, src::Memory, soffs::Integer, n::Integer)
function copyto!(dest::PermutedDimsArray{T,2,perm}, src::AbstractQ) where {T,perm}
function copyto!(dest::SymTridiagonal, bc::Broadcasted{<:StructuredMatrixStyle})
function copyto!(dest::Symmetric, src::Symmetric)
function copyto!(dest::Tridiagonal, bc::Broadcasted{<:StructuredMatrixStyle})
function copyto!(dest::UpperTriangular, bc::Broadcasted{<:StructuredMatrixStyle})
function copyto!(deststyle::IndexStyle, dest::AbstractArray, srcstyle::IndexStyle, src::AbstractArray)
function copyto_nonleaf!(dest, bc::Broadcasted, iter, state, count)
function copyto_unaliased!(deststyle::IndexStyle, dest::AbstractArray, srcstyle::IndexStyle, src::AbstractArray)
function copytri!(A::AbstractMatrix, uplo::AbstractChar, conjugate::Bool=false, diag::Bool=false)
function copyuntil(out::IO, io::GenericIOBuffer, delim::UInt8; keep::Bool=false)
function copyuntil(out::IO, io::IO, target::AbstractString; keep::Bool=false)
function copyuntil(out::IO, s::IO, delim::AbstractChar; keep::Bool=false)
function copyuntil(out::IOBuffer, s::IOStream, delim::UInt8; keep::Bool=false)
function copyuntil(out::IOStream, s::IOStream, delim::UInt8; keep::Bool=false)
function correct_rounding_requires_increment(x, rounding_mode, sign_bit::Bool)
function cos(A::AbstractMatrix{<:Complex})
function cos(A::AbstractMatrix{<:Real})
function cos(x::T) where T<:Union{Float32, Float64}
function cos(z::Complex{T}) where T
function cos_kernel(y::DoubleFloat32)
function cos_kernel(y::DoubleFloat64)
function cos_kernel(y::Float64)
function cosd(x::Real)
function cosh(A::AbstractMatrix)
function cosh(x::T) where T<:Union{Float32,Float64}
function cosh(z::Complex)
function cosh_kernel(x2::Float32)
function cosh_kernel(x2::Float64)
function cospi(x::T) where T<:IEEEFloat
function cospi(z::Complex{T}) where T
function cospi_kernel(x::Float16)
function cospi_kernel(x::Float32)
function cospi_kernel(x::Float64)
function cospi_kernel_wide(x::Float16)
function cospi_kernel_wide(x::Float32)
function cospi_kernel_wide(x::Float64)
function count!(tpdum::TwoPhaseDefUseMap, arg::SSAValue)
function count(diff::GitDiff)
function count(idx::GitIndex)
function count(rb::GitRebase)
function count(t::Union{AbstractChar,AbstractString,AbstractPattern}, s::AbstractString; overlap::Bool=false)
function count(tree::GitTree)
function count_expr_push(ex::Expr, head::Symbol, counter)
function count_int(val::Int, arr::Vector{Int})
function count_ones(x::BigInt)
function count_zeros(x::BigInt)
function counthunks(blame::GitBlame)
function countlines(io::IO; eol::AbstractChar='\n')
function coverage_enabled(m::Module)
function cp_and_test(src::AbstractString, dst::AbstractString, follow_symlinks::Bool)
function cpu_summary(io::IO=stdout, cpu::AbstractVector{CPUinfo} = cpu_info)
function crc32c_sw(io::IO, nb::Integer, crc::UInt32=0x00000000)
function crc32c_sw(s::Union{String, SubString{String}}, crc::UInt32=0x00000000)
function create_serialization_stream(f::Function)
function create_socket(addr::IPAddr, port)
function create_test_overrides_toml(temp_dir::String)
function credential_helpers(cfg::GitConfig, cred::GitCredential)
function credential_identifier(scheme::AbstractString, host::AbstractString)
function credential_identifier(url::AbstractString)
function cross(a::AbstractVector, b::AbstractVector)
function cumprod(A::AbstractArray; dims::Integer)
function cumsum!(out::AbstractArray, v::AbstractVector; dims::Integer=1)
function cumsum(A::AbstractArray{T}; dims::Integer) where T
function cumsum_ssamap!(ssachangemap::Vector{Int})
function cumulative_compile_timing(b::Bool)
function current(rb::GitRebase)
function current_exceptions(task::Task=current_task; backtrace::Bool=true)
function current_project(dir::AbstractString)
function current_word_with_dots(buf::IOBuffer)
function custom_lookup(mi::MethodInstance, min_world::UInt, max_world::UInt)
function cwstring(s::AbstractString)
function datatype_alignment(dt::DataType)
function datatype_arrayelem(dt::DataType)
function datatype_fieldcount(t::DataType)
function datatype_fielddesc_type(dt::DataType)
function datatype_haspadding(dt::DataType)
function datatype_layoutsize(dt::DataType)
function datatype_min_ninitialized(t::DataType)
function datatype_nfields(dt::DataType)
function datatype_pointerfree(dt::DataType)
function day_in(obj::ObjMember)
function dayabbr(dt::TimeType;locale::AbstractString)
function dayofquarter(dt::TimeType)
function dayofweekofmonth(dt::TimeType)
function daysofweekinmonth(dt::TimeType)
function deactivate(p::TextInterface, s::ModeState, termbuf::AbstractTerminal, term::TextTerminal)
function dec(x::Unsigned, pad::Int, neg::Bool)
function decimallength(v::UInt16)
function decimallength(v::UInt32)
function declared_ceil(x::Float64)
function declared_floor(x::Float64)
function declared_floor(x::Float64)
function decode(raw_results::RawResults)::AllocResults
function decode_alloc(cache::BacktraceCache, raw_alloc::RawAlloc)::Alloc
function decode_effects(e::UInt32)
function decode_effects_override(e::UInt8)
function decompose(x::BigFloat)::Tuple{BigInt, Int, Int}
function decompose(x::Float16)::NTuple{3,Int}
function decompose(x::Float32)::NTuple{3,Int}
function decompose(x::Float64)::Tuple{Int64, Int, Int}
function deepcopy_internal(S::SharedArray, stackdict::IdDict)
function deepcopy_internal(x::AbstractLock, stackdict::IdDict)
function deepcopy_internal(x::GenericCondition, stackdict::IdDict)
function deepcopy_internal(x::GenericMemoryRef, stackdict::IdDict)
function deepcopy_internal(x::Memory, stackdict::IdDict)
function deepcopy_internal(x::SimpleVector, stackdict::IdDict)
function deepcopy_internal(x::String, stackdict::IdDict)
function deepcopy_internal(x::Union{Dict,IdDict}, stackdict::IdDict)
function default_branch(rmt::GitRemote)
function default_config(code::IRCode; verbose_linetable=false)
function default_logcolor(level::LogLevel)
function default_metafmt(level::LogLevel, _module, group, id, file, line)
function default_signature(repo::GitRepo)
function default_username(cfg::GitConfig, cred::GitCredential)
function define_editor(fn::Function, pattern; wait::Bool=false)
function deg2rad_ext(x::Float64)
function delete!(h::Dict, key)
function delete!(wkh::WeakKeyDict, key)
function delete(dict::PersistentDict{K}, key::K) where K
function delete_branch(branch::GitReference)
function delete_method(m::Method)
function deleteat!(B::BitVector, i::Integer)
function deleteat!(B::BitVector, inds)
function deleteat!(B::BitVector, inds::AbstractVector{Bool})
function deleteat!(B::BitVector, r::AbstractUnitRange{Int})
function deleteat!(a::Vector, i::Integer)
function deleteat!(a::Vector, inds::AbstractVector{Bool})
function deleteat!(a::Vector, r::AbstractUnitRange{<:Integer})
function deletions(diff_stat::GitDiffStats)
function demangle_function_name(name::AbstractString)
function depth(node::Node, d)
function depth(t::Core.Compiler.Timings.Timing)
function depwarn(msg, funcsym; force::Bool=false)
function deserialize(s::AbstractSerializer)
function deserialize(s::AbstractSerializer, ::Type{Base.StackTraces.StackFrame})
function deserialize(s::AbstractSerializer, ::Type{CodeInfo})
function deserialize(s::AbstractSerializer, ::Type{Core.LineInfoNode})
function deserialize(s::AbstractSerializer, ::Type{Core.MethodInstance})
function deserialize(s::AbstractSerializer, ::Type{Core.TypeName})
function deserialize(s::AbstractSerializer, ::Type{Method})
function deserialize(s::AbstractSerializer, ::Type{PhiNode})
function deserialize(s::AbstractSerializer, ::Type{Task})
function deserialize(s::AbstractSerializer, ::Type{T}) where T<:Base.AbstractLock
function deserialize(s::AbstractSerializer, ::Type{T}) where T<:Base.GenericCondition
function deserialize(s::AbstractSerializer, ::Type{UnionAll})
function deserialize(s::AbstractSerializer, T::Type{Dict{K,V}}) where {K,V}
function deserialize(s::AbstractSerializer, X::Type{Core.AddrSpace{M}} where M)
function deserialize(s::AbstractSerializer, X::Type{MemoryRef{T}} where T)
function deserialize(s::AbstractSerializer, X::Type{Memory{T}} where T)
function deserialize(s::AbstractSerializer, t::DataType)
function deserialize(s::AbstractSerializer, t::Type{<:SharedArray})
function deserialize(s::AbstractSerializer, t::Type{Regex})
function deserialize_array(s::AbstractSerializer)
function deserialize_datatype(s::AbstractSerializer, full::Bool)
function deserialize_dict(s::AbstractSerializer, T::Type{<:AbstractDict})
function deserialize_expr(s::AbstractSerializer, len)
function deserialize_fillarray!(A::Union{Array{T},Memory{T}}, s::AbstractSerializer) where {T}
function deserialize_module(s::AbstractSerializer)
function deserialize_string(s::AbstractSerializer, len::Int)
function deserialize_svec(s::AbstractSerializer)
function deserialize_symbol(s::AbstractSerializer, len::Int)
function deserialize_typename(s::AbstractSerializer, number)
function destroy(ref::REPLBackendRef, state::Task)
function det(A::AbstractMatrix{T}) where {T}
function det(C::Cholesky)
function det(C::CholeskyPivoted)
function det(F::Factorization)
function det(F::LU{T}) where T
function det(F::UpperHessenberg; shift::Number=false)
function det(J::UniformScaling{T}) where T
function det_usmani(a::V, b::V, c::V, shift::Number=0) where {T,V<:AbstractVector{T}}
function detect_args_kwargs(funargs::Vector{Any}, context_module::Module, default_any::Bool, broadcasting::Bool)
function detect_libstdcxx_version(max_minor_version::Int=30)
function diag(B::BitMatrix)
function diag(D::Diagonal{T}, k::Integer=0) where T
function diag(M::Bidiagonal{T}, n::Integer=0) where T
function diag(M::SymTridiagonal, n::Integer=0)
function diag(M::SymTridiagonal{T}, n::Integer=0) where T<:Number
function diag(M::Tridiagonal{T}, n::Integer=0) where T
function diagind(A::AbstractMatrix, k::Integer=0)
function diagm_container(size, kv::Pair{<:Integer,<:AbstractVector}...)
function diagm_size(size::Nothing, kv::Pair{<:Integer,<:AbstractVector}...)
function diagm_size(size::Tuple{Int,Int}, kv::Pair{<:Integer,<:AbstractVector}...)
function dict_identifier_key(str::String, tag::Symbol, context_module::Module=Main)
function dict_with_eltype(DT_apply::F, kv::Generator, t) where F
function diff(a::AbstractArray{T,N}; dims::Integer) where {T,N}
function diff(r::AbstractRange{T}; dims::Integer=1) where {T}
function diff_tree(repo::GitRepo, oldtree::GitTree, newtree::GitTree)
function diff_tree(repo::GitRepo, tree::GitTree, pathspecs::AbstractString; cached::Bool=false)
function digits!(a::AbstractVector{T}, n::BigInt; base::Integer = 10) where {T<:Integer}
function digits!(a::AbstractVector{T}, n::Integer; base::Integer = 10) where T<:Integer
function digits(T::Type{<:Integer}, n::Integer; base::Integer = 10, pad::Integer = 1)
function disable_logging(level::LogLevel)
function disable_sigint(f::Function)
function disconnect(rmt::GitRemote)
function diskstat(path::AbstractString=pwd)
function display(d::REPLDisplay, mime::MIME, x)
function display_error(io::IO, er, bt)
function display_error(io::IO, stack::ExceptionStack)
function displayable(m::MIME)
function displaysize(io::TTY)
function div!(z::Rational{BigInt}, x::Rational{BigInt}, y::Rational{BigInt})
function div(a::T, b::SignedMultiplicativeInverse{T}) where T
function div(a::T, b::UnsignedMultiplicativeInverse{T}) where T
function div(c::CdoubleMax, x::BigFloat)
function div(c::ClongMax, x::BigFloat)
function div(c::CulongMax, x::BigFloat)
function div(x::BigFloat, c::BigInt)
function div(x::BigFloat, c::CdoubleMax)
function div(x::BigFloat, c::ClongMax)
function div(x::BigFloat, c::CulongMax)
function div(x::BigFloat, y::BigFloat)
function div(x::Bool, y::Bool, rnd::Union{typeof(RoundNearest),
function div(x::Int128, y::Int128)
function div(x::Integer, y::Integer, ::typeof(RoundFromZero))
function div(x::Integer, y::Integer, rnd::Union{typeof(RoundNearest),
function div(x::Integer, y::Rational, r::RoundingMode)
function div(x::Rational, y::Integer, r::RoundingMode)
function div(x::Rational, y::Rational, r::RoundingMode)
function div(x::Real, y::Real, r::RoundingMode)
function div(x::Signed, y::Unsigned, ::typeof(RoundDown))
function div(x::Signed, y::Unsigned, ::typeof(RoundUp))
function div(x::T, y::T, ::typeof(RoundDown)) where T<:Integer
function div(x::T, y::T, ::typeof(RoundUp)) where T<:Integer
function div(x::T, y::T, ::typeof(RoundUp)) where T<:Unsigned
function div(x::Unsigned, y::Signed, ::typeof(RoundDown))
function div(x::Unsigned, y::Signed, ::typeof(RoundUp))
function div12(x::T, y::T) where {T<:AbstractFloat}
function divgcd(x::Integer,y::Integer)
function divrem(a, b, r::RoundingMode)
function divrem(a::Integer, b::Integer, r::Union{typeof(RoundUp),
function divrem(a::T, b::MultiplicativeInverse{T}) where T
function divrem(x, y, ::typeof(RoundFromZero))
function divrem(x::BitSigned, y::Unsigned)
function divrem(x::Integer, y::Integer, rnd:: typeof(RoundNearestTiesAway))
function divrem(x::Integer, y::Integer, rnd::typeof(RoundNearest))
function divrem(x::Integer, y::Integer, rnd::typeof(RoundNearestTiesUp))
function divrem(x::UInt128, y::UInt128)
function divrem(x::Unsigned, y::BitSigned)
function dl_phdr_info_callback(di::dl_phdr_info, size::Csize_t, dynamic_libraries::Array{String,1})
function dlclose(p::Nothing)
function dlclose(p::Ptr)
function dlopen(f::Function, name, args...; kwargs...)
function dlopen(ll::LazyLibrary, flags::Integer = ll.flags; kwargs...)
function dlopen(s::AbstractString, flags::Integer = default_rtld_flags; throw_error::Bool = true)
function dlpath(handle::Ptr{Cvoid})
function dlpath(libname::Union{AbstractString, Symbol})
function dlsym(hnd::Ptr, s::Union{Symbol,AbstractString}; throw_error::Bool = true)
function do_broken_test(result::ExecutionResult, orig_expr)
function do_download(url::AbstractString, path::Union{AbstractString, Nothing})
function do_test(result::ExecutionResult, orig_expr)
function do_test_throws(result::ExecutionResult, orig_expr, extype)
function do_threadcall(fun_ptr::Ptr{Cvoid}, cfptr::Ptr{Cvoid}, rettype::Type, argtypes::Vector, argvals::Vector)
function doc!(source::LineNumberNode, mod::Module, str, ex)
function doc(binding::Binding, sig::Type = Union{})
function doc_completions(name, mod::Module=Main)
function doc_str(md, source::LineNumberNode, mod::Module)
function docexpr(source::LineNumberNode, mod::Module, s, flavor = :julia)
function docm(source::LineNumberNode, mod::Module, ex)
function docm(source::LineNumberNode, mod::Module, meta, ex, define::Bool = true)
function docm(source::LineNumberNode, mod::Module, str, x)
function docsearch(haystack::Array, needle)
function docsearch(haystack::DocStr, needle)
function docsearch(haystack::MultiDoc, needle)
function docstr(binding::Binding, typesig = Union{})
function doiterate(itr, valstate::Union{Nothing, Tuple{Any, Any}})
function dominated(domtree::DomTree, root::BBNumber)
function dominates_ssa(compact::IncrementalCompact, domtree::DomTree, x::AnySSAValue, y::AnySSAValue)
function domsort_ssa!(ir::IRCode, domtree::DomTree)
function dot(D::Diagonal, B::AbstractMatrix)
function dot(x::AbstractArray, y::AbstractArray)
function dot(x::AbstractVector, A::AbstractMatrix, y::AbstractVector)
function dot(x::AbstractVector, A::LowerTriangular, y::AbstractVector)
function dot(x::AbstractVector, A::RealHermSymComplexHerm, y::AbstractVector)
function dot(x::AbstractVector, A::Tridiagonal, y::AbstractVector)
function dot(x::AbstractVector, A::UnitLowerTriangular, y::AbstractVector)
function dot(x::AbstractVector, A::UnitUpperTriangular, y::AbstractVector)
function dot(x::AbstractVector, A::UpperTriangular, y::AbstractVector)
function dot(x::AbstractVector, B::Bidiagonal, y::AbstractVector)
function dot(x::AbstractVector, H::UpperHessenberg, y::AbstractVector)
function dot(x::AbstractVector, S::SymTridiagonal, y::AbstractVector)
function dot(x::Adjoint{<:Union{Real,Complex}}, y::Adjoint{<:Union{Real,Complex}})
function dot(x::BitVector, y::BitVector)
function dot(x::Vector{T}, rx::AbstractRange{TI}, y::Vector{T}, ry::AbstractRange{TI}) where {T<:BlasComplex,TI<:Integer}
function dot(x::Vector{T}, rx::AbstractRange{TI}, y::Vector{T}, ry::AbstractRange{TI}) where {T<:BlasReal,TI<:Integer}
function doubly_declared2_trunc(x::Float64)
function doubly_declared2_trunc(x::Float64)
function doubly_declared_floor(x::Float64)
function doubly_declared_floor(x::Float64)
function download_from_cache(desired_url::AbstractString)
function dsfmt_fill_array_close1_open2!(s::DSFMT_state, A::Ptr{Float64}, n::Int)
function dsfmt_fill_array_close_open!(s::DSFMT_state, A::Ptr{Float64}, n::Int)
function dsfmt_gv_init_by_array(seed::Vector{UInt32})
function dsfmt_init_by_array(s::DSFMT_state, seed::StridedVector{UInt32})
function dsfmt_init_gen_rand(s::DSFMT_state, seed::UInt32)
function dsfmt_jump(s::DSFMT_state, jp::GF2X)
function dsfmt_jump_add!(dest::AbstractVector{UInt64}, src::Vector{UInt64})
function dsfmt_jump_next_state!(mts::Vector{UInt64})
function dsymutil( adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
function dummy_uuid(project_file::String)
function dump(io::IOContext, x::Array, n::Int, indent)
function dump(io::IOContext, x::DataType, n::Int, indent)
function dump(io::IOContext, x::SimpleVector, n::Int, indent)
function dump_elts(io::IOContext, x::Array, n::Int, indent, i0, i1)
function dup(src::WindowsRawSocket)
function dup(src::WindowsRawSocket, target::RawFD)
function eachindex(::IndexCartesian, A::AbstractArray, B::AbstractArray...)
function eachindex(::IndexLinear, A::AbstractArray, B::AbstractArray...)
function eachindex(A::AbstractArray, B::AbstractArray)
function eachindex(A::AbstractArray, B::AbstractArray...)
function eachindex(style::IndexSCartesian2{K}, A::AbstractArray, B::AbstractArray...) where {K}
function eachline(cmd::AbstractCmd; keep::Bool=false)
function eachline(filename::AbstractString; keep::Bool=false)
function eachline(stream::IO=stdin; keep::Bool=false)
function eat_char(l::Parser)::Char
function eatindent(io::IO, n = 3)
function edit(path::AbstractString, line::Integer=0, column::Integer=0)
function edit_abort(s::MIState, confirm::Bool=options(s).confirm_exit; key)
function edit_backspace(buf::IOBuffer, align::Bool=false, adjust::Bool=false)
function edit_backspace(s::PromptState, align::Bool=options(s).backspace_align,
function edit_clear(s::MIState)
function edit_copy_region(s::MIState)
function edit_delete(buf::IOBuffer)
function edit_delete(s::MIState)
function edit_delete_next_word(buf::IOBuffer)
function edit_delete_next_word(s::MIState)
function edit_delete_prev_word(buf::IOBuffer)
function edit_delete_prev_word(s::MIState)
function edit_exchange_point_and_mark(buf::IOBuffer)
function edit_exchange_point_and_mark(s::MIState)
function edit_indent(buf::IOBuffer, num::Int, multiline::Bool)
function edit_indent(s::MIState, num::Int)
function edit_insert(buf::IOBuffer, c::StringLike)
function edit_insert(s::PromptState, c::StringLike)
function edit_insert_newline(s::PromptState, align::Int = 0 - options(s).auto_indent)
function edit_insert_tab(buf::IOBuffer, jump_spaces::Bool=false, delete_trailing::Bool=jump_spaces)
function edit_kill_line(s::MIState, backwards::Bool=false)
function edit_kill_region(s::MIState)
function edit_lower_case(s::BufferLike)
function edit_move_down(buf::IOBuffer)
function edit_move_down(s::MIState)
function edit_move_left(buf::IOBuffer)
function edit_move_right(buf::IOBuffer)
function edit_move_up(buf::IOBuffer)
function edit_move_up(s::MIState)
function edit_move_word_left(s::PromptState)
function edit_move_word_right(s::PromptState)
function edit_redo!(s::MIState)
function edit_redo!(s::PromptState)
function edit_replace_word_right(buf::IOBuffer, replace::Function)
function edit_replace_word_right(s::Union{MIState,ModeState}, replace::Function)
function edit_shift_move(s::MIState, move_function::Function)
function edit_splice!(s::BufferLike, r::Region=region(s), ins::String; rigid_mark::Bool=true)
function edit_tab(s::MIState, jump_spaces::Bool=false, delete_trailing::Bool=jump_spaces)
function edit_title_case(s::BufferLike)
function edit_transpose_chars(buf::IOBuffer)
function edit_transpose_chars(s::MIState)
function edit_transpose_lines_down!(buf::IOBuffer, reg::Region)
function edit_transpose_lines_down!(s::MIState)
function edit_transpose_lines_up!(buf::IOBuffer, reg::Region)
function edit_transpose_lines_up!(s::MIState)
function edit_transpose_words(buf::IOBuffer, mode::Symbol=:emacs)
function edit_transpose_words(s::MIState)
function edit_undo!(s::MIState)
function edit_undo!(s::PromptState)
function edit_upper_case(s::BufferLike)
function edit_werase(buf::IOBuffer)
function edit_werase(s::MIState)
function edit_yank(s::MIState)
function edit_yank_pop(s::MIState, require_previous_yank::Bool=true)
function effectbits_color(effects::Effects, name::Symbol)
function effectbits_letter(effects::Effects, name::Symbol, suffix::Char)
function egal_tfunc(::JLTypeLattice, x, y)
function egal_tfunc(ð•ƒ::ConditionalsLattice, x, y)
function egal_tfunc(ð•ƒ::ConstsLattice, x, y)
function egal_tfunc(ð•ƒ::MustAliasesLattice, x, y)
function eigen!(A::AbstractMatrix, C::Cholesky; sortby::Union{Function,Nothing}=nothing)
function eigen!(A::HermOrSym{T,S}, B::HermOrSym{T,S}; sortby::Union{Function,Nothing}=nothing) where {T<:BlasReal,S<:StridedMatrix}
function eigen!(A::Hermitian{T,S}, B::Hermitian{T,S}; sortby::Union{Function,Nothing}=nothing) where {T<:BlasComplex,S<:StridedMatrix}
function eigen!(A::StridedMatrix{T}, B::StridedMatrix{T}; sortby::Union{Function,Nothing}=eigsortby) where T<:BlasComplex
function eigen!(A::StridedMatrix{T}, B::StridedMatrix{T}; sortby::Union{Function,Nothing}=eigsortby) where T<:BlasReal
function eigen!(A::StridedMatrix{T}; permute::Bool=true, scale::Bool=true, sortby::Union{Function,Nothing}=eigsortby) where T<:BlasComplex
function eigen!(A::StridedMatrix{T}; permute::Bool=true, scale::Bool=true, sortby::Union{Function,Nothing}=eigsortby) where T<:BlasReal
function eigen(A::AbstractMatrix, C::Cholesky; sortby::Union{Function,Nothing}=nothing)
function eigen(A::AbstractMatrix, D::Diagonal; sortby::Union{Function,Nothing}=nothing)
function eigen(A::AbstractMatrix{TA}, B::AbstractMatrix{TB}; kws...) where {TA,TB}
function eigen(A::AbstractMatrix{T}; permute::Bool=true, scale::Bool=true, sortby::Union{Function,Nothing}=eigsortby) where T
function eigen(A::AbstractMatrix{T}; permute::Bool=true, scale::Bool=true, sortby::Union{Function,Nothing}=eigsortby) where {T <: Union{Float16,Complex{Float16}}}
function eigen(A::HermOrSym{TA}, B::HermOrSym{TB}; kws...) where {TA,TB}
function eigen(A::RealHermSymComplexHerm, irange::UnitRange)
function eigen(A::RealHermSymComplexHerm, vl::Real, vh::Real)
function eigen(A::RealHermSymComplexHerm; sortby::Union{Function,Nothing}=nothing)
function eigen(D::Diagonal; permute::Bool=true, scale::Bool=true, sortby::Union{Function,Nothing}=nothing)
function eigen(D::Diagonal{<:AbstractMatrix}; permute::Bool=true, scale::Bool=true, sortby::Union{Function,Nothing}=nothing)
function eigen(Da::Diagonal, Db::Diagonal; sortby::Union{Function,Nothing}=nothing)
function eigmax(A::Union{Number, AbstractMatrix}; permute::Bool=true, scale::Bool=true)
function eigvals!(A::AbstractMatrix{T}, C::Cholesky{T, <:AbstractMatrix}; sortby::Union{Function,Nothing}=nothing) where {T<:Number}
function eigvals!(A::HermOrSym{T,S}, B::HermOrSym{T,S}; sortby::Union{Function,Nothing}=nothing) where {T<:BlasReal,S<:StridedMatrix}
function eigvals!(A::Hermitian{T,S}, B::Hermitian{T,S}; sortby::Union{Function,Nothing}=nothing) where {T<:BlasComplex,S<:StridedMatrix}
function eigvals!(A::RealHermSymComplexHerm{<:BlasReal,<:StridedMatrix}; sortby::Union{Function,Nothing}=nothing)
function eigvals!(A::StridedMatrix{<:BlasComplex}; permute::Bool=true, scale::Bool=true, sortby::Union{Function,Nothing}=eigsortby)
function eigvals!(A::StridedMatrix{<:BlasReal}; permute::Bool=true, scale::Bool=true, sortby::Union{Function,Nothing}=eigsortby)
function eigvals!(A::StridedMatrix{T}, B::StridedMatrix{T}; sortby::Union{Function,Nothing}=eigsortby) where T<:BlasComplex
function eigvals!(A::StridedMatrix{T}, B::StridedMatrix{T}; sortby::Union{Function,Nothing}=eigsortby) where T<:BlasReal
function eigvals(A::AbstractMatrix, C::Cholesky; sortby::Union{Function,Nothing}=nothing)
function eigvals(A::AbstractMatrix{TA}, B::AbstractMatrix{TB}; kws...) where {TA,TB}
function eigvals(A::HermOrSym{TA}, B::HermOrSym{TB}; kws...) where {TA,TB}
function eigvals(A::RealHermSymComplexHerm, irange::UnitRange)
function eigvals(A::RealHermSymComplexHerm, vl::Real, vh::Real)
function eigvals(A::RealHermSymComplexHerm; sortby::Union{Function,Nothing}=nothing)
function eigvecs(A::AbstractTriangular{T}) where T
function eigvecs(A::LowerTriangular{<:BlasFloat,<:StridedMatrix})
function eigvecs(A::UnitLowerTriangular{<:BlasFloat,<:StridedMatrix})
function eigvecs(A::UnitUpperTriangular{<:BlasFloat,<:StridedMatrix})
function eigvecs(A::UpperTriangular{<:BlasFloat,<:StridedMatrix})
function eigvecs(D::Diagonal{T}) where T<:AbstractMatrix
function eigvecs(M::Bidiagonal{T}) where T
function elsize(::Type{Ptr{T}}) where T
function eltype(::Type{<:AbstractDict{K,V}}) where {K,V}
function emit_lineinfo_update(io::IO, linestart::String, lineidx::Int32)
function empty!(B::BitVector)
function empty!(a::Vector)
function empty!(d::IdDict)
function empty!(h::Dict{K,V}) where V where K
function empty!(s::BitSet)
function empty!(wkh::WeakKeyDict)
function empty(stack :: Stack)
function empty_backedges!(frame::InferenceState, currpc::Int=frame.currpc)
function empty_undo(s::PromptState)
function en_dash(stream::IO, md::MD)
function enable_logging(on::Bool=true)
function encode_effects(e::Effects)
function encode_effects_override(eo::EffectsOverride)
function endofline(buf::IOBuffer, pos::Int=position(buf))
function endswith(a::AbstractString, b::AbstractString)
function endswith(s::AbstractString, r::Regex)
function endswith(s::SubString{String}, r::Regex)
function enq_work(t::Task)
function ensure_rescheduled(othertask::Task)
function ensureroom(io::GenericIOBuffer, nshort::UInt)
function ensureroom_slowpath(io::GenericIOBuffer, nshort::UInt)
function enter_prefix_search(s::MIState, p::PrefixHistoryPrompt, backward::Bool)
function enter_search(s::MIState, p::HistoryPrompt, backward::Bool)
function entry_index(trie::HAMT, bi::BitmapIndex)
function entry_path(path::String, name::String)::Union{Nothing,String}
function entry_point_and_project_file(dir::String, name::String)::Union{Tuple{Nothing,Nothing},Tuple{String,Nothing},Tuple{String,String}}
function entry_point_and_project_file_inside(dir::String, name::String)::Union{Tuple{Nothing,Nothing},Tuple{String,Nothing},Tuple{String,String}}
function entryid(te::GitTreeEntry)
function entrytype(te::GitTreeEntry)
function env_project_file(env::String)::Union{Bool,String}
function eof(s::BufferStream)
function eof(s::LibuvStream)
function equal(ci1::Core.CodeInfo, ci2::Core.CodeInfo)
function err_message(errno::Integer)
function error(s::Vararg{Any,N}) where {N}
function errorbounds(A::AbstractTriangular{TA}, X::AbstractVecOrMat{TX}, B::AbstractVecOrMat{TB}) where {TA<:Number,TX<:Number,TB<:Number}
function errormonitor(t::Task)
function errors_not_signals(cmd::Cmd)
function errors_not_signals(p::Base.Process)
function escape_array_copy!(astate::AnalysisState, pc::Int, args::Vector{Any})
function escape_builtin!(::typeof(getfield), astate::AnalysisState, pc::Int, args::Vector{Any})
function escape_builtin!(::typeof(ifelse), astate::AnalysisState, pc::Int, args::Vector{Any})
function escape_builtin!(::typeof(setfield!), astate::AnalysisState, pc::Int, args::Vector{Any})
function escape_builtin!(::typeof(tuple), astate::AnalysisState, pc::Int, args::Vector{Any})
function escape_builtin!(::typeof(typeassert), astate::AnalysisState, pc::Int, args::Vector{Any})
function escape_call!(astate::AnalysisState, pc::Int, args::Vector{Any})
function escape_edges!(astate::AnalysisState, pc::Int, edges::Vector{Any})
function escape_exception!(astate::AnalysisState, tryregions::Vector{UnitRange{Int}})
function escape_foreigncall!(astate::AnalysisState, pc::Int, args::Vector{Any})
function escape_invoke!(astate::AnalysisState, pc::Int, args::Vector{Any})
function escape_microsoft_c_args(io::IO, args::AbstractString...)
function escape_new!(astate::AnalysisState, pc::Int, args::Vector{Any})
function escape_raw_string(io::IO, str::AbstractString, delim::Char)
function escape_raw_string(str::AbstractString, delim::Char)
function escape_string(io::IO, s::AbstractString, esc; keep )
function escape_val_ifdefined!(astate::AnalysisState, pc::Int, x)
function escapes(stream::IO, md::MD)
function eval_test(evaluated::Expr, quoted::Expr, source::LineNumberNode, negate::Bool=false)
function eval_with_backend(ast, backend::REPLBackendRef)
function evalfile(path::AbstractString, args::Vector{String}=String[])
function evalpoly(x, p::Tuple)
function evalpoly(z::Complex, p::Tuple)
function examine(mt::Core.MethodTable)
function examine(mt::Core.MethodTable)
function exit_on_sigint(on::Bool)
function exp!(A::StridedMatrix{T}) where T<:BlasFloat
function exp(z::Complex)
function exp10(z::Complex{T}) where T
function exp2(x::Base.BitInteger)
function exp2(z::Complex{T}) where T
function exp_impl(a::Float16, base)
function exp_impl(x::Float32, base)
function exp_impl(x::Float64, base)
function exp_impl(x::Float64, xlo::Float64, base)
function exp_impl_fast(x::Float32, base)
function exp_impl_fast(x::Float64, base)
function expanduser(path::AbstractString)
function expb_kernel(::Val{10}, x::Float32)
function expb_kernel(::Val{2}, x::Float32)
function explicit_manifest_deps_get(project_file::String, where::PkgId, name::String)::Union{Nothing,PkgId}
function explicit_manifest_entry_path(manifest_file::String, pkg::PkgId, entry::Dict{String,Any})
function explicit_manifest_uuid_path(project_file::String, pkg::PkgId)::Union{Nothing,String,Missing}
function explicit_mantissa_noinfnan(x::T) where {T<:IEEEFloat}
function explicit_project_deps_get(project_file::String, name::String)::Union{Nothing,UUID}
function expm1(x::Float16)
function expm1(x::Float32)
function expm1(x::Float64)
function expm1(z::Complex{T}) where T<:Real
function expm1_small(x::Float32)
function expm1_small(x::Float64)
function expm1b_kernel(::Val{10}, x::Float64)
function expm1b_kernel(::Val{2}, x::Float64)
function exponent(x::BigFloat)
function exponent(x::T) where T<:IEEEFloat
function export!(a::AbstractVector{T}, n::BigInt; order::Integer=-1, nails::Integer=0, endian::Integer=0) where {T<:Base.BitInteger}
function exprresolve(ex::Expr)
function exprresolve_arith(ex::Expr)
function exprresolve_conditional(ex::Expr)
function extendedterminfo(data::IO, NumInt::Union{Type{UInt16}, Type{UInt32}})
function f(io::IO)
function f(x::T = 1) where T
function f(x::Vector{T}) where {T}
function f1090(x)::Int
function f1090_err()::Int
function f11355(arg::DataType)
function f11355(sig::Type{T}) where T<:Tuple
function f17572(::Type{Val{A}}) where A
function f20961(x::Vector{Vec{N, T}}, y::Vector{Vec{N, T}}) where{N, T}
function f21147(f::Tuple{A}; kwargs...) where {B,A<:Tuple{B}}
function f23024(::Type{T}, ::Int) where T
function f24852_early_expr(f, x::X, y::Y) where {X, Y}
function f24852_early_inflated(f, x::X, y::Y) where {X, Y}
function f24852_early_uninflated(f, x::X, y::Y) where {X, Y}
function f24852_gen_cinfo_inflated(world::UInt, source, X, Y, _, f, x, y)
function f24852_gen_cinfo_uninflated(world::UInt, source, X, Y, _, f, x, y)
function f24852_kernel_cinfo(world::UInt, source, fsig::Type)
function f24852_late_expr(f, x::X, y::Y) where {X, Y}
function f27209(x::Union{Float64, Nothing})
function f28044(::Val{code28044}) where code28044
function f28279(b::Bool)
function f28356(::Type{T}) where {T<:Union{Float64,Float32}}
function f29175(tuple::T) where {T<:Tuple}
function f29326()::Any
function f30679(::DataType)
function f30679(t::Type{Int})
function f30772(a::T) where T
function f31353(f, x::Array{<:Dict})
function f32579(x::Int, b::Bool)
function f32620(x::T) where T
function f38751!(dest::Vector{UInt8}, src::Vector{UInt8}, n::UInt)
function f47374(i::Int, x)
function f48802!(log, x::Integer)
function f5457(obj_ptr::Ptr{Float64}, f)
function f_typ_assert(x::Int)
function f_typ_assert2(x::Any)
function f_unused_undefined_sp(::T...) where T
function f_with_maybe_nonbool_cond(a::Int, r::Bool)
function factorial(n::Integer)
function factorial(x::BigFloat)
function factorial_lookup(n::Integer, table, lim)
function factorize(A::AbstractMatrix{T}) where T
function fdio(name::AbstractString, fd::Integer, own::Bool=false)
function fencedcode(stream::IO, block::MD)
function fetch(t::Task)
function fetch_buffered(c::Channel)
function fetch_refspecs(rmt::GitRemote)
function fetchheads(repo::GitRepo)
function ffmerge!(repo::GitRepo, ann::GitAnnotated)
function fielddoc(binding::Binding, field::Symbol)
function fieldindex(T::DataType, name::Symbol, err::Bool=true)
function fieldindex(t::UnionAll, name::Symbol, err::Bool=true)
function fieldname(t::DataType, i::Integer)
function fieldtype_nothrow(ð•ƒ::AbstractLattice, s0, name)
function fieldtype_tfunc(ð•ƒ::AbstractLattice, s0, name)
function fieldtype_tfunc(ð•ƒ::AbstractLattice, s0, name, boundscheck)
function filemode(te::GitTreeEntry)
function filename(te::GitTreeEntry)
function files_changed(diff_stat::GitDiffStats)
function filesize(s::IOStream)
function fill!(A::AbstractArray{T}, x) where T
function fill!(A::Union{Diagonal,Bidiagonal,Tridiagonal,SymTridiagonal}, x)
function fill!(B::BitArray, x)
function fill!(S::SharedArray, v)
function fill!(V::SubArray{Bool, <:Any, <:BitArray, <:Tuple{AbstractUnitRange{Int}}}, x)
function fill!(a::Union{Array{UInt8}, Array{Int8}}, x::Integer)
function fill!(a::Union{Memory{UInt8}, Memory{Int8}}, x::Integer)
function fill!(cfg::GitConfig, cred::GitCredential)
function fill!(dest::Array{T}, x) where T
function fill_array!(rng::MersenneTwister, A::Ptr{Float64}, n::Int, I)
function fill_bitarray_from_itr!(B::BitArray, itr)
function fill_chunks!(Bc::Array{UInt64}, x::Bool, pos::Int, numbits::Int)
function fill_to_length(t::Tuple, val, ::Val{_N}) where {_N}
function fillband!(A::AbstractMatrix{T}, x, l, u) where T
function fillcells!(mc::Array{Cell})
function fillstored!(A::HermOrSym{T}, x) where T
function filter!(f, a::AbstractVector)
function filter!(f, d::AbstractDict)
function filter!(pred, h::Dict{K,V}) where {K,V}
function filter(f, Bs::BitArray)
function filter(f, a::AbstractArray)
function filter(f, a::Array{T, N}) where {T, N}
function filter(f, d::AbstractDict)
function filter(f, itr::SkipMissing{<:AbstractArray})
function filter(f, s::AbstractString)
function filter(f, s::Union{String, SubString{String}})
function filter_errors(ts::DefaultTestSet)
function filter_in_one_pass!(f, d::AbstractDict)
function filter_preferences(prefs::Dict{String, Any}, pkg_name)
function filtered_mod_names(ffunc::Function, mod::Module, name::AbstractString, all::Bool = false, imported::Bool = false)
function final_shred!(s::SecretBuffer)
function finalize_refs(S::SharedArray{T,N}) where T where N
function finalizer_sparam(d::DoAllocNoEscapeSparam{T}) where {T}
function find_all_in_cache_path(pkg::PkgId)
function find_artifacts_toml(path::String)
function find_constrained_arg(cnd::Conditional, fargs::Vector{Any}, sv::InferenceState)
function find_curblock(domtree::DomTree, allblocks::BitSet, curblock::Int)
function find_dict_matches(identifier::AbstractDict, partial_key)
function find_dominating_assignment(id::Int, idx::Int, sv::InferenceState)
function find_ext_path(project_path::String, extname::String)
function find_readme(m::Module)::Union{String, Nothing}
function find_root_impl!(parents::Vector{T}, x::Integer) where {T<:Integer}
function find_source_file(path::AbstractString)
function find_ssavalue_uses(body::Vector{Any}, nvals::Int)
function find_ssavalue_uses(e::Expr, uses::Vector{BitSet}, line::Int)
function find_ssavalue_uses(e::PhiNode, uses::Vector{BitSet}, line::Int)
function find_ssavalue_uses1(compact::IncrementalCompact)
function find_start_brace(s::AbstractString; c_start='(', c_end=')')
function find_terminfo_file(term::String)
function find_throw_blocks(code::Vector{Any}, handler_at::Vector{Int})
function findall(A::AbstractArray{Bool})
function findall(B::BitArray)
function findall(pred::Fix2{typeof(in),<:Union{Array{<:Real},Real}}, x::Array{<:Real})
function findall(pred::Fix2{typeof(in),<:Union{Memory{<:Real},Real}}, x::Memory{<:Real})
function findall(testf::Function, A)
function finddoc(Î», def::Expr)
function findfirst(p::Union{Fix2{typeof(isequal),T},Fix2{typeof(==),T}}, r::StepRange{T,S}) where {T,S}
function findfirst(testf::Function, A)
function findlast(testf::Function, A)
function findmax(a::BitArray)
function findmeta(ex::Expr)
function findmin(a::BitArray)
function findminmax!(f, op, Rval, Rind, A::AbstractArray{T,N}) where {T,N}
function findnext(B::BitArray, start::Integer)
function findnext(pred::Fix2{<:Union{typeof(isequal),typeof(==)},<:AbstractChar},
function findnext(pred::Fix2{<:Union{typeof(isequal),typeof(==)},Bool},
function findnext(testf::Function, A, start)
function findnext(testf::Function, s::AbstractString, i::Integer)
function findnextnot(B::BitArray, start::Int)
function findprev(B::BitArray, start::Integer)
function findprev(pred::Fix2{<:Union{typeof(isequal),typeof(==)},<:AbstractChar},
function findprev(pred::Fix2{<:Union{typeof(isequal),typeof(==)},Bool},
function findprev(testf::Function, A, start)
function findprev(testf::Function, s::AbstractString, i::Integer)
function findprevnot(B::BitArray, start::Int)
function finish!(interp::AbstractInterpreter, caller::InferenceState)
function finish(compact::IncrementalCompact)
function finish(me::InferenceState, interp::AbstractInterpreter)
function finish(rb::GitRebase, sig::GitSignature)
function finish(ts::CustomTestSet)
function finish(ts::DefaultTestSet; print_results::Bool=TESTSET_PRINT_ENABLE[])
function finish_cfg_inline!(state::CFGInliningState)
function finish_show_ir(io::IO, cfg::CFG, config::IRShowConfig)
function first(s::BitSet)
function first(v::AbstractVector, n::Integer)
function first_insert_for_bb(code::Vector{Any}, cfg::CFG, block::Int)
function first_step_last_ascending(r::StepRange)
function firstcaller(bt::Vector, funcsyms)
function firstdayofquarter(dt::Date)
function fixup_keymaps!(dict::Dict{Char,Any}, level, s, subkeymap)
function fixup_phinode_values!(compact::IncrementalCompact, old_values::Vector{Any}, reify_new_nodes::Bool)
function fixup_stdlib_path(path::String)
function fl_incomplete_tag(msg::AbstractString)
function fl_parse(text::AbstractString, filename::AbstractString, lineno, offset, options)
function flags_for_effects(effects::Effects)
function flat(io::IO, data::Vector{Alloc}, cols::Int, fmt::ProfileFormat)
function flatten(bc::Broadcasted)
function flatten(data::Vector, lidict::LineInfoDict)
function flatten_length(f, T::Type{<:NTuple{N,Any}}) where {N}
function flatten_times(t::Core.Compiler.Timings.Timing)
function fld(x::T, y::T) where T<:Integer
function fld1(x::T, y::T) where T<:Integer
function float(A::AbstractArray{T}) where T
function float(A::AbstractArray{Union{T, Missing}}) where {T}
function float(r::LinRange)
function float_samples(::Type{T}, exponents, n::Int) where {T<:AbstractFloat}
function floatrange(::Type{T}, start_n::Integer, step_n::Integer, len::Integer, den::Integer) where T
function floorceil(dt::TimeType, p::Period)
function floorceil(x::ConvertiblePeriod, precision::ConvertiblePeriod)
function flush(s::BufferStream)
function flush(s::IOStream)
function flush(s::LibuvStream)
function fma(a::Float16, b::Float16, c::Float16)
function fma(x::BigFloat, y::BigFloat, z::BigFloat)
function fma_emulated(a::Float32, b::Float32, c::Float32)::Float32
function fma_emulated(a::Float64, b::Float64,c::Float64)
function fmt(buf, pos, arg, spec::Spec{T}) where {T <: Chars}
function fmt(buf, pos, arg, spec::Spec{T}) where {T <: Floats}
function fmt(buf, pos, arg, spec::Spec{T}) where {T <: Ints}
function fmt(buf, pos, arg, spec::Spec{T}) where {T <: Strings}
function fmt(buf, pos, arg::Ref{<:Integer}, ::Spec{PositionCounter})
function fmt(buf, pos, args, argp, spec::Spec{T}) where {T}
function fmtfallback(buf, pos, arg, spec::Spec{T}) where {T}
function fold_ifelse!(compact::IncrementalCompact, idx::Int, stmt::Expr)
function foldl_impl(op::OP, nt, itr) where {OP}
function follow_map(map::Vector{Int}, idx::Int)
function foo(a::A, b::B) where {A,B}
function foo(a::T) where {T}
function foo(x::T, y::S) where T<:Number where S<:Number
function foo11904(x::Nullable11904{S}) where S
function foo4075(f::Foo4075, s::Symbol)
function foo42190(r::Union{Nothing,Int}, n::Int)
function foo_defined_last_iter(n::Int)
function footnote(stream::IO, block::MD)
function footnote_link(stream::IO, md::MD)
function forkRand(rng::Union{TaskLocalRNG, Xoshiro}, ::Val{N}) where N
function form_8x8_chunk(Bc::Vector{UInt64}, i1::Int, i2::Int, m::Int, cgap::Int, cinc::Int, nc::Int, msk8::UInt64)
function form_new_preserves(origex::Expr, intermediates::Vector{Int}, new_preserves::Vector{Any})
function format(buf::Vector{UInt8}, pos::Integer, f::Format, args...)
function format(dt::TimeType, f::AbstractString; locale::Locale=ENGLISH)
function format(dt::TimeType, fmt::DateFormat, bufsize=12)
function format(io, d::AbstractDateToken, dt, locale)
function format(io, d::DatePart{'p'}, dt, locale)
function format(io, d::DatePart{'s'}, dt)
function format(io, d::DatePart{'y'}, dt)
function format(io, d::Delim, dt, locale)
function format_error_message_for_err_type(error::ParserError)
function formatdoc(d::DocStr)
function frame_module(sv::AbsIntState)
function free(buf_ref::Base.Ref{Buffer})
function free(sa_ref::Base.Ref{StrArrayStruct})
function frexp(x::BigFloat)
function frexp(x::T) where T<:IEEEFloat
function from(frame::StackFrame, m::Module)
function from_fenv(r::Integer)
function from_intermustalias(rt::InterMustAlias, arginfo::ArgInfo)
function from_interprocedural(argescape::ArgEscapeInfo, pc::Int)
function fromfraction(f::Int128)
function front(t::Tuple)
function full!(A::LowerTriangular)
function full!(A::UnitLowerTriangular)
function full!(A::UnitUpperTriangular)
function full!(A::UpperTriangular)
function full_va_len(p::Core.SimpleVector)
function fullname(m::Module)
function fullname(ref::GitReference)
function functionloc(m::Method)
function futime(f::File, atime::Float64, mtime::Float64)
function fuzzyscore(needle::AbstractString, haystack::AbstractString)
function fuzzysort(search::String, candidates::Vector{String})
function fzero(bc::Broadcast.Broadcasted)
function g(::Union{map(t->Array{t,N},types27268)...} where N)
function g(::Val{x->2x})
function g21147(f::Tuple{A}, k = 2) where {B,A<:Tuple{B}}
function gc_alloc_count(diff::GC_Diff)
function gcd(a::T, b::T) where T<:BitInteger
function gcd(a::T, b::T) where T<:Integer
function gcd(abc::AbstractArray{<:Integer})
function gcdext!(x::BigInt, y::BigInt, z::BigInt, a::BigInt, b::BigInt)
function gcdx(a::BigInt, b::BigInt)
function gcdx(x::Rational, y::Rational)
function gen_bitarray(::HasLength, itr)
function gen_bitarray(::HasShape, itr)
function gen_bitarray(::HasShape, itr::Generator)
function gen_f(a::T) where T
function gen_nodes(qty::Integer) :: AbstractNode
function gen_rand(r::MersenneTwister)
function generating_output(incremental::Union{Bool,Nothing}=nothing)
function generic_lufact!(A::AbstractMatrix{T}, pivot::Union{RowMaximum,NoPivot,RowNonZero} = lupivottype(T);
function generic_matmatmul!(C::AbstractVecOrMat, tA, tB, A::AbstractVecOrMat, B::AbstractVecOrMat, _add::MulAddMul)
function generic_matmatmul(tA, tB, A::AbstractVecOrMat{T}, B::AbstractMatrix{S}) where {T,S}
function generic_mattridiv!(C::AbstractMatrix, uploc, isunitc, ::Function, A::AbstractMatrix, xB::AdjOrTrans)
function generic_mattridiv!(C::AbstractMatrix, uploc, isunitc, tfun::Function, A::AbstractMatrix, B::AbstractMatrix)
function generic_mattrimul!(C::AbstractMatrix, uploc, isunitc, ::Function, A::AbstractMatrix, xB::AdjOrTrans)
function generic_mattrimul!(C::AbstractMatrix, uploc, isunitc, tfun::Function, A::AbstractMatrix, B::AbstractMatrix)
function generic_mul!(C::AbstractArray, X::AbstractArray, s::Number, _add::MulAddMul)
function generic_mul!(C::AbstractArray, s::Number, X::AbstractArray, _add::MulAddMul)
function generic_trimatdiv!(C::AbstractVecOrMat, uploc, isunitc, ::Function, xA::AdjOrTrans, B::AbstractVecOrMat)
function generic_trimatdiv!(C::AbstractVecOrMat, uploc, isunitc, tfun::Function, A::AbstractMatrix, B::AbstractVecOrMat)
function generic_trimatmul!(C::AbstractVecOrMat, uploc, isunitc, ::Function, xA::AdjOrTrans, B::AbstractVecOrMat)
function generic_trimatmul!(C::AbstractVecOrMat, uploc, isunitc, tfun::Function, A::AbstractMatrix, B::AbstractVecOrMat)
function geqp3!(A::AbstractMatrix{<:BlasFloat})
function geqp3!(A::AbstractMatrix{<:BlasFloat}, jpvt::AbstractVector{BlasInt})
function get!(X::AbstractArray{T}, A::AbstractArray, I::RangeVecIntList, default::T) where T
function get!(X::AbstractArray{T}, A::AbstractArray, I::Union{AbstractRange,AbstractVector{Int}}, default::T) where T
function get!(X::AbstractVector{T}, A::AbstractVector, I::Union{AbstractRange,AbstractVector{Int}}, default::T) where T
function get!(default::Callable, ::EnvDict, k::AbstractString)
function get!(default::Callable, h::Dict{K,V}, key0) where V where K
function get!(default::Callable, h::Dict{K,V}, key::K) where V where K
function get!(default::Callable, t::AbstractDict{K,V}, key) where K where V
function get!(default::Callable, wkh::WeakKeyDict{K}, key) where {K}
function get!(lazyagdomtree::LazyAugmentedDomtree)
function get!(wkh::WeakKeyDict{K}, key, default) where {K}
function get!(x::LazyGenericDomtree{IsPostDom}) where {IsPostDom}
function get(::Type{<:AbstractString}, c::GitConfig, name::AbstractString)
function get(::Type{Bool}, c::GitConfig, name::AbstractString)
function get(::Type{GitRemote}, repo::GitRepo, rmt_name::AbstractString)
function get(::Type{Int32}, c::GitConfig, name::AbstractString)
function get(::Type{Int64}, c::GitConfig, name::AbstractString)
function get(c::GitConfig, name::AbstractString, default::T) where T
function get(default::Callable, dict::ImmutableDict, key)
function get(default::Callable, dict::PersistentDict{K,V}, key::K) where {K,V}
function get(default::Callable, h::Dict{K,V}, key) where V where K
function get(default::Callable, wkh::WeakKeyDict{K}, key) where {K}
function get(dict::ImmutableDict, key, default)
function get(dict::PersistentDict{K,V}, key::K, default) where {K,V}
function get(h::Dict{K,V}, key, default) where V where K
function get(s::AbstractString, i::Integer, default)
function get(val::ScopedValue{T}) where {T}
function get(wkh::WeakKeyDict{K}, key, default) where {K}
function get(wvc::WorldView{InternalCodeCache}, mi::MethodInstance, default)
function getEntry(keymap::Dict{Char,Any},key::Union{String,Char})
function get_alignment(ts::DefaultTestSet, depth::Int)
function get_atomic_order(order::Symbol, loading::Bool, storing::Bool)
function get_aux_root(n :: Int)
function get_binding_type_nothrow(ð•ƒ::AbstractLattice, M, s)
function get_binding_type_tfunc(ð•ƒ::AbstractLattice, M, s)
function get_bool_env(name::String, default::Bool)
function get_cached_result(state::InliningState, mi::MethodInstance)
function get_compare_strategy(p::Platform, key::String, default = compare_default)
function get_deps(raw_manifest::Dict)
function get_expr_list(ex::Core.CodeInfo)
function get_expr_list(ex::Expr)
function get_extension(parentid::PkgId, ext::Symbol)
function get_inlinetable(mi::MethodInstance)
function get_last_word(buf::IOBuffer)
function get_lines_in_region(s::BufferLike)
function get_local_result(inf_result::InferenceResult)
function get_max_methods(interp::AbstractInterpreter, sv::AbsIntState)
function get_max_methods_for_module(mod::Module)
function get_method_instance_roots(mi::Union{Method, MethodInstance})
function get_methodtable(m::Method)
function get_name_color(x::EscapeInfo, symbol::Bool = false)
function get_preferences(uuid::Union{UUID,Nothing} = nothing)
function get_preferences_hash(uuid::Union{UUID, Nothing}, prefs_list::Vector{String})
function get_staged(mi::MethodInstance, world::UInt)
function get_stmt_edges!(caller::InferenceState, currpc::Int=caller.currpc)
function get_task_ids(data::Vector{<:Unsigned}, threadid = nothing)
function get_task_tls(t::Task)
function get_test_counts(ts::DefaultTestSet)
function get_thread_ids(data::Vector{<:Unsigned}, taskid = nothing)
function get_updated_dict(p::TOML.Parser, f::CachedTOMLDict)
function get_uuid_name(project::Dict{String, Any}, uuid::UUID)
function get_uuid_name(project_toml::String, uuid::UUID)
function getaddrinfo(host::AbstractString)
function getaddrinfo(host::String, T::Type{<:IPAddr})
function getaliases(x::Union{Argument,SSAValue}, estate::EscapeState)
function getaliases(xidx::Int, estate::EscapeState)
function getalladdrinfo(host::String)
function getcache(mi::Core.MethodInstance)
function getconfig(name::AbstractString, default)
function getconfig(r::GitRepo, name::AbstractString, default)
function getconfig(rname::AbstractString, name::AbstractString, default)
function getdict!(dict::LineInfoDict, data::Vector{UInt})
function getdict(data::Vector{UInt})
function getelsize(list::Vector{T}) where T
function getfield_nothrow(ð•ƒ::AbstractLattice, arginfo::ArgInfo, boundscheck::Symbol=getfield_boundscheck(arginfo))
function getfield_nothrow(ð•ƒ::AbstractLattice, s00, name, boundscheck::Bool)
function getfield_tfunc(ð•ƒ::AbstractLattice, s00, name)
function getfield_tfunc(ð•ƒ::AbstractLattice, s00, name, boundscheck_or_order)
function getfield_tfunc(ð•ƒ::AbstractLattice, s00, name, order, boundscheck)
function getfilespaths!(filepaths::Vector, rootdir::AbstractString)
function getglobal_tfunc(ð•ƒ::AbstractLattice, M, s, order=Symbol)
function getgrgid(gid::Unsigned, throw_error::Bool=true)
function getgroupname(gid::Unsigned)
function gethandle(io::IO)
function getindex(::Type{T}, vals...) where T
function getindex(A::AbstractArray, I...)
function getindex(A::Array, I::AbstractUnitRange{<:Integer})
function getindex(A::Array, c::Colon)
function getindex(A::Array, i1::Int, i2::Int, I::Int...)
function getindex(A::Array, i::Int)
function getindex(A::Array{S}, I::AbstractRange{Int}) where S
function getindex(A::Bidiagonal{T}, i::Integer, j::Integer) where T
function getindex(A::Hermitian, i::Integer, j::Integer)
function getindex(A::Memory, I::AbstractUnitRange{<:Integer})
function getindex(A::ReshapedArray, index::ReshapedIndex)
function getindex(A::ReshapedArrayLF, index::Int)
function getindex(A::ReshapedArray{T,N}, indices::Vararg{Int,N}) where {T,N}
function getindex(A::SymTridiagonal{T}, i::Integer, j::Integer) where T
function getindex(A::Symmetric, i::Integer, j::Integer)
function getindex(A::Tridiagonal{T}, i::Integer, j::Integer) where T
function getindex(B::BitArray, i::Int)
function getindex(D::Diagonal, i::Int, j::Int)
function getindex(G::Givens, i::Integer, j::Integer)
function getindex(J::UniformScaling{T}, n::AbstractVector{<:Integer}, m::AbstractVector{<:Integer}) where T
function getindex(J::UniformScaling{T}, n::AbstractVector{<:Integer}, m::Integer) where T
function getindex(Q::AbstractQ, inds...)
function getindex(V::FastContiguousSubArray, i::Int)
function getindex(V::FastContiguousSubArray{<:Any, 1}, i::Int)
function getindex(V::FastSubArray, i::Int)
function getindex(V::FastSubArray{<:Any, 1}, i::Int)
function getindex(V::SubArray{T,N}, I::Vararg{Int,N}) where {T,N}
function getindex(compact::IncrementalCompact, ssa::NewSSAValue)
function getindex(compact::IncrementalCompact, ssa::OldSSAValue)
function getindex(compact::IncrementalCompact, ssa::SSAValue)
function getindex(dict::ImmutableDict, key)
function getindex(dict::PersistentDict{K,V}, key::K) where {K,V}
function getindex(dtfd::DataTypeFieldDesc, i::Int)
function getindex(h::Dict{K,V}, key) where V where K
function getindex(ir::IRCode, s::SSAValue)
function getindex(iter::LinearIndices, i::AbstractRange{<:Integer})
function getindex(iter::LinearIndices, i::Int)
function getindex(iter::SCartesianIndices2{K}, i::Int, j::Int) where {K}
function getindex(m::RegexMatch, name::Union{AbstractString,Symbol})
function getindex(node::Instruction, fld::Symbol)
function getindex(r::AbstractUnitRange, s::AbstractUnitRange{T}) where {T<:Integer}
function getindex(r::AbstractUnitRange, s::StepRange{T}) where {T<:Integer}
function getindex(r::LinRange{T}, s::OrdinalRange{S}) where {T, S<:Integer}
function getindex(r::OneTo{T}, s::OneTo) where T
function getindex(r::StepRange, s::AbstractRange{T}) where {T<:Integer}
function getindex(r::StepRangeLen{T,<:TwicePrecision,<:TwicePrecision}, s::OrdinalRange{S}) where {T, S<:Integer}
function getindex(r::StepRangeLen{T}, s::OrdinalRange{S}) where {T, S<:Integer}
function getindex(s::AbstractString, i::Integer)
function getindex(s::AnnotatedString, i::Integer)
function getindex(s::Slices{P,SM,AX,S,N}, I::Vararg{Int,N}) where {P,SM,AX,S,N}
function getindex(s::String, r::UnitRange{Int})
function getindex(s::SubString, i::Integer)
function getindex(t::AbstractDict{<:Any,V}, key) where V
function getindex(tpdum::TwoPhaseDefUseMap, idx::Int)
function getindex(tpvv::TwoPhaseVectorView, i::Int)
function getindex(view::TypesView, idx::Int)
function getindex(view::TypesView, idx::NewSSAValue)
function getindex(view::TypesView, v::OldSSAValue)
function getindex(wkh::WeakKeyDict{K}, key) where {K}
function getindex(wvc::WorldView{InternalCodeCache}, mi::MethodInstance)
function getindex(x::Number, I::Integer...)
function getindex(x::Number, i::Integer)
function getindex_continued(s, i::Int, u::UInt32)
function getipaddr(addr_type::Type{T}) where T<:IPAddr
function getipaddrs(addr_type::Type{T}=IPAddr; loopback::Bool=false) where T<:IPAddr
function getkey(h::Dict{K,V}, key, default) where V where K
function getkey(wkh::WeakKeyDict{K}, kk, default) where K
function getnameinfo(address::Union{IPv4, IPv6})
function getpass(input::TTY, output::IO, prompt::AbstractString)
function getprop(F::NotQRSparse, d::Symbol)
function getproperty(B::BunchKaufman{T,<:StridedMatrix}, d::Symbol) where {T<:BlasFloat}
function getproperty(C::Cholesky, d::Symbol)
function getproperty(C::CholeskyPivoted{T}, d::Symbol) where {T}
function getproperty(C::Cholesky{<:Any,<:Diagonal}, d::Symbol)
function getproperty(F::GeneralizedSVD{T}, d::Symbol) where T
function getproperty(F::GeneralizedSchur, d::Symbol)
function getproperty(F::Hessenberg, d::Symbol)
function getproperty(F::LDLt{<:Any, <:SymTridiagonal}, d::Symbol)
function getproperty(F::LQ, d::Symbol)
function getproperty(F::LU{T,Tridiagonal{T,V}}, d::Symbol) where {T,V}
function getproperty(F::LU{T}, d::Symbol) where T
function getproperty(F::QR, d::Symbol)
function getproperty(F::QRCompactWY, d::Symbol)
function getproperty(F::QRPivoted{T}, d::Symbol) where T
function getproperty(F::SVD, d::Symbol)
function getproperty(F::Schur, d::Symbol)
function getproperty(ci::CodeInfo, s::Symbol)
function getproperty(f::FDEvent, field::Symbol)
function getproperty(fdw::FDWatcher, s::Symbol)
function getproperty(m::AbstractMenu, name::Symbol)
function getproperty(pipe::AbstractPipe, name::Symbol)
function getproperty(server::LibuvServer, name::Symbol)
function getproperty(stream::LibuvStream, name::Symbol)
function getproperty(t::Task, field::Symbol)
function getproperty(x::Pairs, s::Symbol)
function getpwuid(uid::Unsigned, throw_error::Bool=true)
function getqs(F::LinearAlgebra.LQ)
function getqs(F::LinearAlgebra.LQ)
function getrandom!(A::Union{Array,Base.RefValue})
function getstate(::TaskLocalRNG)
function gettable(s::AbstractSerializer, id::Int)
function gettypeinfos(io::IO, p::Pair)
function getusername(uid::Unsigned)
function gitdir(repo::GitRepo)
function github_paragraph(stream::IO, md::MD)
function github_table(stream::IO, md::MD)
function givens(f::T, g::T, i1::Integer, i2::Integer) where T
function givensAlgorithm(f::Complex{T}, g::Complex{T}) where T<:AbstractFloat
function givensAlgorithm(f::T, g::T) where T
function givensAlgorithm(f::T, g::T) where T<:AbstractFloat
function global_logger(logger::AbstractLogger)
function glue_src_bitchunks(src::Vector{UInt64}, k::Int, ks1::Int, msk_s0::UInt64, ls0::Int)
function graphemes(s::AbstractString, r::AbstractUnitRange{<:Integer})
function group_roots(iter::RLEIterator)
function group_roots(m::Method)
function grow!(io::IO, offset::Integer, len::Integer)
function grow_to!(dest::AbstractDict{K, V}, itr) where V where K
function grow_to!(dest::AbstractDict{K,V}, itr, st) where V where K
function guardseed(f::Function, r::AbstractRNG=default_rng)
function h11480(x::A{A{A{A{A{A{A{A{A{Int}}}}}}}}}) 
function handle_control_backedge!(interp::AbstractInterpreter, frame::InferenceState, from::Int, to::Int)
function handle_deserialize(s::AbstractSerializer, b::Int32)
function handle_modifyfield!_call!(ir::IRCode, idx::Int, stmt::Expr, info::ModifyFieldInfo, state::InliningState)
function hardlink(src::AbstractString, dst::AbstractString)
function has_backslashes(f::Function)
function has_backslashes(meth::Method)
function has_backslashes(mod::Module)
function has_bottom_parameter(t::DataType)
function hash(A::AbstractArray, h::UInt)
function hash(a::AbstractDict, h::UInt)
function hash(a::typeA, h::UInt)
function hash(frame::StackFrame, h::UInt)
function hash(pkg::PkgId, h::UInt)
function hash(r::Regex, h::UInt)
function hash(s::AbstractSet, h::UInt)
function hash(s::SubString{String}, h::UInt)
function hash(t::Any32, h::UInt)
function hash(v::VersionNumber, h::UInt)
function hash(x::BigInt, h::UInt)
function hash(x::Float16, h::UInt)
function hash(x::Float64, h::UInt)
function hash(x::Rational{<:BitInteger64}, h::UInt)
function hash(x::Real, h::UInt)
function hash(z::Complex, h::UInt)
function hash_32_32(n::UInt32)
function hash_64_32(n::UInt64)
function hash_64_64(n::UInt64)
function hash_integer(n::BigInt, h::UInt)
function hash_integer(n::Integer, h::UInt)
function hash_seed(seed::Integer)
function hash_seed(seed::Union{AbstractArray{UInt32}, AbstractArray{UInt64}})
function hash_seed(str::AbstractString)
function hashheader(stream::IO, md::MD)
function haskey(dict::ImmutableDict, key)
function haskey(dict::PersistentDict{K}, key::K) where K
function haskey(m::RegexMatch, name::Union{AbstractString,Symbol})
function haskey(wkh::WeakKeyDict{K}, key) where {K}
function haskey(wvc::WorldView{InternalCodeCache}, mi::MethodInstance)
function hasmethod(f, t, kwnames::Tuple{Vararg{Symbol}}; world::UInt=get_world_counter)
function haszerolayout(x::NTuple{32, VecElement{UInt8}})
function hcat(A::Union{BitMatrix,BitVector}...)
function hcat(B::BitVector...)
function hcat(V::Vector{T}...) where T
function head!(repo::GitRepo, ref::GitReference)
function head(pkg::AbstractString)
function head(repo::GitRepo)
function head_oid(repo::GitRepo)
function header(p::Pager)
function headname(repo::GitRepo)
function heapify!(xs::Vector, o::Ordering)
function heappop!(xs::Vector, o::Ordering)
function heappush!(xs::Vector, x, o::Ordering)
function hello(param::Vector{In64_nOt_DeFiNeD__})
function helpmode(io::IO, line::AbstractString, mod::Module=Main)
function hermitian_type(::Type{T}) where {S, T<:AbstractMatrix{S}}
function hermitian_type(::Type{T}) where {S<:AbstractMatrix, T<:AbstractMatrix{S}}
function hermitian_type(::Type{T}) where {S<:Number, T<:AbstractMatrix{S}}
function hessenberg!(A::Union{Symmetric{<:BlasReal,<:StridedMatrix},Hermitian{<:BlasFloat,<:StridedMatrix}})
function hex(x::Unsigned, pad::Int, neg::Bool)
function hex2bytes!(dest::AbstractArray{UInt8}, itr)
function hex2bytes!(dest::AbstractArray{UInt8}, s::String)
function hidigit(x::AbstractFloat, base)
function highlight_region(lwrite::Union{String,SubString{String}}, regstart::Int, regstop::Int, written::Int, slength::Int)
function hilb(T::Type, m::Integer, n::Integer)
function hilb(T::Type, n::Integer)
function hist_from_file(hp::REPLHistoryProvider, path::String)
function hist_open_file(hp::REPLHistoryProvider)
function history_move(s::Union{LineEdit.MIState,LineEdit.PrefixSearchState}, hist::REPLHistoryProvider, idx::Int, save_idx::Int = hist.cur_idx)
function history_next(s::ModeState, hist)
function history_next_result(s::MIState, data::ModeState)
function history_prev(s::ModeState, hist)
function history_reset_state(hist::REPLHistoryProvider)
function history_set_backward(s::SearchState, backward::Bool)
function horizontalrule(stream::IO, block::MD)
function ht_keyindex2_shorthash!(h::Dict{K,V}, key) where V where K
function html(io::IO, code::Code)
function html(io::IO, content::Vector)
function html(io::IO, f::Footnote)
function html(io::IO, header::Header{l}) where l
function html(io::IO, md::Admonition)
function html(io::IO, md::BlockQuote)
function html(io::IO, md::HorizontalRule)
function html(io::IO, md::List)
function html(io::IO, md::Paragraph)
function html(io::IO, md::Table)
function htmlesc(io::IO, s::AbstractString)
function htmlesc(io::IO, s::Symbol)
function htmlesc(io::IO, xs::Union{AbstractString,Symbol}...)
function htmlesc(s::Union{AbstractString,Symbol})
function htmlinline(io::IO, br::LineBreak)
function htmlinline(io::IO, code::Code)
function htmlinline(io::IO, content::Vector)
function htmlinline(io::IO, f::Footnote)
function htmlinline(io::IO, link::Link)
function htmlinline(io::IO, md::Bold)
function htmlinline(io::IO, md::Image)
function htmlinline(io::IO, md::Italic)
function htmlinline(io::IO, md::Union{Symbol,AbstractString})
function hvcat(nbc::Int, as...)
function hvcat(rows::Tuple{Vararg{Int}}, xs::T...) where T<:Number
function hvcat_fill!(a::Array, xs::Tuple)
function hvncat_fill!(A::Array, row_first::Bool, xs::Tuple)
function hypot(x::BigFloat, y::BigFloat)
function iamax(dx::AbstractArray)
function ident_cmp(A::VerTuple, B::VerTuple)
function identify_package_env(name::String)
function identify_package_env(where::PkgId, name::String)
function ifelse_nothrow(ð•ƒ::AbstractLattice, cond, x, y)
function ifelse_tfunc(ð•ƒ::AbstractLattice, cnd, x, y)
function ig27907(::Type{T}, ::Type, N::Integer, offsets...) where {T}
function image(stream::IO, md::MD)
function implicit_manifest_deps_get(dir::String, where::PkgId, name::String)::Union{Nothing,PkgId}
function implicit_manifest_uuid_path(dir::String, pkg::PkgId)::Union{Nothing,String}
function implicit_project_deps_get(dir::String, name::String)::Union{Nothing,PkgId}
function in!(x, s::Set)
function in(idx::Int, bsbmp::BitSetBoundedMinPrioritySet)
function in(key_val::Pair{K,V}, dict::PersistentDict{K,V}, valcmp=(==)) where {K,V}
function in(key_value::Pair, dict::ImmutableDict, valcmp=(==))
function in(p, a::AbstractDict)
function in(p::Pair, a::AbstractDict, valcmp=(==))
function in(x::T, r::StepRange{T}) where T<:TimeType
function inbase(m::Module)
function include(fname::AbstractString)
function include(mod::Module, path::String)
function include_dependency(path::AbstractString)
function incomplete_tag(ex::Expr)
function increment_uses(ssa::AnySSAValue)
function indcopy(sz::Dims, I::GenericMemory)
function indcopy(sz::Dims, I::Tuple{Vararg{RangeIndex}})
function indcopy(sz::Dims, I::Vector)
function indent(depth::Int)
function indentation(str::AbstractString; tabwidth=8)
function indentcode(stream::IO, block::MD)
function index_dimsum(::AbstractArray{<:Any,N}, I...) where N
function index_ndims(i1::AbstractArray{CartesianIndex{N}}, I...) where N
function index_ndims(i1::CartesianIndex, I...)
function indexin(a, b::AbstractArray)
function indices_promote_type(::Type{Tuple{R1,Vararg{R1,N}}}, ::Type{Tuple{R2,Vararg{R2,N}}}) where {R1,R2,N}
function indmaxcolumn(A::AbstractMatrix)
function inflate_ir!(ci::CodeInfo, linfo::MethodInstance)
function inflate_ir!(ci::CodeInfo, sptypes::Vector{VarState}, argtypes::Vector{Any})
function inflate_ir(ci::CodeInfo)
function info(regex::Ptr{Cvoid}, what::Integer, ::Type{T}) where T
function init( n::Union{Nothing,Integer} = nothing, delay::Union{Nothing,Real} = nothing, limitwarn::Bool = true)
function init(n::Integer, delay::Real; limitwarn::Bool = true)
function init(path::AbstractString, bare::Bool=false)
function init_loc_flds(S::SharedArray{T,N}, empty_local=false) where T where N
function init_state(terminal, m::ModalInterface)
function init_stdio(handle::Ptr{Cvoid})
function init_vartable!(vartable::VarTable, frame::InferenceState)
function initmeta(m::Module)
function initstate!(r::MersenneTwister, data::StridedVector, seed)
function initstate!(x::Union{TaskLocalRNG, Xoshiro}, state)
function inline_code(stream::IO, md::MD)
function inline_const_if_inlineable!(inst::Instruction)
function inline_cost(ir::IRCode, params::OptimizationParams, cost_threshold::Int)
function inline_cost_clamp(x::Int)
function inline_into_block!(state::CFGInliningState, block::Int)
function inline_linfo_printer(code::IRCode)
function inlineanonymous(ex::Expr, val)
function input_string_newlines_aftercursor(s::PromptState)
function insert!(a::Array{T,1}, i::Integer, item) where T
function insert!(found, present, trie::HAMT{K,V}, i, bi, h, val) where {K,V}
function insert_extension_triggers(env::String, pkg::PkgId)::Union{Nothing,Missing}
function insert_extension_triggers(pkg::PkgId)
function insert_internal_warning(md::Markdown.MD, internal_access::Set{Pair{Module,Symbol}})
function insert_internal_warning(other, internal_access::Set{Pair{Module,Symbol}})
function insert_node!(ir::IRCode, pos::SSAValue, newinst::NewInstruction, attach_after::Bool=false)
function insert_node_here!(compact::IncrementalCompact, newinst::NewInstruction, reverse_affinity::Bool=false)
function insert_spval!(insert_node!::Inserter, spvals_ssa::SSAValue, spidx::Int, do_isdefined::Bool)
function insertions(diff_stat::GitDiffStats)
function instantiate(bc::Broadcasted)
function instantiate(bc::Broadcasted{Style{Tuple}})
function int_symdiff!(s::BitSet, n::Integer)
function integerpow(A::AbstractMatrix{T}, p) where T
function interp(stream::IO, md::MD)
function interpinner(stream::IO, greedy = false)
function intersect!(s::AbstractSet, itrs...)
function intersect(a::WorldRange, b::WorldRange)
function intersect(p1::Padding, p2::Padding)
function intersect(r1::AbstractRange, r2::AbstractRange)
function intersect(r1::AbstractRange, r2::AbstractRange, r3::AbstractRange, r::AbstractRange...)
function intersect(r::AbstractUnitRange{<:Integer}, s::StepRange{<:Integer})
function intersect(r::StepRange, s::StepRange)
function intersect(r::StepRange{<:Integer}, s::AbstractUnitRange{<:Integer})
function intersect(s::AbstractSet, itr)
function intersect(s::AbstractSet, itr, itrs...)
function intersect(v::AbstractVector, r::AbstractRange)
function intrinsic_effects(f::IntrinsicFunction, argtypes::Vector{Any})
function intrinsic_nothrow(f::IntrinsicFunction, argtypes::Vector{Any})
function inv(A::AbstractMatrix{T}) where T
function inv(A::StridedMatrix{T}) where T
function inv(B::Bidiagonal{T}) where T
function inv(B::BunchKaufman{<:BlasComplex,<:StridedMatrix})
function inv(B::BunchKaufman{<:BlasReal,<:StridedMatrix})
function inv(C::CholeskyPivoted{<:BlasFloat,<:StridedMatrix})
function inv(D::Diagonal{T}) where T
function inv(F::SVD{T}) where T
function inv(w::ComplexF64)
function inv(z::Complex)
function inv(z::Complex{T}) where T<:Union{Float16,Float32}
function invalidate_slotwrapper(vt::VarState, changeid::Int, ignore_conditional::Bool)
function invmod(n::Integer, m::Integer)
function invmod(x::BigInt, y::BigInt)
function invoke_rewrite(xs::Vector{Any})
function invoke_signature(argtypes::Vector{Any})
function invperm(P::Tuple)
function invperm(a::AbstractVector)
function invperm(p::Union{Tuple{},Tuple{Int},Tuple{Int,Int}})
function invsquaring(A0::UpperTriangular, theta)
function ip_matches_func(ip, func::Symbol)
function ipiv2perm(v::AbstractVector{T}, maxi::Integer) where T
function ipo_dataflow_analysis!(interp::AbstractInterpreter, ir::IRCode, result::InferenceResult)
function ipv6_field(ip::IPv6,i)
function ir_abstract_constant_propagation(interp::NativeInterpreter, irsv::IRInterpretationState)
function ir_to_codeinf!(opt::OptimizationState)
function ir_to_codeinf!(src::CodeInfo, ir::IRCode)
function irval(xidx::Int, estate::EscapeState)
function is_all_const_arg(argtypes::Vector{Any}, start::Int)
function is_ancestor_of(a::AbstractString, b::AbstractString, repo::GitRepo)
function is_bb_empty(ir::IRCode, bb::BasicBlock)
function is_builtin(ð•ƒâ‚’::AbstractLattice, s::Signature)
function is_call_graph_uncached(sv::CC.InferenceState)
function is_conditional_noub(inst::Instruction, sv::PostOptAnalysisState)
function is_const_prop_profitable_conditional(cnd::Conditional, fargs::Vector{Any}, sv::InferenceState)
function is_constprop_edge_recursed(edge::MethodInstance, caller::AbsIntState)
function is_constprop_method_recursed(method::Method, caller::AbsIntState)
function is_constprop_recursed(result::MethodCallResult, mi::MethodInstance, sv::AbsIntState)
function is_edge_recursed(edge::MethodInstance, caller::AbsIntState)
function is_effect_overridden(linfo::MethodInstance, effect::Symbol)
function is_expected_union(u::Union)
function is_exported_from_stdlib(name::Symbol, mod::Module)
function is_file_tracked(file::Symbol)
function is_global_function(tn::Core.TypeName, globname::Union{Symbol,Nothing})
function is_in_mods(m::Module, recursive::Bool, mods)
function is_ipo_dataflow_analysis_profitable(effects::Effects)
function is_legal_bb_drop(ir::IRCode, bbidx::Int, bb::BasicBlock)
function is_load_forwardable(x::EscapeInfo)
function is_method_recursed(method::Method, caller::AbsIntState)
function is_nonverbose_env(k::String)
function is_parent(dfs_tree::DFSTree, x::BBNumber, y::BBNumber)
function is_passphrase_required(private_key::AbstractString)
function is_pending(compact::IncrementalCompact, old::OldSSAValue)
function is_pop_loc(ex::Expr)
function is_pure_intrinsic_infer(f::IntrinsicFunction)
function is_relevant_expr(e::Expr)
function is_repl_frame_getproperty(sv::CC.InferenceState)
function is_result_constabi_eligible(result::InferenceResult)
function is_same_frame(interp::AbstractInterpreter, mi::MethodInstance, frame::InferenceState)
function is_throw_call(e::Expr)
function is_top_bit_set(x::Union{Int8,UInt8})
function is_typed_expr(e::Expr)
function is_union_phi(compact::IncrementalCompact, idx::Int)
function is_v1_format_manifest(raw_manifest::Dict{String})
function is_verbose_env(k::String)
function isa_kindtype(T::Type{<:AbstractVector})
function isa_nothrow(ð•ƒ::AbstractLattice, obj, typ)
function isa_tfunc(ð•ƒ::AbstractLattice, v, tt)
function isambiguous(m1::Method, m2::Method; ambiguous_bottom::Bool=false)
function isascii(cu::AbstractVector{CU}) where {CU <: Integer}
function isassigned(A::AbstractArray, i::Union{Integer, CartesianIndex}...)
function isassigned(A::ReshapedArrayLF, index::Int)
function isassigned(A::ReshapedArray{T,N}, indices::Vararg{Int, N}) where {T,N}
function isassigned(V::FastContiguousSubArray, i::Int)
function isassigned(V::FastContiguousSubArray{<:Any, 1}, i::Int)
function isassigned(V::FastSubArray, i::Int)
function isassigned(V::FastSubArray{<:Any, 1}, i::Int)
function isassigned(V::SubArray{T,N}, I::Vararg{Int,N}) where {T,N}
function isassigned(a::Array, i::Int...)
function isassigned(a::Memory, i::Int)
function isassigned(a::Vector, i::Int) 
function isassigned(r::AbstractRange, i::Integer)
function isassigned(v::SimpleVector, i::Int)
function isattached(repo::GitRepo)
function isbare(repo::GitRepo)
function isbinary(blob::GitBlob)
function isbinaryoperator(s::Symbol)
function isbranch(ref::GitReference)
function iscased(c::AbstractChar)
function iscommit(id::AbstractString, repo::GitRepo)
function isconst(g::GlobalRef)
function isdefined_effects(ð•ƒ::AbstractLattice, argtypes::Vector{Any})
function isdefined_globalref(g::GlobalRef)
function isdefined_nothrow(ð•ƒ::AbstractLattice, argtypes::Vector{Any})
function isdefined_nothrow(ð•ƒ::AbstractLattice, x, name)
function isdefined_tfunc(ð•ƒ::AbstractLattice, arg1, sym)
function isdefined_tfunc(ð•ƒ::AbstractLattice, arg1, sym, order)
function isdiff(repo::GitRepo, treeish::AbstractString, paths::AbstractString; cached::Bool=false)
function isdisjoint(a::AbstractRange{T}, b::AbstractRange{T}) where T
function isempty(bsbmp::BitSetBoundedMinPrioritySet)
function isempty(trie::HAMT)
function isempty_timeout(c::Channel)
function isequal(A::AbstractArray, B::AbstractArray)
function isequal(l::AbstractDict, r::AbstractDict)
function isequal_normalized(s1::AbstractString, s2::AbstractString; casefold::Bool=false, stripmark::Bool=false, chartransform=identity)
function isexecutable(path::String)
function isfilled(cred::GitCredential)
function isfilled(cred::SSHCredential)
function isfilled(cred::UserPasswordCredential)
function isgraphemebreak!(state::Ref{Int32}, c1::AbstractChar, c2::AbstractChar)
function ishead(ref::GitReference)
function ishermitian(A::AbstractMatrix)
function isidentifier(s::AbstractString)
function isinf(x::BigFloat)
function isinteger(x::BigFloat)
function isiterable(T)::Bool
function isknownlength(t::DataType)
function isless(a::T, b::T) where T<:IEEEFloat
function isless(a::VersionNumber, b::VersionNumber)
function isless(t1::Any32, t2::Any32)
function isless(t1::Tuple, t2::Tuple)
function islinklocaladdr(addr::IPv4)
function islinklocaladdr(addr::IPv6)
function islocked(l::SpinLock)
function islocked(rl::ReentrantLock)
function ismalformed(c::Char)
function ismatch(url::AbstractString, git_cred::GitCredential)
function ismodulecall(ex::Expr)
function isnan(x::BigFloat)
function isnan_type(::Type{T}, x) where T
function isone(A::AbstractMatrix)
function isopen(x::Union{LibuvStream, LibuvServer})
function isorphan(repo::GitRepo)
function isoverlong(c::Char)
function isperm(P::Tuple)
function ispostfixoperator(s::Union{Symbol,AbstractString})
function isqrt(x::Union{Int64,UInt64,Int128,UInt128})
function isreadable(io::LibuvStream)
function isremote(ref::GitReference)
function issetequal(a, b::AbstractSet)
function issorted(itr, order::Ordering)
function isstored(A::AbstractArray{<:Any,N}, I::Vararg{Integer,N}) where {N}
function isstructurepreserving(::typeof(Base.literal_pow), ::Ref{typeof(^)}, ::StructuredMatrix, ::Ref{Val{N}}) where N
function issubalias(a::AnyMustAlias, b::AnyMustAlias)
function issubnormal(x::T) where {T<:IEEEFloat}
function issubset(a::BitSet, b::BitSet)
function issue22582!(a::AbstractArray, b)
function issue44732(c::Container44732)
function issue48067(a::Int, b)
function issue49027(::Type{<:Issue49027{Ty}}) where Ty
function issue49027_integer(::Type{<:Issue49027{Ty}}) where Ty<:Integer
function issue51837( openquotechar::Char, newlinechar::Char)
function issymmetric(A::AbstractMatrix)
function istag(ref::GitReference)
function istril(A::AbstractMatrix, k::Integer = 0)
function istril(A::BitMatrix)
function istril(A::Union{LowerTriangular,UnitLowerTriangular}, k::Integer=0)
function istril(M::Bidiagonal, k::Integer=0)
function istril(M::Tridiagonal, k::Integer=0)
function istriu(A::AbstractMatrix, k::Integer = 0)
function istriu(A::BitMatrix)
function istriu(A::Union{UpperTriangular,UnitUpperTriangular}, k::Integer=0)
function istriu(A::UpperHessenberg, k::Integer=0)
function istriu(M::Bidiagonal, k::Integer=0)
function istriu(M::SymTridiagonal, k::Integer=0)
function istriu(M::Tridiagonal, k::Integer=0)
function isunix(os::Symbol)
function isvalid(s::SubString, i::Integer)
function isvalid_cache_header(f::IOStream)
function isvalid_pkgimage_crc(f::IOStream, ocachefile::String)
function isvalidpid(hostname::AbstractString, pid::Cuint)
function isvisible(sym::Symbol, parent::Module, from::Module)
function isword(c::AbstractChar)
function iswritable(io::LibuvStream)
function iszero(id::GitHash)
function iterate(::EnvDict, i=0)
function iterate(A::Reverse, state=(reverse(eachindex(A.itr)),))
function iterate(B::BitArray, i::Int=0)
function iterate(I::ANSIIterator, (i, m_st)=(1, iterate(I.captures)))
function iterate(L::LogicalIndex{<:Any,<:BitArray}, (i1, Bi, irest, c))
function iterate(L::LogicalIndex{<:CartesianIndex,<:BitArray})
function iterate(L::LogicalIndex{<:CartesianIndex})
function iterate(L::LogicalIndex{Int,<:BitArray})
function iterate(L::LogicalIndex{Int})
function iterate(P::ProductIterator)
function iterate(P::ProductIterator, states)
function iterate(R::ReshapedArrayIterator, i...)
function iterate(c::Channel, state=nothing)
function iterate(compact::IncrementalCompact, state=nothing)
function iterate(cp::CyclePadding)
function iterate(cp::CyclePadding, state::Tuple)
function iterate(d::IdDict{K,V}, idx=0) where {K, V}
function iterate(d::ImmutableDict{K,V}, t=d) where {K, V}
function iterate(doms::DominatedBlocks, state::Nothing=nothing)
function iterate(ebo::ExponentialBackOff, state= (ebo.n, min(ebo.first_delay, ebo.max_delay)))
function iterate(f::Filter, state...)
function iterate(g::Generator, s...)
function iterate(hash::EnvDict, block::Tuple{Ptr{UInt16},Ptr{UInt16}} = GESW)
function iterate(ibl::DropWhile)
function iterate(ibl::TakeWhile, itr...)
function iterate(it::CompactPeekIterator, (idx, aidx, bidx)::NTuple{3, Int}=(it.start_idx, it.compact.new_nodes_idx, 1))
function iterate(it::Cycle, state)
function iterate(it::Drop)
function iterate(it::UseRefIterator, op::Int=0)
function iterate(iter::BackedgeIterator, i::Int=1)
function iterate(iter::CartesianIndices)
function iterate(iter::CartesianIndices, state)
function iterate(iter::CartesianPartition)
function iterate(iter::CartesianPartition, (state, n))
function iterate(iter::SCartesianIndices2{K}) where {K}
function iterate(iter::SCartesianIndices2{K}, (state1, item2, state2)) where {K}
function iterate(iter::SplitIterator, (i, k, n)=(firstindex(iter.str), firstindex(iter.str), 0))
function iterate(itr::Accumulate)
function iterate(itr::Accumulate, state)
function iterate(itr::AsyncCollector)
function iterate(itr::AsyncCollector, state::AsyncCollectorState)
function iterate(itr::AsyncGenerator, state::AsyncGeneratorState=AsyncGeneratorState)
function iterate(itr::EachLine, state=nothing)
function iterate(itr::PartitionIterator, state...)
function iterate(itr::PartitionIterator{<:AbstractArray}, state = firstindex(itr.c))
function iterate(itr::PartitionIterator{<:AbstractRange}, state = firstindex(itr.c))
function iterate(itr::PartitionIterator{<:AbstractString}, state = firstindex(itr.c))
function iterate(itr::RegexMatchIterator, (offset,prevempty)=(1,false))
function iterate(itr::SkipMissing, state...)
function iterate(r::Iterators.Reverse{<:EachLine})
function iterate(r::Iterators.Reverse{<:EachLine}, state)
function iterate(r::OrdinalRange{T}, i) where {T}
function iterate(r::Reverse{<:CartesianIndices})
function iterate(r::Reverse{<:CartesianIndices}, state)
function iterate(r::Reverse{<:Enumerate})
function iterate(r::Reverse{<:Enumerate}, state)
function iterate(r::Union{StepRangeLen,LinRange}, i::Integer=zero(length(r)))
function iterate(result::MethodLookupResult, args...)
function iterate(s::BitSet, (word, idx) = (CHK0, 0))
function iterate(s::IdSet, state...)
function iterate(s::String, i::Int=firstindex(s))
function iterate(s::SubString, i::Integer=firstindex(s))
function iterate(specs::MethodSpecializations)
function iterate(specs::MethodSpecializations, i::Int)
function iterate(t::WeakKeyDict{K,V}, state...) where {K, V}
function iterate(trie::HAMT, state=nothing)
function iterate(unw::AbsIntStackUnwind, (sv, cyclei)::Tuple{AbsIntState, Int})
function iterate(v::Union{KeySet,ValueIterator}, state...)
function iterate(x::BBIdxIter, (idx, bb)::Tuple{Int, Int}=(1, 1))
function iterate_compact(compact::IncrementalCompact)
function iterate_continued(s, i::Int, u::UInt32)
function iterated_dominance_frontier(cfg::CFG, liveness::BlockLiveness, domtree::DomTree)
function iterlength(it)::Signed
function jit_compile(regex::Ptr{Cvoid})
function join(io::IO, iterator, delim, last)
function join(io::IO, iterator, delim)
function joinpath(paths::Union{Tuple, AbstractVector})::String
function joinpath(paths::Union{Tuple, AbstractVector})::String
function julia_cmd(julia=joinpath(Sys.BINDIR, julia_exename); cpu_target::Union{Nothing,String} = nothing)
function jump(r::MersenneTwister, steps::Integer)
function just_fixup!(compact::IncrementalCompact, new_new_nodes_offset::Union{Int, Nothing} = nothing, late_fixup_offset::Union{Int, Nothing} = nothing)
function keymap(keymaps::Union{Vector{AnyDict},Vector{Dict{Char,Any}}})
function keymap_merge!(target::Dict{Char,Any}, source::Union{Dict{Char,Any},AnyDict})
function keymap_merge(target::Dict{Char,Any}, source::Union{Dict{Char,Any},AnyDict})
function keypress(m::RadioMenu, i::UInt32)
function keypress(menu::MultiSelectMenu, key::UInt32)
function keys(m::RegexMatch)
function keys(t::Tuple, t2::Tuple...)
function keyworddoc(__source__, __module__, str, def::Base.BaseDocs.Keyword)
function kill(p::Process, signum::Integer=SIGTERM)
function kill_def_use!(tpdum::TwoPhaseDefUseMap, def::Int, use::Int)
function kill_edge!(bbs::Vector{BasicBlock}, from::Int, to::Int, callback=nothing)
function kill_edge!(compact::IncrementalCompact, active_bb::Int, from::Int, to::Int)
function kill_edge!(ir::IRCode, from::Int, to::Int, callback=nothing)
function kill_terminator_edges!(irsv::IRInterpretationState, term_idx::Int, bb::Int=block_for_inst(irsv.ir, term_idx))
function kron!(C::AbstractMatrix, A::AbstractMatrix, B::Diagonal)
function kron!(C::AbstractMatrix, A::Diagonal, B::AbstractMatrix)
function kron!(C::AbstractMatrix, A::Diagonal, B::Diagonal)
function kron!(C::AbstractVecOrMat, A::AbstractVecOrMat, B::AbstractVecOrMat)
function kron!(R::BitMatrix, a::BitMatrix, b::BitMatrix)
function kron!(R::BitVector, a::BitVector, b::BitVector)
function kron!(c::AbstractVector, a::AbstractVector, b::AbstractVector)
function kron(A::AbstractVecOrMat{T}, B::AbstractVecOrMat{S}) where {T,S}
function kron(A::Diagonal, B::Bidiagonal)
function kron(A::Diagonal, B::SymTridiagonal)
function kron(A::Diagonal, B::Tridiagonal)
function kron(a::AbstractVector{T}, b::AbstractVector{S}) where {T,S}
function kron(a::BitMatrix, b::BitMatrix)
function kron(a::BitVector, b::BitVector)
function kwarg_decl(m::Method, kwtype = nothing)
function kwerr(kw, args::Vararg{Any,N}) where {N}
function last(s::BitSet)
function last(v::AbstractVector, n::Integer)
function last(v::Pairs{K, V}) where {K, V}
function lastdayofquarter(dt::Date)
function lastdayofyear(dt::Date)
function latex(io::IO, code::Code)
function latex(io::IO, content::Vector)
function latex(io::IO, f::Footnote)
function latex(io::IO, header::Header{l}) where l
function latex(io::IO, md::Admonition)
function latex(io::IO, md::BlockQuote)
function latex(io::IO, md::HorizontalRule)
function latex(io::IO, md::List)
function latex(io::IO, md::Paragraph)
function latex(io::IO, md::Table)
function latexesc(io, s::AbstractString)
function latexinline(io::IO, code::Code)
function latexinline(io::IO, md::AbstractString)
function latexinline(io::IO, md::Bold)
function latexinline(io::IO, md::Image)
function latexinline(io::IO, md::Italic)
function latexinline(io::IO, md::Link)
function latexinline(io::IO, md::Vector)
function lbt_forward(path::AbstractString; clear::Bool = false, verbose::Bool = false, suffix_hint::Union{String,Nothing} = nothing)
function lbt_get_forward(symbol_name, interface::Symbol, f2c::Symbol = :plain)
function lcm(a::T, b::T) where T<:Integer
function ldexp(x::BigFloat, n::Clong)
function ldexp(x::BigFloat, n::Culong)
function ldexp(x::T, e::Integer) where T<:IEEEFloat
function ldiv!(A::LQ, B::AbstractVecOrMat)
function ldiv!(A::LU, B::AbstractVecOrMat)
function ldiv!(A::LU{T,Tridiagonal{T,V}}, B::AbstractVecOrMat) where {T,V}
function ldiv!(A::QR, B::AbstractVector)
function ldiv!(A::QRCompactWY{T}, B::AbstractMatrix{T}) where {T}
function ldiv!(A::QRCompactWY{T}, b::AbstractVector{T}) where {T}
function ldiv!(A::QRPivoted, B::AbstractMatrix)
function ldiv!(A::QRPivoted, b::AbstractVector)
function ldiv!(A::QRPivoted{T,<:StridedMatrix}, B::AbstractMatrix{T}, rcond::Real) where {T<:BlasFloat}
function ldiv!(A::QR{T}, B::AbstractMatrix{T}) where T
function ldiv!(A::SVD{T}, B::AbstractVecOrMat) where T
function ldiv!(A::Tridiagonal, B::AbstractVecOrMat)
function ldiv!(B::AbstractVecOrMat, D::Diagonal, A::AbstractVecOrMat)
function ldiv!(B::BunchKaufman{T,<:StridedMatrix}, R::StridedVecOrMat{T}) where {T<:BlasComplex}
function ldiv!(B::BunchKaufman{T,<:StridedMatrix}, R::StridedVecOrMat{T}) where {T<:BlasReal}
function ldiv!(C::Cholesky, B::AbstractVecOrMat)
function ldiv!(C::CholeskyPivoted, B::AbstractMatrix)
function ldiv!(C::CholeskyPivoted, B::AbstractVector)
function ldiv!(C::CholeskyPivoted{T,<:StridedMatrix}, B::StridedMatrix{T}) where T<:BlasFloat
function ldiv!(C::CholeskyPivoted{T,<:StridedMatrix}, B::StridedVector{T}) where T<:BlasFloat
function ldiv!(F::Hessenberg, B::AbstractVecOrMat)
function ldiv!(F::Hessenberg{<:Complex,<:Any,<:AbstractMatrix{<:Real}}, B::AbstractVecOrMat{<:Complex})
function ldiv!(F::UpperHessenberg, B::AbstractVecOrMat; shift::Number=false)
function ldiv!(Fadj::AdjointFactorization{<:Any,<:LQ}, B::AbstractVecOrMat)
function ldiv!(Fadj::AdjointFactorization{<:Any,<:Union{QR,QRCompactWY,QRPivoted}}, B::AbstractVecOrMat)
function ldiv!(S::LDLt{<:Any,<:SymTridiagonal}, B::AbstractVecOrMat)
function ldiv!(T::Tridiagonal, D::Diagonal, S::Union{SymTridiagonal,Tridiagonal})
function ldiv!(Y::AbstractMatrix, A::Factorization, B::AbstractMatrix)
function ldiv!(Y::AbstractVector, A::Factorization, B::AbstractVector)
function ldiv!(adjA::AdjointFactorization{<:Any,<:LU{T,Tridiagonal{T,V}}}, B::AbstractVecOrMat) where {T,V}
function ldiv!(adjA::AdjointFactorization{<:Any,<:LU}, B::AbstractVecOrMat)
function ldiv!(c::AbstractVecOrMat, A::Bidiagonal, b::AbstractVecOrMat)
function ldiv!(s::Number, X::AbstractArray)
function ldiv!(transA::TransposeFactorization{<:Any,<:LU{T,Tridiagonal{T,V}}}, B::AbstractVecOrMat) where {T,V}
function ldiv!(transA::TransposeFactorization{<:Any,<:LU}, B::AbstractVecOrMat)
function ldiv(F::Factorization, B::AbstractVecOrMat)
function ldlt!(S::SymTridiagonal{T,V}) where {T,V}
function ldlt(M::SymTridiagonal{T}; shift::Number=false) where T
function leadingspaces(buf::IOBuffer, b::Int)
function legalize_bb_drop_pred!(ir::IRCode, bb::BasicBlock, bbidx::Int, bbs::Vector{BasicBlock}, dropped_bbs::Vector{Int})
function length(::EnvDict)
function length(g::GraphemeIterator{S}) where {S}
function length(itr::PartitionIterator)
function length(mt::Core.MethodTable)
function length(q::IntrusiveLinkedList)
function length(r::AbstractUnitRange{T}) where T
function length(r::AbstractUnitRange{T}) where T<:Rational
function length(r::OrdinalRange{<:smallints})
function length(r::OrdinalRange{T}) where T
function length(r::OrdinalRange{T}) where T<:bigints
function length(s::AbstractString, i::Int, j::Int)
function length(s::Stateful)
function length(t::WeakKeyDict)
function length(v::SimpleVector)
function length(z::Zip)
function lerpi(j::Integer, d::Integer, a::BigFloat, b::BigFloat)
function lerpi(j::Integer, d::Integer, a::Rational, b::Rational)
function lerpi(j::Integer, d::Integer, a::T, b::T) where T
function less(file::AbstractString, line::Integer)
function less(file::AbstractString, line::Integer)
function less_than_constraint(a::String, b::String, a_requested::Bool, b_requested::Bool)
function levsort(search::String, candidates::Vector{String})
function libc_str(p::AbstractPlatform)
function lift_comparison!(::typeof(===), compact::IncrementalCompact,
function lift_comparison!(::typeof(isa), compact::IncrementalCompact,
function lift_comparison!(::typeof(isdefined), compact::IncrementalCompact,
function lift_svec_ref!(compact::IncrementalCompact, idx::Int, stmt::Expr)
function linear_inline_eligible(ir::IRCode)
function linebreak(stream::IO, md::MD)
function link(stream::IO, md::MD)
function link_image(path, out, internal_stderr::IO=stderr, internal_stdout::IO=stdout)
function link_pipe(reader_supports_async::Bool, writer_supports_async::Bool)
function liperm(lilist::Vector{StackFrame})
function list(stream::IO, block::MD)
function list_append!!(q::IntrusiveLinkedList{T}, q2::IntrusiveLinkedList{T}) where T
function list_deletefirst!(W::IntrusiveLinkedListSynchronized{T}, t::T) where T
function list_deletefirst!(q::IntrusiveLinkedList{T}, val::T) where T
function list_deletefirst!(q::LinkedList{T}, val::T) where T
function listen(addr; backlog::Integer=BACKLOG_DEFAULT)
function listen(path::AbstractString)
function listen(sock::LibuvServer; backlog::Integer=BACKLOG_DEFAULT)
function listenany(host::IPAddr, default_port; backlog::Integer=BACKLOG_DEFAULT)
function literal_pow(f::typeof(^), x, ::Val{p}) where {p}
function lld( adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
function lld( adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
function lld(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
function llvmcall_tfunc(ð•ƒ::AbstractLattice, fptr, rt, at, a...)
function lmul!(A::LQ, B::AbstractVecOrMat)
function lmul!(A::QRPackedQ, B::AbstractVecOrMat)
function lmul!(G::Givens, A::AbstractVecOrMat)
function lmul!(G::Givens, R::Rotation)
function lmul!(R::Rotation, A::AbstractVecOrMat)
function lmul!(adjA::AdjointQ{<:Any,<:QRPackedQ}, B::AbstractVecOrMat)
function lmul!(adjR::AdjointRotation{<:Any,<:Rotation}, A::AbstractVecOrMat)
function lmul!(s::Number, X::AbstractArray)
function lmul_triu!(x, M::AbstractMatrix, k::Integer=0)
function load_InteractiveUtils(mod::Module=Main)
function load_backtrace(trace::RawBacktrace)::Vector{BTElement}
function load_dummy_ref(x::Int)
function load_overrides(force::Bool = false)::Dict{Symbol, Any}
function load_path_expand(env::AbstractString)::Union{String, Nothing}
function load_path_setup_code(load_path::Bool=true)
function load_terminfo(term::String)
function load_type(ptr::Ptr{Type})
function loaddocs(docs::Vector{Core.SimpleVector})
function loadtriplet!(buffer::Buffer, ptr::Ptr{UInt8}, n::UInt)
function locale_dict(names::Vector{<:AbstractString})
function locate_package(pkg::PkgId, stopenv::Union{String, Nothing}=nothing)::Union{Nothing,String}
function locate_package_env(pkg::PkgId, stopenv::Union{String, Nothing}=nothing)
function locate_project_file(env::String)
function lock(f, l::AbstractLock)
function lock(l::SpinLock)
function lock(rl::ReentrantLock)
function log(A::AbstractMatrix)
function log(z::Complex)
function log10(z::Complex)
function log1p(x::BigFloat)
function log1p(x::Float32)
function log1p(x::Float64)
function log1p(z::Complex{T}) where T
function log2(z::Complex)
function log_nonpublic_access(expr::Expr, mod::Module, internal_access::Set{Pair{Module,Symbol}})
function log_proc2(f::Float32,base=Val(:â„¯))
function log_proc2(f::Float64,base=Val(:â„¯))
function log_quasitriu(A0::AbstractMatrix{T}) where T<:BlasFloat
function log_tab_unpack(t::UInt64)
function logabsdet(A::AbstractMatrix)
function logabsdet(A::Diagonal)
function logabsdet(A::Union{UpperTriangular{T},LowerTriangular{T}}) where T
function logabsdet(F::BunchKaufman)
function logabsdet(F::LDLt{<:Any,<:SymTridiagonal})
function logabsdet(F::LU{T}) where T  
function logabsdet(F::UpperHessenberg; shift::Number=false)
function logacc(x::Float64,expected::Float64)
function logdet(A::AbstractMatrix)
function logdet(A::AbstractQ)
function logdet(C::Cholesky)
function logdet(C::CholeskyPivoted)
function logdet(D::Diagonal{<:Complex})
function logdet(F::Factorization)
function logdet(F::Hessenberg)
function longpath(path::AbstractString)
function lookup(ip::Union{Base.InterpreterIP,Core.Compiler.InterpreterIP})
function lookup_inline_frame_info(func::Symbol, file::Symbol, linenum::Int, inlinetable::Vector{Core.LineInfoNode})
function lookup_inline_frame_info(func::Symbol, file::Symbol, miroots::Vector{Any})
function lookup_object_number(s::Serializer, n::UInt64)
function lookup_remote(repo::GitRepo, remote_name::AbstractString)
function loop_range_values(::Type{T}) where T
function lowercasefirst(s::AbstractString)
function lowrankdowndate!(C::Cholesky, v::AbstractVector)
function lowrankupdate!(C::Cholesky, v::AbstractVector)
function lreplace!(ex::Expr, r::LReplace)
function lreplace!(str::AbstractString, r::LReplace)
function lreplace!(sym::Symbol, r::LReplace)
function ls(rmt::GitRemote)
function lstrip(f, s::AbstractString)
function lt(a::StackFrame, b::StackFrame)
function ltruncto(str::String, w::Int)
function lu!(A::HermOrSym{T}, pivot::Union{RowMaximum,NoPivot,RowNonZero} = lupivottype(T); check::Bool = true) where {T}
function lu!(A::StridedMatrix{T}, ::RowMaximum; check::Bool = true) where {T<:BlasFloat}
function lu!(A::Tridiagonal{T,V}, pivot::Union{RowMaximum,NoPivot} = RowMaximum; check::Bool = true) where {T,V}
function lu!(F::LU{<:Any,<:Tridiagonal}, A::Tridiagonal, pivot::Union{RowMaximum,NoPivot} = RowMaximum; check::Bool = true)
function lu(x::Number; check::Bool=true)
function lutype(T::Type)
function lyap(A::AbstractMatrix, C::AbstractMatrix)
function lyap(A::AbstractMatrix{T}, C::AbstractMatrix{T}) where {T<:BlasFloat}
function madvise!(m::Array, flag::Integer=MADV_NORMAL)
function main(args = ARGS)::Int
function make(n::Int)
function make_entry_point(path::String, name::String, uuid::UUID)
function make_fastmath(expr::Expr)
function make_fastmath(symb::Symbol)
function make_issue47349(::Val{N}) where {N}
function make_scratch(scratch::Nothing, T::Type, len::Integer)
function make_scratch(scratch::Vector, T::Type, len::Integer)
function make_scratch(scratch::Vector{T}, ::Type{T}, len::Integer) where T
function manifest_deps_get(env::String, where::PkgId, name::String)::Union{Nothing,PkgId}
function manifest_uuid_path(env::String, pkg::PkgId)::Union{Nothing,String,Missing}
function map!(f, S::SharedArray, Q::SharedArray)
function map!(f, iter::ValueIterator)
function map!(f, iter::ValueIterator{<:Dict})
function map!(f::F, dest::AbstractArray, A::AbstractArray) where F
function map!(f::F, dest::AbstractArray, A::AbstractArray, B::AbstractArray) where F
function map!(f::F, dest::AbstractArray, As::AbstractArray...) where {F}
function map(::Type{T}, r::LinRange) where T<:AbstractFloat
function map(f, A::StructuredMatrix, Bs::StructuredMatrix...)
function map(f, nt::NamedTuple{names}, nts::NamedTuple...) where names
function map(f, s::AbstractString)
function map(f, t1::Any32, t2::Any32, ts::Any32...)
function map(f, t1::Tuple, t2::Tuple, ts::Tuple...)
function map(f, t::Any32)
function map(f, t::Any32, s::Any32)
function map(f, t::Tuple, s::Tuple)
function map_n!(f::F, dest::AbstractArray, As) where F
function map_slot_number(slot::Int)
function mapfirst!(f::F, R::AbstractArray, A::AbstractArray{<:Any,N}) where {N, F}
function mapfoldl_impl(f::F, op::OP, nt, itr) where {F,OP}
function mapreduce_impl(f, op::Union{typeof(max), typeof(min)},
function mapslices(f, A::AbstractArray; dims)
function mark(io::IO)
function mark_phi_cycles!(compact::IncrementalCompact, safe_phis::SPCSet, phi::Int)
function mark_throw_blocks!(src::CodeInfo, handler_at::Vector{Int})
function match(re::Regex, str::AnnotatedString)
function match(re::Regex, str::AnnotatedString, idx::Integer, add_opts::UInt32=UInt32)
function match_input(f::Function, s::Union{Nothing,MIState}, term, cs::Vector{Char}, keymap)
function match_input(k::Dict{Char}, s::Union{Nothing,MIState}, term::Union{AbstractTerminal,IOBuffer}=terminal(s), cs::Vector{Char}=Char[], keymap::Dict{Char} = k)
function match_logs(f, patterns...; match_mode::Symbol=:all, kwargs...)
function matches_oddness(a::String, b::String, a_requested::Bool, b_requested::Bool)
function matches_sv(parent::AbsIntState, sv::AbsIntState)
function matchinds(needle, haystack; acronym::Bool = false)
function matching_cache_argtypes(ð•ƒ::AbstractLattice, linfo::MethodInstance)
function matching_cache_argtypes(ð•ƒ::AbstractLattice, linfo::MethodInstance, simple_argtypes::SimpleArgtypes)
function materialize!(::BroadcastStyle, dest, bc::Broadcasted{<:Any})
function materialize!(dest, bc::Broadcasted{<:Any})
function matmul2x2(tA, tB, A::AbstractMatrix{T}, B::AbstractMatrix{S}) where {T,S}
function matmul3x3(tA, tB, A::AbstractMatrix{T}, B::AbstractMatrix{S}) where {T,S}
function max(x::T, y::T) where {T<:Union{Float32,Float64}}
function max_values(T::Union)
function maxstats(root::StackFrameTree)
function may_have_fcalls(m::Method)
function may_invoke_generator(mi::MethodInstance)
function maybe_cachefile_lock(f, pkg::PkgId, srcpath::String; stale_age=compilecache_pidlock_stale_age)
function maybe_compress_codeinfo(interp::AbstractInterpreter, linfo::MethodInstance, ci::CodeInfo)
function maybe_error_int(x::Int)
function maybe_extract_const_bool(c::AnyConditional)
function maybe_kws_nt(x::DataType)
function maybe_show_hint(s::PromptState)
function maybe_show_ir(ir::IRCode)
function maybe_vararg(isva::Bool)
function memcmp(a::Ptr, b::Ptr, n::Integer)
function memcpy(dst::Ptr, src::Ptr, n::Integer)
function memmove(dst::Ptr, src::Ptr, n::Integer)
function memoryref_builtin_common_nothrow(argtypes::Vector{Any})
function memoryref_isassigned_tfunc(ð•ƒ::AbstractLattice, mem, order, boundscheck)
function memoryref_tfunc(ð•ƒ::AbstractLattice, mem)
function memoryref_tfunc(ð•ƒ::AbstractLattice, ref, idx)
function memoryref_tfunc(ð•ƒ::AbstractLattice, ref, idx, boundscheck)
function memoryrefget_tfunc(ð•ƒ::AbstractLattice, mem, order, boundscheck)
function memoryrefoffset_tfunc(ð•ƒ::AbstractLattice, mem)
function memoryrefset!_tfunc(ð•ƒ::AbstractLattice, mem, item, order, boundscheck)
function memset(p::Ptr, val, n::Integer)
function merge!(d::AbstractDict, others::AbstractDict...)
function merge(a::NamedTuple, itr)
function merge(a::NamedTuple{an}, b::NamedTuple{bn}) where {an, bn}
function merge_adjacent_dim(apsz::Dims{N}, apst::Dims{N}, n::Int = 1) where {N}
function merge_analysis(repo::GitRepo, anns::Vector{GitAnnotated})
function merge_base(repo::GitRepo, one::AbstractString, two::AbstractString)
function merge_call_chain!(interp::AbstractInterpreter, parent::InferenceState, ancestor::InferenceState, child::InferenceState)
function merge_causes(causesa::IdSet{InferenceState}, causesb::IdSet{InferenceState})
function merge_effectbits(old::UInt8, new::UInt8)
function merge_effects!(::AbstractInterpreter, caller::InferenceState, effects::Effects)
function merge_effects(old::Effects, new::Effects)
function merge_to_unindexable(info::AInfo, infos::IdDict{Int,AInfo})
function merge_to_unindexable(info::AInfo, infos::Vector{AInfo})
function mergewith!(combine, d1::AbstractDict, d2::AbstractDict)
function mergewith!(combine, d1::Dict{K, V}, d2::AbstractDict) where {K, V}
function mergewith!(combine, d::AbstractDict, others::AbstractDict...)
function mergewith51009(combine, a::NamedTuple{an}, b::NamedTuple{bn}) where {an, bn}
function message(c::GitCommit, raw::Bool=false)
function meta(m::Module; autoinit::Bool=true)
function metadata_matches(ast::Core.CodeInfo)
function method_argnames(m::Method)
function mightalias(A::SubArray{T,<:Any,P}, B::SubArray{T,<:Any,P}) where {T,P}
function min(x::T, y::T) where {T<:Union{Float32,Float64}}
function minmax(x::BigFloat, y::BigFloat)
function minmax(x::T, y::T) where {T<:Union{Float32,Float64}}
function mkdir(path::AbstractString; mode::Integer = 0o777)
function mkpath(path::AbstractString; mode::Integer = 0o777)
function mkpidlock(at::String, proc::Process; kwopts...)
function mkpidlock(f::Function, at::String, pid::Cint; kwopts...)
function mktemp(fn::Function, parent::AbstractString=tempdir)
function mktemp(parent::AbstractString=tempdir; cleanup::Bool=true)
function mktemp(parent::AbstractString=tempdir; cleanup::Bool=true)
function mktempdir(fn::Function, parent::AbstractString=tempdir;
function mktempdir(parent::AbstractString=tempdir;
function mod(x::Int128, y::Int128)
function mod(x::T, y::T) where T<:Integer
function mod(x::T, y::T) where {T<:AbstractFloat}
function mode_idx(hist::HistoryProvider, mode::TextInterface)
function mode_keymap(julia_prompt::Prompt)
function modf(x::BigFloat)
function modf(x::T) where T<:IEEEFloat
function modifyfield!_tfunc(ð•ƒ::AbstractLattice, o, f, op, v)
function modifyfield!_tfunc(ð•ƒ::AbstractLattice, o, f, op, v, order)
function modifyproperty!(x, f::Symbol, op, v, order::Symbol=:not_atomic)
function module_build_id(m::Module)
function module_depth(from::Module, to::Module)
function moduledoc(__source__, __module__, meta, def, defâ€²::Expr)
function moduleroot(m::Module)
function modules_to_be_loaded(ast::Expr, mods::Vector{Symbol} = Symbol[])
function modulesof!(s::Set{Module}, x::Type)
function monthabbr(dt::TimeType; locale::AbstractString)
function monthname(dt::TimeType; locale::AbstractString)
function most_general_argtypes(closure::PartialOpaque)
function move_down!(m::AbstractMenu, cursor::Int, lastoption::Int=numoptions(m))
function move_line_end(buf::IOBuffer)
function move_line_end(s::MIState)
function move_line_start(s::MIState)
function move_up!(m::AbstractMenu, cursor::Int, lastoption::Int=numoptions(m))
function mpfr_to_ieee(::Type{Float32}, x::BigFloat, r::MPFRRM)
function mpfr_to_ieee(::Type{Float64}, x::BigFloat, r::MPFRRM)
function mpfr_to_ieee(::Type{G}, x::BigFloat, r::RoundingMode) where {G}
function mt_pop!(r::MersenneTwister, ::Type{T}) where T<:BitInteger
function mt_pop!(r::MersenneTwister, ::Type{T}) where {T<:Union{Int128,UInt128}}
function mt_setfull!(r::MersenneTwister, ::Type{<:BitInteger})
function mul!(C::AbstractArray, X::AbstractArray, s::Number, alpha::Number, beta::Number)
function mul!(C::AbstractArray, s::Number, X::AbstractArray, alpha::Number, beta::Number)
function mul!(C::AbstractVecOrMat{T}, A::AbstractVecOrMat, Q::AbstractQ{T}) where {T}
function mul!(C::AbstractVecOrMat{T}, Q::AbstractQ{T}, B::Union{AbstractVecOrMat,AbstractQ}) where {T}
function mul!(out::AbstractMatrix{T}, a::Number, B::UniformScaling, Î±::Number, Î²::Number) where {T}
function mul!(z::Rational{BigInt}, x::Rational{BigInt}, y::Rational{BigInt})
function mul(a::Vector{BigInt}, b::Vector{BigInt})
function mul12(x::T, y::T) where {T<:AbstractFloat}
function mul_with_overflow(x::T, y::T) where T<:BrokenSignedIntMul
function mul_with_overflow(x::T, y::T) where T<:BrokenUnsignedIntMul
function mul_with_overflow(x::T, y::T) where T<:Int128
function mul_with_overflow(x::T, y::T) where T<:UInt128
function mulshift(m::U, mul, j) where {U<:Unsigned}
function mulshiftinvsplit(::Type{T}, mv, mp, mm, i, j) where {T}
function mulshiftsplit(::Type{T}, mv, mp, mm, i, j) where {T}
function multidoc(__source__, __module__, meta, ex::Expr, define::Bool)
function multiple_uv_errors(pfx::AbstractString, codes::AbstractVector{<:Integer})
function multiq_insert(task::Task, priority::UInt16)
function multiq_sift_down(heap::taskheap, idx::Int32)
function multiq_sift_up(heap::taskheap, idx::Int32)
function multiq_size(tpid::Int8)
function mulxmod!(f::GF2X, m::GF2X, deg=degree(m))::GF2X
function mv(src::AbstractString, dst::AbstractString; force::Bool=false)
function my_ntuple(f::F, ::Val{N}) where {F,N}
function my_simple_count(pred, g::Vector{T}) where {T}
function mycompare(a, b)::Cint
function n_avail(c::Channel)
function nagle(sock::Union{TCPServer, TCPSocket}, enable::Bool)
function naive_idoms(blocks::Vector{BasicBlock}, is_post_dominator::Bool=false)
function name(ref::GitReference)
function name(rmt::GitRemote)
function name(tag::GitTag)
function nameof(f::Core.IntrinsicFunction)
function nameof(f::Function)
function narguments(sv::InferenceState, include_va::Bool=true)
function ndigits0z(x::Integer, b::Integer)
function ndigits0znb(x::Integer, b::Integer)
function ndigits0zpb(x::BigInt, b::Integer)
function ndigits0zpb(x::Integer, b::Integer)
function nearest_common_dominator(domtree::GenericDomTree, a::BBNumber, b::BBNumber)
function need_update(repo::GitRepo)
function new_expr_effect_flags(ð•ƒâ‚’::AbstractLattice, args::Vector{Any}, src::Union{IRCode,IncrementalCompact}, pattern_match=nothing)
function new_nodes_iter(compact::IncrementalCompact)
function new_nodes_iter(ir::IRCode, new_nodes_idx=1)
function next_char(l::Parser)::Char
function nextfloat!(x::BigFloat, n::Integer=1)
function nextfloat(f::IEEEFloat, d::Integer)
function nextind(s::AbstractString, i::Int, n::Int)
function nextpow(a::Real, x::Real)
function nextprod(a::Union{Tuple{Vararg{Integer}},AbstractVector{<:Integer}}, x::Real)
function nfields_tfunc(ð•ƒ::AbstractLattice, x)
function nmatches(info::UnionSplitInfo)
function non_dce_finish!(compact::IncrementalCompact)
function nonmissingtype_checked(T::Type)
function nonnothingtype_checked(T::Type)
function nonzero_chunks(chunks::Vector{UInt64}, pos0::Int, pos1::Int)
function norm(itr, p::Real=2)
function norm(x::Number, p::Real=2)
function norm(x::StridedVector{T}, rx::Union{UnitRange{TI},AbstractRange{TI}}) where {T<:BlasFloat,TI<:Integer}
function normalize!(a::AbstractArray, p::Real=2)
function normalize(a::AbstractArray, p::Real = 2)
function normalize(s::AbstractString, nf::Symbol)
function normalize_arch(arch::String)
function normalize_key(key::Union{String,SubString{String}})
function normalize_keys(keymap::Union{Dict{Char,Any},AnyDict})
function normpath(path::String)
function note_block_use!(usebb::Int, useidx::Int)
function notify(e::Event)
function notify_filled(buffer::IOBuffer, nread::Int)
function ntuple(f::F, ::Val{N}) where {F,N}
function ntuple(f::F, n::Integer) where F
function number_from_hex(c::UInt8)
function numbered_prompt!(repl::LineEditREPL=Base.active_repl, backend=nothing)
function nvalid(mi::Core.MethodInstance)
function objtype(obj_type::Consts.OBJECT)
function occursin(delim::UInt8, buf::GenericIOBuffer)
function occursin(delim::UInt8, buf::IOBuffer)
function occursin(pattern::Tuple, r::LogRecord)
function occursin(r::Regex, s::AbstractString; offset::Integer=0)
function occursin(r::Regex, s::SubString{String}; offset::Integer=0)
function oct(x::Unsigned, pad::Int, neg::Bool)
function offset_coerce(::Type{Base.OneTo{T}}, r::AbstractUnitRange) where T<:Integer
function on_semidominator_path(domtree::DomTree, x::BBNumber, y::BBNumber)
function one(x::BitMatrix)
function onediag(T::Type, m::Integer, n::Integer)
function onediag_sparse(T::Type, n::Integer)
function opaque_closure_tfunc(ð•ƒ::AbstractLattice, arg, lb, ub, source, env::Vector{Any}, linfo::MethodInstance)
function open(cmds::AbstractCmd, mode::AbstractString, stdio::Redirectable=devnull)
function open(cmds::AbstractCmd, stdio::Redirectable=devnull; write::Bool=false, read::Bool=!write)
function open(f::Function, args...; kwargs...)
function open(f::Function, cmds::AbstractCmd, args...; kwargs...)
function open(fd::RawFD)
function open(fname::AbstractString, mode::AbstractString; lock = true)
function open(h::OS_HANDLE)
function open(path::AbstractString, flags::Integer, mode::Integer=0)
function open_libllvm(f::Function)
function open_pipe!(p::PipeEndpoint, handle::OS_HANDLE)
function operator_associativity(s::Symbol)
function opnorm(A::AbstractMatrix, p::Real=2)
function opnorm1(A::AbstractMatrix{T}) where T
function opnorm2(A::AbstractMatrix{T}) where T
function opnormInf(A::AbstractMatrix{T}) where T
function optimize(interp::AbstractInterpreter, opt::OptimizationState, caller::InferenceResult)
function or_int_tfunc(ð•ƒ::ConstsLattice, x, y)
function oracle_check(compact::IncrementalCompact)
function ord(lt, by, rev::Bool, order::Ordering=Forward)
function ordschur!(gschur::GeneralizedSchur, select::Union{Vector{Bool},BitVector})
function ordschur!(schur::Schur, select::Union{Vector{Bool},BitVector})
function os_str(p::AbstractPlatform)
function overdub(c::Ctx, f::Union{Core.Builtin, Core.IntrinsicFunction}, args...)
function overdub_generator(world::UInt, source, self, c, f, args)
function overflow_check(r::AbstractUnitRange, offset::Integer)
function p7zip( adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
function p7zip(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
function pack8bools(z::UInt64)
function pack_platform!(meta::Dict, p::AbstractPlatform)
function package_slug(uuid::UUID, p::Int=5)
function page_down!(m::AbstractMenu, cursor::Int, lastoption::Int=numoptions(m))
function page_up!(m::AbstractMenu, cursor::Int, lastoption::Int=numoptions(m))
function paragraph(stream::IO, md::MD)
function parameter_upper_bound(t::UnionAll, idx)
function parent(c::GitCommit, n)
function parent_id(c::GitCommit, n)
function parentmodule_before_main(m::Module)
function parse(::Type{IPAddr}, str::AbstractString)
function parse(::Type{IPv4}, str::AbstractString)
function parse(::Type{IPv6}, str::AbstractString)
function parse(::Type{Rational{T}}, s::AbstractString) where T<:Integer
function parse(::Type{T}, c::AbstractChar; base::Integer = 10) where T<:Integer
function parse(::Type{T}, s::AbstractString; base::Union{Nothing,Integer} = nothing) where {T<:Integer}
function parse(::Type{VersionNumber}, v::AbstractString)
function parse(l::Parser)::TOMLDict
function parse(stream::IO, block::MD, config::Config; breaking = false)
function parse(stream::IO; flavor = julia)
function parse_array(l::Parser)::Err{Vector}
function parse_array_table(l)::Union{Nothing, ParserError}
function parse_bool(l::Parser, v::Bool)::Union{Bool, Nothing}
function parse_cache_header(cachefile::String)
function parse_cache_header(f::IO, cachefile::AbstractString)
function parse_dl_name_version(path::AbstractString, os::AbstractString)
function parse_dl_name_version(path::String, os::String)
function parse_entry(l::Parser, d)::Union{Nothing, ParserError}
function parse_flat(::Type{T}, data::Vector{Alloc}, C::Bool) where T
function parse_float(l::Parser, contains_underscore)::Err{Float64}
function parse_image_target(io::IO)
function parse_image_targets(targets::Vector{UInt8})
function parse_inline_table(l::Parser)::Err{TOMLDict}
function parse_inline_wrapper(stream::IO, delimiter::AbstractString; rep = false)
function parse_input_line(s::String; filename::String, depwarn=true)
function parse_key(l::Parser)
function parse_level(level::Symbol)
function parse_load_path(str::String)
function parse_local_time(l::Parser)
function parse_mapping(mapping::Dict, name::String, override_file::String)
function parse_mapping(mapping::String, name::String, override_file::String)
function parse_number_or_date_start(l::Parser)
function parse_pidfile(io::IO)
function parse_pidfile(path::String)
function parse_string_continue(l::Parser, multiline::Bool, quoted::Bool)::Err{String}
function parse_string_start(l::Parser, quoted::Bool)::Err{String}
function parse_toml(path::String)
function parse_toplevel(l::Parser)::Err{Nothing}
function parse_value(l::Parser)
function parseall(text::AbstractString; filename, lineno=1)
function parseatom(text::AbstractString, pos::Integer; filename, lineno=1)
function parsed_toml(project_file::AbstractString, toml_cache::TOMLCache, toml_lock::ReentrantLock)
function parsedoc(d::DocStr)
function parseinline(stream::IO, md::MD, config::Config)
function parseinline(stream::IO, md::MD, parsers::Vector{Function})
function parseint_iterate(s::AbstractString, startpos::Int, endpos::Int)
function parseint_preamble(signed::Bool, base::Int, s::AbstractString, startpos::Int, endpos::Int)
function parserow(stream::IO)
function partialsort!(v::AbstractVector, k::Union{Integer,OrdinalRange}, o::Ordering)
function partition!(v::AbstractVector, lo::Integer, hi::Integer, o::Ordering)
function path(repo::GitRepo)
function path(trie::HAMT{K,V}, key, _h, copy=false) where {K, V}
function pathof(m::Module)
function peakflops(n::Integer=4096; eltype::DataType=Float64, ntrials::Integer=3, parallel::Bool=false)
function peakflops(n::Integer=4096; eltype::DataType=Float64, ntrials::Integer=3, parallel::Bool=false)
function peek(from::GenericIOBuffer, ::Type{UInt8})
function peek(from::GenericIOBuffer, T::Union{Type{Int16},Type{UInt16},Type{Int32},Type{UInt32},Type{Int64},Type{UInt64},Type{Int128},Type{UInt128},Type{Float16},Type{Float32},Type{Float64}})
function peek(io::SecretBuffer, ::Type{UInt8})
function peek(s::IO, ::Type{T}) where T
function peek(s::IOStream, ::Type{UInt8})
function peek(s::LibuvStream, ::Type{T}) where T
function peek(s::Stateful, sentinel=nothing)
function peel(::Type{T}, obj::GitObject) where T<:GitObject
function peel(::Type{T}, ref::GitReference) where T<:GitObject
function percolate_down!(xs::Vector, i::Integer, x, o::Ordering, len::Integer=length(xs))
function percolate_up!(xs::Vector, i::Integer, x, o::Ordering)
function permutecols!!(a::AbstractMatrix, p::AbstractVector{<:Integer})
function permutedims!(dest, src::AbstractArray, perm)
function permutedims(A::AbstractArray, perm)
function permutedims(B::Bidiagonal, perm)
function permutedims(B::StridedArray, perm)
function permutedims(S::SymTridiagonal, perm)
function permutedims(T::Tridiagonal, perm)
function pfib(n::Int)
function pick(menu::MultiSelectMenu, cursor::Int)
function pick(menu::RadioMenu, cursor::Int)
function pick_const_args!(ð•ƒ::AbstractLattice, cache_argtypes::Vector{Any}, overridden_by_const::BitVector, given_argtypes::Vector{Any})
function pick_const_args(ð•ƒ::AbstractLattice, linfo::MethodInstance, given_argtypes::Vector{Any})
function pickvarnames(x::Vector{Any})
function pickvarnames2(x::Vector{Any})
function pinv(D::Diagonal{T}) where T
function pinv(D::Diagonal{T}, tol::Real) where T
function pinv(x::Number)
function pipeline(cmd::AbstractCmd; stdin=nothing, stdout=nothing, stderr=nothing, append::Bool=false)
function pipeline_error(proc::Process)
function pipeline_error(procs::ProcessChain)
function pkg_str(_pkg::PkgId)
function pkgdir(m::Module, paths::String...)
function pkgversion(m::Module)
function plain(io::IO, code::Code)
function plain(io::IO, content::Vector)
function plain(io::IO, f::Footnote)
function plain(io::IO, header::Header{l}) where l
function plain(io::IO, l::LaTeX)
function plain(io::IO, list::List)
function plain(io::IO, md)
function plain(io::IO, md::Admonition)
function plain(io::IO, md::HorizontalRule)
function plain(io::IO, md::Table)
function plain(io::IO, p::Paragraph)
function plain(io::IO, q::BlockQuote)
function plaininline(io::IO, md...)
function plaininline(io::IO, md::Code)
function platform_dlext(p::AbstractPlatform = HostPlatform)
function platform_name(p::AbstractPlatform)
function platforms_match(a::AbstractPlatform, b::AbstractPlatform)
function platforms_match(a::AbstractPlatform, b::String)
function platforms_match(a::String, b::AbstractPlatform)
function plength(f::Spec{T}, args, argp) where {T}
function plength(f::Spec{T}, x) where {T <: Chars}
function plength(f::Spec{T}, x) where {T <: Ints}
function plength(f::Spec{T}, x) where {T <: Strings}
function point_to_line(str::AbstractString, a::Int, b::Int, context)
function pointer(V::SubArray{<:Any,<:Any,<:Array,<:Tuple{Vararg{RangeIndex}}}, is::AbstractCartesianIndex{N}) where {N}
function pointer(x::AbstractArray{T}, i::Integer) where T
function pointerref_tfunc(ð•ƒ::AbstractLattice, a, i, align)
function pointerset_tfunc(ð•ƒ::AbstractLattice, a, v, i, align)
function poison_callstack!(infstate::InferenceState, topmost::InferenceState)
function poll_fd(s::Union{RawFD, Sys.iswindows ? WindowsRawSocket : Union{}}, timeout_s::Real=-1; readable=false, writable=false)
function poll_file(s::AbstractString, interval_seconds::Real=5.007, timeout_s::Real=-1)
function pop!(B::BitVector)
function pop!(W::IntrusiveLinkedListSynchronized)
function pop!(a::Vector)
function pop!(h::Dict)
function pop!(h::Dict, key)
function pop!(h::Dict, key, default)
function pop!(q::IntrusiveLinkedList{T}) where {T}
function pop!(s::BitSet, n::Integer)
function pop!(s::BitSet, n::Integer, default)
function pop!(s::Set)
function pop!(s::Set, x)
function pop!(wkh::WeakKeyDict{K}, key) where {K}
function pop!(wkh::WeakKeyDict{K}, key, default) where {K}
function pop(stack :: Stack)
function pop_undo(s::PromptState)
function popat!(a::Vector, i::Integer)
function popat!(a::Vector, i::Integer, default)
function popdisplay(d::AbstractDisplay)
function popfirst!(B::BitVector)
function popfirst!(W::IntrusiveLinkedListSynchronized)
function popfirst!(a::Vector)
function popfirst!(bsbmp::BitSetBoundedMinPrioritySet)
function popfirst!(q::IntrusiveLinkedList{T}) where {T}
function popfirst!(s::Stateful)
function poplinenum(ex::Expr)
function poptask(W::StickyWorkqueue)
function populate_def_use_map!(tpdum::TwoPhaseDefUseMap, scanner::BBScanner)
function position(f::File)
function position(s::IOStream)
function postprocess!(dict::Dict{Char,Any})
function pow5split(::Type{T}, i) where {T<:AbstractFloat}
function pow_body(x::T, y::T) where T <: Union{Float16, Float32}
function pow_body(xu::UInt64, y::Float64)
function power_by_squaring(x::Bool, p::Integer)
function powermod(x::BigInt, p::BigInt, m::BigInt)
function powermod(x::Integer, p::Integer, m::T) where T<:Integer
function powm!(A0::UpperTriangular{<:BlasFloat}, p::Real)
function powxmod(e::BigInt, m::GF2X)::GF2X
function preferences_hash(cachefile::String)
function prepare_for_deletion(path::AbstractString)
function prepare_next(repl::LineEditREPL)
function prepend!(B::BitVector, items::BitVector)
function prepend!(a::Vector, items::AbstractVector)
function preprint(io::IO)
function preprint(io::IO, idx::Int)
function preserve_active(command::Symbol)
function prevfloat!(x::BigFloat, n::Integer=1)
function prevind(s::AbstractString, i::Int, n::Int)
function prevpow(a::T, x::Real) where T <: Real
function print(io::IO, v::VersionNumber)
function print(io::IO, x)
function print(io::IO, xs...)
function print(io::IO,ip::IPv6)
function print_bit_chunk(io::IO, c::UInt64, l::Integer = 64)
function print_callstack(sv::InferenceState)
function print_correction(io::IO, word::String, mod::Module)
function print_fullname(io::IO, m::Module)
function print_indentation(final::Bool=true)
function print_inline_table(f::MbyFunc, io::IO, value::AbstractDict)
function print_integer(io::IO, value::Integer)
function print_joined_cols(io::IO, ss::Vector{String}, delim = "", last = delim; cols::Int = _displaysize(io)[2])
function print_llvm(io::IO, code::String)
function print_native(io::IO, code::String, arch::Symbol=sys_arch_category)
function print_new_node(node; final::Bool=true)
function print_quoted(io, s::AbstractString)
function print_response(errio::IO, response, show_value::Bool, have_color::Bool, specialdisplay::Union{AbstractDisplay,Nothing}=nothing)
function print_response(repl::AbstractREPL, response, show_value::Bool, have_color::Bool)
function print_shell_escaped_posixly(io::IO, args::AbstractString...)
function print_shell_word(io::IO, word::AbstractString, special::AbstractString = "")
function print_stackframe(io, i, frame::StackFrame, n::Int, ndigits_max, modulecolor)
function print_stackframe(io, i, frame::StackFrame, n::Int, ndigits_max, modulecolordict, modulecolorcycler)
function print_state(args::Pair{String,String}...)
function print_status(key::String)
function print_test_errors(ts::DefaultTestSet)
function print_test_results(ts::DefaultTestSet, depth_pad=0)
function print_toml_escaped(io::IO, s::AbstractString)
function print_tree(io::IO, alg::Algorithm, cols::Int)
function print_tree(io::IO, bt::StackFrameTree{T}, cols::Int, fmt::ProfileFormat, is_subsection::Bool) where T
function print_type_bicolor(io, str::String; color=:normal, inner_color=:light_black, use_color::Bool=true)
function print_with_info(io::IO, result::EscapeResult)
function print_with_info(preprint, postprint, io::IO, ir::IRCode, source::Bool)
function print_wrapped(io::IO, s...; width = 80, pre = "", i = 0)
function printkey(io::IO, keys::Vector{String})
function printmatch(io::IO, word, match)
function printmatches(io::IO, word, matches; cols::Int = _displaysize(io)[2])
function printmenu(out::IO, m::AbstractMenu, cursoridx::Int; oldstate=nothing, init::Bool=false)
function printstyled_ll(io::IO, x, s::Symbol, trailing_spaces="")
function printvalue(f::MbyFunc, io::IO, value)
function printvalue(f::MbyFunc, io::IO, value::AbstractVector)
function printvalue(f::MbyFunc, io::IO, value::TOMLValue)
function process_backtrace(t::Vector, limit::Int=typemax(Int); skipC = true)
function process_newnode!(compact::IncrementalCompact, new_idx::Int, new_node_entry::Instruction, new_node_info::NewNodeInfo, idx::Int, active_bb::Int, do_rename_ssa::Bool)
function process_node!(compact::IncrementalCompact, result_idx::Int, inst::Instruction, idx::Int, processed_idx::Int, active_bb::Int, do_rename_ssa::Bool)
function process_overrides(artifact_dict::Dict, pkg_uuid::Base.UUID)
function process_simple!(todo::Vector{Pair{Int,Any}}, ir::IRCode, idx::Int, state::InliningState)
function process_status(s::Process)
function prod(arr::AbstractArray{BigInt})
function project_deps_get(env::String, name::String)::Union{Nothing,PkgId}
function project_deps_get_completion_candidates(pkgstarts::String, project_file::String)
function project_file_ext_path(project_file::String, name::String)
function project_file_manifest_path(project_file::String)::Union{Nothing,String}
function project_file_name_uuid(project_file::String, name::String)::PkgId
function project_file_path(project_file::String)
function promote_op(f, S::Type...)
function promote_rule(::Type{StepRangeLen{T1,R1,S1,L1}},::Type{StepRangeLen{T2,R2,S2,L2}}) where {T1,T2,R1,R2,S1,S2,L1,L2}
function promote_rule(::Type{StepRange{T1a,T1b}}, ::Type{StepRange{T2a,T2b}}) where {T1a,T1b,T2a,T2b}
function promote_rule(T::Type{>:Missing}, S::Type)
function promote_rule(T::Type{>:Nothing}, S::Type)
function promote_rule(T::Type{>:Union{Nothing, Missing}}, S::Type)
function promote_rule(a::Type{LinRange{T1,L1}}, b::Type{LinRange{T2,L2}}) where {T1,T2,L1,L2}
function promote_shape(a::AbstractArray, b::AbstractArray)
function promote_shape(a::Dims, b::Dims)
function promote_shape(a::Indices, b::Indices)
function promote_shape(a::Tuple{Int, Int}, b::Tuple{Int, Int})
function promote_shape(a::Tuple{Int,Int}, b::Tuple{Int,})
function promote_shape(a::Tuple{Int,}, b::Tuple{Int,})
function promote_type(::Type{T}, ::Type{S}) where {T,S}
function promote_typejoin_union(::Type{T}) where T
function prompt!(term::TextTerminal, prompt::ModalInterface, s::MIState = init_state(term, prompt))
function prompt(input::IO, output::IO, message::AbstractString; default::AbstractString="")
function propagate_alias_change!(estate::EscapeState, change::AliasChange)
function propagate_changes!(estate::EscapeState, changes::Changes)
function propagate_liveness_change!(estate::EscapeState, change::LivenessChange)
function propagate_to_error_handler!(frame::InferenceState, currpc::Int, W::BitSet, ð•ƒáµ¢::AbstractLattice, currstate::VarTable)
function push!!(v::Vector, el)
function push!(B::BitVector, item)
function push!(W::IntrusiveLinkedListSynchronized{T}, t::T) where T
function push!(a::Vector{T}, item) where T
function push!(bsbmp::BitSetBoundedMinPrioritySet, idx::Int)
function push!(q::IntrusiveLinkedList{T}, val::T) where T
function push!(s::IntDisjointSet{T}) where {T<:Integer}
function push!(tpvv::TwoPhaseVectorView, v::Int)
function push!(w::GitRevWalker, cid::GitHash)
function push!(w::GitRevWalker, range::AbstractString)
function push(stack :: Stack, val :: String)
function push_head!(w::GitRevWalker)
function push_kill!(s::MIState, killed::String, concat::Bool = s.key_repeats > 0; rev::Bool=false)
function push_refspecs(rmt::GitRemote)
function push_testset(ts::AbstractTestSet)
function push_undo(s::PromptState, advance::Bool=true)
function push_url(rmt::GitRemote)
function pushdisplay(d::AbstractDisplay)
function pushfirst!(B::BitVector, item)
function pushfirst!(W::IntrusiveLinkedListSynchronized{T}, t::T) where T
function pushfirst!(a::Vector{T}, item) where T
function pushfirst!(q::IntrusiveLinkedList{T}, val::T) where T
function pushmeta!(ex::Expr, sym::Symbol, args::Any...)
function put!(c::Channel{T}, v) where T
function put_8x8_chunk(Bc::Vector{UInt64}, i1::Int, i2::Int, x::UInt64, m::Int, cgap::Int, cinc::Int, nc::Int, msk8::UInt64)
function put_buffered(c::Channel, v)
function put_unbuffered(c::Channel, v)
function qr(A::AbstractMatrix{T}, arg...; kwargs...) where T
function qr(v::AbstractVector)
function qrfactPivotedUnblocked!(A::AbstractMatrix)
function qrfactUnblocked!(A::AbstractMatrix{T}) where {T}
function query_override(hash::SHA1; overrides::Dict{Symbol,Any} = load_overrides)
function query_override(pkg::Base.UUID, artifact_name::String; overrides::Dict{Symbol,Any} = load_overrides)
function quickack(sock::Union{TCPServer, TCPSocket}, enable::Bool)
function radix_chunk_size_heuristic(lo::Integer, hi::Integer, bits::Unsigned)
function rand!(r::MersenneTwister, A1::Array{Bool}, sp::SamplerType{Bool})
function rand!(r::MersenneTwister, A::UnsafeView{UInt128}, ::SamplerType{UInt128})
function rand!(rd::RandomDevice, A::Array{Bool}, ::SamplerType{Bool})
function rand!(rng::AbstractRNG, A::AbstractArray{T}, sp::Sampler) where T
function rand!(rng::AbstractRNG, B::BitArray, ::SamplerType{Bool})
function rand!(rng::AbstractRNG, x::BigInt, sp::SamplerBigInt)
function rand!(rng::Union{TaskLocalRNG, Xoshiro}, dst::Array{Bool}, ::SamplerType{Bool})
function rand!(rng::Union{TaskLocalRNG, Xoshiro}, dst::Array{Float32}, ::SamplerTrivial{CloseOpen01{Float32}})
function rand!(rng::Union{TaskLocalRNG, Xoshiro}, dst::Array{Float64}, ::SamplerTrivial{CloseOpen01{Float64}})
function rand(r::AbstractRNG, ::SamplerType{T}) where {T<:AbstractChar}
function rand(r::MersenneTwister, ::SamplerTrivial{UInt104Raw{UInt128}})
function rand(r::MersenneTwister, ::SamplerTrivial{UInt2x52Raw{UInt128}})
function rand(r::MersenneTwister, x::SamplerTrivial{UInt52Raw{UInt64}})
function rand(rng::AbstractRNG, sp::LessThan)
function rand(rng::AbstractRNG, sp::SamplerRangeFast{UInt128,T}) where T
function rand(rng::AbstractRNG, sp::SamplerRangeFast{UInt32,T}) where T
function rand(rng::AbstractRNG, sp::SamplerRangeFast{UInt64,T}) where T
function rand(rng::AbstractRNG, sp::SamplerRangeInt{T,UInt128}) where T<:BitInteger
function rand(rng::AbstractRNG, sp::SamplerRangeInt{T,UInt64}) where T<:BitInteger
function rand(rng::AbstractRNG, sp::SamplerRangeNDL{U,T}) where {U,T}
function rand(rng::AbstractRNG, sp::SamplerSimple{<:AbstractString,<:Sampler})::Char
function rand(rng::AbstractRNG, sp::SamplerSimple{<:Dict,<:Sampler})
function rand(rng::AbstractRNG, sp::SamplerSimple{BitSet,<:Sampler})
function rand(rng::AbstractRNG, sp::SamplerSimple{Tuple{A,B,C}}) where {A,B,C}
function rand(rng::AbstractRNG, sp::SamplerTag{Ref{T}}) where T<:Tuple
function rand(rng::Union{TaskLocalRNG, Xoshiro}, ::SamplerType{UInt128})
function rand(x::Union{TaskLocalRNG, Xoshiro}, ::SamplerType{UInt64})
function randcycle!(r::AbstractRNG, a::Array{<:Integer})
function randjump(r::MersenneTwister, steps::Integer)
function randn(rng::AbstractRNG, ::Type{T}) where {T<:AbstractFloat}
function randn(rng::AbstractRNG=default_rng)
function randperm!(r::AbstractRNG, a::Array{<:Integer})
function randstring(r::AbstractRNG, chars=b, n::Integer=8)
function randsubseq!(r::AbstractRNG, S::AbstractArray, A::AbstractArray, p::Real)
function range_1dim(S::SharedArray, pidx)
function range_fuzztests(::Type{T}, niter, nrange) where {T}
function range_start_length(a, len::Integer)
function range_start_step_length(a, step, len::Integer)
function range_start_step_length(a::T, st::T, len::Integer) where T<:IEEEFloat
function range_start_stop_length(start::T, stop::T, len::Integer) where {T<:IEEEFloat}
function range_step_stop_length(step, a, len::Integer)
function range_step_stop_length(step::IEEEFloat, stop::IEEEFloat, len::Integer)
function range_stop_length(a, len::Integer)
function rationalize(::Type{T}, x::Integer; kvs...) where {T<:Integer}
function rationalize(::Type{T}, x::Union{AbstractFloat, Rational}, tol::Real) where T<:Integer
function raw!(t::TTYTerminal, raw::Bool)
function raw!(t::TTYTerminal,raw::Bool)
function rawcontent(blob::GitBlob)
function rcswap!(i::Integer, j::Integer, X::AbstractMatrix{<:Number})
function rdiv!(A::AbstractVecOrMat, B::LU)
function rdiv!(B::AbstractMatrix, C::Cholesky)
function rdiv!(B::AbstractMatrix, F::Hessenberg)
function rdiv!(B::AbstractMatrix, F::UpperHessenberg; shift::Number=false)
function rdiv!(B::AbstractVecOrMat{<:Complex}, F::Hessenberg{<:Complex,<:Any,<:AbstractMatrix{<:Real}})
function rdiv!(X::AbstractArray, s::Number)
function reachable_blocks(cfg::CFG, from_bb::Int, to_bb::Union{Nothing,Int} = nothing)
function read!(idx::GitIndex, force::Bool = false)
function read!(repo::GitRepo, force::Bool = false)
function read!(s::IO, A::AbstractArray{T}) where {T}
function read!(s::IO, A::StridedArray{T}) where {T}
function read!(s::IO, B::BitArray)
function read!(s::IO, x::Ref{T}) where {T}
function read(cmd::AbstractCmd)
function read(data::IO, ::Type{TermInfoRaw})
function read(f::File, ::Type{Char})
function read(f::File, ::Type{UInt8})
function read(from::GenericIOBuffer, ::Type{UInt8})
function read(from::GenericIOBuffer, T::Union{Type{Int16},Type{UInt16},Type{Int32},Type{UInt32},Type{Int64},Type{UInt64},Type{Int128},Type{UInt128},Type{Float16},Type{Float32},Type{Float64}})
function read(io::IO, ::Type{Char})
function read(io::SecretBuffer, ::Type{UInt8})
function read(s::BufferStream, ::Type{UInt8})
function read(s::IO, ::Type{Complex{T}}) where T<:Real
function read(s::IO, ::Type{Rational{T}}) where T<:Integer
function read(s::IO, T::Union{Type{Int16},Type{UInt16},Type{Int32},Type{UInt32},Type{Int64},Type{UInt64},Type{Int128},Type{UInt128},Type{Float16},Type{Float32},Type{Float64}})
function read(s::IO, nb::Integer = typemax(Int))
function read(s::IOStream)
function read(s::IOStream, ::Type{UInt8})
function read(s::IOStream, T::Union{Type{Int16},Type{UInt16},Type{Int32},Type{UInt32},Type{Int64},Type{UInt64}})
function read(s::IOStream, nb::Integer; all::Bool=true)
function read(stream::LibuvStream)
function read(this::LibuvStream, ::Type{UInt8})
function read_dependency_src(cachefile::String, filename::AbstractString)
function read_dependency_src(io::IO, cachefile::AbstractString, filename::AbstractString)
function read_sub(from::GenericIOBuffer, a::AbstractArray{T}, offs, nel) where T
function read_to_buffer(io::IO, buffer::Buffer)
function read_tree!(idx::GitIndex, tree::GitTree)
function read_until_end(pipe::Base64DecodePipe, ptr::Ptr{UInt8}, n::UInt)
function readavailable(s::IOStream)
function readavailable(this::LibuvStream)
function readbytes!(f::File, b::Array{UInt8}, nb=length(b))
function readbytes!(io::GenericIOBuffer, b::Array{UInt8}, nb::Int)
function readbytes!(s::IO, b::AbstractArray{UInt8}, nb=length(b))
function readbytes!(s::LibuvStream, a::Vector{UInt8}, nb::Int)
function readcb_specialized(stream::LibuvStream, nread::Int, nrequested::UInt)
function readchomperrors(exename::Cmd)
function readchomperrors(exename::Cmd)
function readdir(dir::AbstractString; join::Bool=false, sort::Bool=true)
function readheader(s::AbstractSerializer)
function readline(s::IOStream; keep::Bool=false)
function readlines(filename::AbstractString; kw...)
function readlink(path::AbstractString)
function readuntil(io::IO, target::AbstractVector{T}; keep::Bool=false) where T
function readuntil(s::BufferStream, c::UInt8; keep::Bool=false)
function readuntil(s::IOStream, delim::UInt8; keep::Bool=false)
function readuntil(stream::IO, delimiter; newlines = false, match = nothing)
function readuntil(x::LibuvStream, c::UInt8; keep::Bool=false)
function readuntil_string(s::IOStream, delim::UInt8, keep::Bool)
function readuntil_vector!(io::IO, target::AbstractVector{T}, keep::Bool, out) where {T}
function realpath(path::AbstractString)
function rebase!(repo::GitRepo, upstream::AbstractString="", newbase::AbstractString="")
function recompute_inst_flag(newinst::NewInstruction, src::Union{IRCode,IncrementalCompact})
function record(::FallbackTestSet, t::LogTestFailure)
function record(c::ContextTestSet, t::Fail)
function record(ts::DefaultTestSet, t::LogTestFailure)
function record(ts::DefaultTestSet, t::Union{Fail, Error}; print_result::Bool=TESTSET_PRINT_ENABLE[])
function record(ts::FallbackTestSet, t::Union{Fail, Error})
function record_bestguess!(sv::InferenceState)
function record_compiletime_preference(uuid::UUID, key::String)
function record_immutable_preserve!(new_preserves::Vector{Any}, def::Expr, compact::IncrementalCompact)
function record_slot_assign!(sv::InferenceState)
function recurse_dict!(l::Parser, d::Dict, dotted_keys::AbstractVector{String}, check=true)::Err{TOMLDict}
function recurse_package(name::String, names::String...)
function recurse_package(where::PkgId, name::String, names::String...)
function recursive_prefs_merge(base::Dict{String, Any}, overrides::Dict{String, Any}...)
function recv(sock::UDPSocket)
function recvfrom(sock::UDPSocket)
function reduce(::typeof(merge), items::Vector{<:Dict})
function reduce_shortest(f::T, maxsignif=nothing) where {T}
function reduced_indices(inds::Indices{N}, d::Int) where N
function reduced_indices(inds::Indices{N}, region) where N
function reduced_indices0(inds::Indices{N}, d::Int) where N
function reduced_indices0(inds::Indices{N}, region) where N
function reducedim_init(f, op::Union{typeof(*),typeof(mul_prod)}, A::AbstractArray, region)
function reducedim_init(f, op::Union{typeof(+),typeof(add_sum)}, A::AbstractArray, region)
function reducedim_init(f::ExtremaMap, op::typeof(_extrema_rf), A::AbstractArray, region)
function reenable_sigint(f::Function)
function ref_list(repo::GitRepo)
function refine_effects!(sv::PostOptAnalysisState)
function refine_new_effects!(ð•ƒâ‚’::AbstractLattice, compact::IncrementalCompact, idx::Int, stmt::Expr)
function refine_partial_struct2(xs::Union{Int,String,Symbol}...)
function reflect!(x::AbstractVector, y::AbstractVector, c, s)
function reflector!(x::AbstractVector{T}) where {T}
function reflectorApply!(x::AbstractVector, Ï„::Number, A::AbstractVecOrMat)
function refresh_multi_line(s::PromptState; kw...)
function refresh_multi_line(termbuf::TerminalBuffer, s::SearchState)
function refresh_multi_line(terminal::UnixTerminal, args...; kwargs...)
function reftype(ref::GitReference)
function register_finalizer!(obj::DoAllocWithFieldInter)
function register_restored_modules(sv::SimpleVector, pkg::PkgId, path::String)
function rehash!(d::IdDict, newsz = length(d.ht)%UInt)
function reinit!(p::Parser, str::String; filepath::Union{Nothing, String}=nothing)
function reinterpret(::Type{Out}, x) where {Out}
function reinterpret(::Type{T}, a::A) where {T,N,S,A<:AbstractArray{S, N}}
function reinterpret(::typeof(reshape), ::Type{T}, a::A) where {T,S,A<:AbstractArray{S}}
function reject(cache::CachedCredentials, cred::AbstractCredential, url::AbstractString)
function reject(cfg::GitConfig, cred::UserPasswordCredential, url::AbstractString)
function reject(p::CredentialPayload; shred::Bool=true)
function release(s::Semaphore)
function relockall(rl::ReentrantLock, n::UInt32)
function relpath(path::String, startpath::String = ".")
function rem(x, y, ::typeof(RoundFromZero))
function rem(x::BigFloat, y::BigFloat)
function rem(x::BigInt, ::Type{T}) where T<:Union{Base.BitUnsigned,Base.BitSigned}
function rem(x::Int128, y::Int128)
function rem(x::T, y::T) where {T<:IEEEFloat}
function rem(x::UInt128, y::UInt128)
function rem2pi(x::Int64, r::RoundingMode)
function rem_fast(x::T, y::T) where {T<:FloatTypes}
function rem_pio2_kernel(x::Float32)
function rem_pio2_kernel(x::Float64) 
function remote_delete(repo::GitRepo, remote_name::AbstractString)
function remotes(repo::GitRepo)
function remove!(idx::GitIndex, files::AbstractString...)
function remove!(repo::GitRepo, files::AbstractString...)
function remove_frames!(stack::StackTrace, m::Module)
function remove_frames!(stack::StackTrace, name::Symbol)
function remove_frames!(stack::StackTrace, names::Vector{Symbol})
function remove_linenums!(ex::Expr)
function remove_linenums!(src::CodeInfo)
function rename(src::AbstractString, dst::AbstractString; force::Bool=false)
function rename_incoming_edge(old_edge::Int, old_to::Int, result_order::Vector{Int}, bb_rename::Vector{Int})
function rename_nodes!(D::DFSTree, rename_bb::Vector{BBNumber})
function rename_nodes!(domtree::DomTree, rename_bb::Vector{BBNumber})
function rename_outgoing_edge(old_to::Int, old_from::Int, result_order::Vector{Int}, bb_rename::Vector{Int})
function rename_phinode_edges(node::PhiNode, bb::Int, result_order::Vector{Int}, bb_rename::Vector{Int})
function renumber_cfg_stmts!(cfg::CFG, blockchangemap::Vector{Int})
function renumber_ir_elements!(body::Vector{Any}, cfg::Union{CFG,Nothing}, ssachangemap::Vector{Int})
function renumber_ir_elements!(body::Vector{Any}, ssachangemap::Vector{Int}, labelchangemap::Vector{Int})
function renumber_ssa(stmt::SSAValue, ssanums::Vector{SSAValue}, new_ssa::Bool=false)
function repeat(A::AbstractArray, counts...)
function repeat(A::AbstractArray; inner = nothing, outer = nothing)
function repeat(c::AbstractChar, r::Integer)
function repeat(c::AnnotatedChar, r::Integer)
function repeat(s::Union{String, SubString{String}}, r::Integer)
function repeat(str::AnnotatedString, r::Integer)
function repeat_outer(a::AbstractMatrix, (m,n)::NTuple{2, Any})
function repeat_outer(a::AbstractVector, (m,)::Tuple{Any})
function repeat_outer(arr::AbstractArray{<:Any,N}, dims::NTuple{N,Any}) where {N}
function repl(io::IO, s::Symbol; brief::Bool=true, mod::Module=Main, internal_accesses::Union{Nothing, Set{Pair{Module,Symbol}}}=nothing)
function repl_backend_loop(backend::REPLBackend, get_module::Function)
function repl_corrections(io::IO, s, mod::Module)
function repl_latex(io::IO, s0::String)
function repl_search(io::IO, s::Union{Symbol,String}, mod::Module)
function replace(A, old_new::Pair...; count::Union{Integer,Nothing}=nothing)
function replace_code_newstyle!(ci::CodeInfo, ir::IRCode)
function replace_colon(A::AbstractArray, I)
function replace_depot_path(path::AbstractString)
function replace_in_print_matrix(S::SubArray{<:Any,1,<:AbstractVector}, i::Integer, j::Integer, s::AbstractString)
function replace_in_print_matrix(S::SubArray{<:Any,2,<:AbstractMatrix}, i::Integer, j::Integer, s::AbstractString)
function replace_line(s::PrefixSearchState, l::Union{String,SubString{String}})
function replace_line(s::PromptState, l::IOBuffer)
function replace_line(s::PromptState, l::Union{String,SubString{String}}, keep_undo::Bool=false)
function replace_linenums!(ex::Expr, ln::LineNumberNode)
function replace_pairs!(res, A, count::Int, old_new::Tuple{Vararg{Pair}})
function replace_with_centered_mark(s::AbstractString;c::AbstractChar = 'â‹…')
function replacefield!_tfunc(ð•ƒ::AbstractLattice, o, f, x, v)
function replacefield!_tfunc(ð•ƒ::AbstractLattice, o, f, x, v, success_order)
function replacefield!_tfunc(ð•ƒ::AbstractLattice, o, f, x, v, success_order, failure_order)
function replaceproperty!(x, f::Symbol, expected, desired, success_order::Symbol=:not_atomic, fail_order::Symbol=success_order)
function repository(idx::GitIndex)
function request(term::REPL.Terminals.TTYTerminal, m::AbstractMenu; cursor::Union{Int, Base.RefValue{Int}}=1, suppress_output=false)
function request(term::REPL.Terminals.TTYTerminal, msg::AbstractString, m::AbstractMenu; kwargs...)
function require(into::Module, mod::Symbol)
function reserve1(r::MersenneTwister, ::Type{T}) where T<:BitInteger
function reset!(p::CredentialPayload, config::GitConfig=p.config)
function reset!(repo::GitRepo, committish::AbstractString, pathspecs::AbstractString...)
function reset!(repo::GitRepo, obj::Union{GitObject, Nothing}, pathspecs::AbstractString...)
function reset!(s::Stateful{T,VS}, itr::T=s.itr) where {T,VS}
function reset(e::Event)
function reset(io::T) where T<:IO
function reset(repl::LineEditREPL)
function reset_caches!(r::MersenneTwister)
function reset_key_repeats(f::Function, s::MIState)
function reset_state(s::AbstractSerializer)
function reset_state(s::MIState)
function reset_state(s::PrefixSearchState)
function reset_state(s::PromptState)
function reset_state(s::SearchState)
function reseteof(x::TTY)
function reshape(B::BitArray{N}, dims::NTuple{N,Int}) where N
function reshape(a::SharedArray{T}, dims::NTuple{N,Int}) where {T,N}
function reshape(parent::AbstractArray, ndims::Val{N}) where N
function resize!(a::Vector, nl::Integer)
function resize!(compact::IncrementalCompact, nnewnodes::Int)
function resize!(stmts::InstructionStream, len)
function resize_nthreads!(A::AbstractVector, copyvalue=A[1])
function resolve(arr, inner, outer::Nothing)
function resolve(arr, inner::Nothing, outer)
function resolve(arr, inner::Nothing, outer::Nothing)
function resolve(arr::AbstractArray{<:Any, N}, inner::NTuple{N, Any}, outer::NTuple{N,Any}) where {N}
function resolve(new::Nothing, oldstream, mode)
function resolve(path::AbstractString, oldstream,mode)
function resolve_call_cycle!(interp::AbstractInterpreter, mi::MethodInstance, parent::AbsIntState)
function resolve_depot(includes::Union{AbstractVector,AbstractSet})
function resolve_toplevel_symbols!(src::Core.CodeInfo, mod::Module)
function resolvebinding(ex::Expr)
function resolvebinding(ex::GlobalRef)
function respond(f, repl, main; pass_empty::Bool = false, suppress_on_semicolon::Bool = true)
function rest(a::AbstractArray{T}, state...) where {T}
function restore(s::State, repo::GitRepo)
function restore_depot_path(path::AbstractString, depot::AbstractString)
function result_join(::S, ::T, ::U, ::V) where {S,T,U,V}
function result_style(s1::S, s2::S) where S<:BroadcastStyle
function retrieve_code_info(linfo::MethodInstance, world::UInt)
function retrieve_ir_for_inlining(::MethodInstance, ir::IRCode, preserve_local_sources::Bool=true)
function retrieve_ir_for_inlining(mi::MethodInstance, src::CodeInfo, preserve_local_sources::Bool=true)
function retrieve_ir_for_inlining(mi::MethodInstance, src::String, ::Bool=true)
function return_the_big_tuple(err::Bool)
function return_type(t::DataType)
function return_type(t::DataType, world::UInt)
function return_type_tfunc(interp::AbstractInterpreter, argtypes::Vector{Any}, si::StmtInfo, sv::AbsIntState)
function returntype(x::Int)::Int
function revcount(repo::GitRepo, commit1::AbstractString, commit2::AbstractString)
function reverse!(v::AbstractVector, start::Integer, stop::Integer=lastindex)
function reverse(A::AbstractVector, start::Integer, stop::Integer=lastindex)
function reverse(s::AnnotatedString)
function reverse(s::Union{String,SubString{String}})::String
function reverse(z::Zip)
function reverseind(a::AbstractVector, i::Integer)
function rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
function rmdynamic(spec::Spec{T}, args, argp) where {T}
function rmul!(A::AbstractMatrix, G::Givens)
function rmul!(A::AbstractMatrix, R::Rotation)
function rmul!(A::AbstractMatrix, adjR::AdjointRotation{<:Any,<:Rotation})
function rmul!(A::AbstractVecOrMat, Q::QRPackedQ)
function rmul!(A::AbstractVecOrMat, adjQ::AdjointQ{<:Any,<:QRPackedQ})
function rmul!(R::Rotation, G::Givens)
function rmul!(X::AbstractArray, s::Number)
function rmul_triu!(M::AbstractMatrix, x, k::Integer=0)
function robust_cdiv1(a::Float64, b::Float64, c::Float64, d::Float64)
function robust_cdiv2(a::Float64, b::Float64, c::Float64, d::Float64, r::Float64, t::Float64)
function robust_cinv(c::Float64, d::Float64)
function root_module(where::Module, name::Symbol)
function root_provenance(m::Method, i::Int)
function root_union!(s::IntDisjointSet{T}, x::T, y::T) where {T<:Integer}
function rot180(A::AbstractMatrix)
function rotate!(x::AbstractVector, y::AbstractVector, c, s)
function rotl90(A::AbstractMatrix)
function rotl90(A::AbstractMatrix, k::Integer)
function rotr90(A::AbstractMatrix)
function round(::Type{BigInt}, x::BigFloat, r::Union{RoundingMode, MPFRRoundingMode})
function round(::Type{T}, x::BigFloat, r::Union{RoundingMode, MPFRRoundingMode}) where T<:Union{Signed, Unsigned}
function round(::Type{T}, x::Rational{Bool}, ::RoundingMode=RoundNearest) where T
function round(::Type{T}, x::Rational{Tr}, r::RoundingMode=RoundNearest) where {T,Tr}
function round(z::Complex, rr::RoundingMode=RoundNearest, ri::RoundingMode=rr; kwargs...)
function rounds_away_from_zero(m::MPFRRoundingMode, sign_bit::Bool)
function rpm_provides(r::T) where T
function rst(io::IO, code::Code)
function rst(io::IO, content::Vector)
function rst(io::IO, f::Footnote)
function rst(io::IO, header::Header{l}) where l
function rst(io::IO, l::LaTeX)
function rst(io::IO, list::List)
function rst(io::IO, md::Admonition)
function rst(io::IO, md::HorizontalRule)
function rst(io::IO, md::Table)
function rst(io::IO, p::Paragraph)
function rst(io::IO, q::BlockQuote)
function rstinline(io::IO, md...)
function rstinline(io::IO, md::Link)
function rstrip(f, s::AbstractString)
function rstrip_shell(s::AbstractString)
function rtoldefault(x::Union{T,Type{T}}, y::Union{S,Type{S}}, atol::Real) where {T<:Number,S<:Number}
function rtruncto(str::String, w::Int)
function run!(helper::GitCredentialHelper, operation::AbstractString, cred::GitCredential)
function run(cmds::AbstractCmd, args...; wait::Bool = true)
function run(helper::GitCredentialHelper, operation::AbstractString, cred::GitCredential)
function run_extension_callbacks(extid::ExtensionId)
function run_extension_callbacks(pkgid::PkgId)
function run_frontend(repl::BasicREPL, backend::REPLBackendRef)
function run_frontend(repl::LineEditREPL, backend::REPLBackendRef)
function run_frontend(repl::StreamREPL, backend::REPLBackendRef)
function run_interface(terminal::TextTerminal, m::ModalInterface, s::MIState=init_state(terminal, m))
function run_main_repl(interactive::Bool, quiet::Bool, banner::Symbol, history_file::Bool, color_set::Bool)
function run_module_init(mod::Module, i::Int=1)
function run_package_callbacks(modkey::PkgId)
function runsubarraytests(A::Array, I...)
function runviews(SB::AbstractArray, indexN, indexNN, indexNNN)
function runviews(SB::AbstractArray{T, 3} where T, indexN, indexNN, indexNNN)
function runviews(SB::AbstractArray{T,1}, indexN, indexNN, indexNNN) where T
function runviews(SB::AbstractArray{T,2}, indexN, indexNN, indexNNN) where T
function same_path(x::AbstractString, y::AbstractString)
function samefile(a::StatStruct, b::StatStruct)
function sample(S, n::Real)
function scaleargs_cdiv(a::Float64, b::Float64, c::Float64, d::Float64, ab::Float64, cd::Float64)
function scaleinv(x::T) where T<:IEEEFloat
function scaling_cdiv(a::Float64, b::Float64, c::Float64, d::Float64, ab::Float64, cd::Float64)
function scan!(callback, scanner::BBScanner, forwards_only::Bool)
function scan_inconsistency!(inst::Instruction, idx::Int, sv::PostOptAnalysisState)
function scan_non_dataflow_flags!(inst::Instruction, sv::PostOptAnalysisState)
function scan_slot_def_use(nargs::Int, ci::CodeInfo, code::Vector{Any})
function schur!(A::StridedMatrix{T}, B::StridedMatrix{T}) where {T<:BlasFloat}
function schur(A::AbstractMatrix{TA}, B::AbstractMatrix{TB}) where {TA,TB}
function schur(A::Bidiagonal{T}) where {T}
function schur(A::RealHermSymComplexHerm)
function schur(A::Union{UnitLowerTriangular{T},LowerTriangular{T}}) where {T}
function schur(A::Union{UnitUpperTriangular{T},UpperTriangular{T}}) where {T}
function schurpow(A::AbstractMatrix, p)
function searchsorted(v::AbstractVector, x, ilo::T, ihi::T, o::Ordering)::UnitRange{keytype(v)} where T<:Integer
function searchsorted(v::AbstractVector, x, ilo::T, ihi::T, o::Ordering)::UnitRange{keytype(v)} where T<:Integer
function searchsortedfirst(a::AbstractRange{<:Integer}, x::Real, o::FastRangeOrderings)::keytype(a)
function searchsortedfirst(a::AbstractRange{<:Real}, x::Real, o::FastRangeOrderings)::keytype(a)
function searchsortedfirst(v::AbstractVector, x, lo::T, hi::T, o::Ordering)::keytype(v) where T<:Integer
function searchsortedfirst(v::AbstractVector, x, lo::T, hi::T, o::Ordering)::keytype(v) where T<:Integer
function searchsortedlast(a::AbstractRange{<:Integer}, x::Real, o::FastRangeOrderings)::keytype(a)
function searchsortedlast(a::AbstractRange{<:Real}, x::Real, o::FastRangeOrderings)::keytype(a)
function searchsortedlast(v::AbstractVector, x, lo::T, hi::T, o::Ordering)::keytype(v) where T<:Integer
function searchsortedlast(v::AbstractVector, x, lo::T, hi::T, o::Ordering)::keytype(v) where T<:Integer
function seed!(rng::Union{TaskLocalRNG, Xoshiro}, ::Nothing)
function seek(f::File, n::Integer)
function seek(io::GenericIOBuffer, n::Integer)
function seek(s::IOStream, n::Integer)
function seekend(f::File)
function seekend(io::GenericIOBuffer)
function seekend(s::IOStream)
function segfaultfunction_20847(A::Vector{NTuple{N, T}}) where {N, T}
function selectpivot!(v::AbstractVector, lo::Integer, hi::Integer, o::Ordering)
function send(sock::UDPSocket, ipaddr::IPAddr, port::Integer, msg)
function send_to_end!(f::F, v::AbstractVector; lo=firstindex(v), hi=lastindex(v)) where F <: Function
function sendfile(dst::File, src::File, src_offset::Int64, bytes::Int)
function sendfile(src::AbstractString, dst::AbstractString)
function serialize(s::AbstractSerializer, S::SharedArray)
function serialize(s::AbstractSerializer, a::Array)
function serialize(s::AbstractSerializer, a::SubArray{T,N,A}) where {T,N,A<:Array}
function serialize(s::AbstractSerializer, cond::Base.GenericCondition)
function serialize(s::AbstractSerializer, d::Dict)
function serialize(s::AbstractSerializer, d::IdDict)
function serialize(s::AbstractSerializer, ex::Expr)
function serialize(s::AbstractSerializer, frame::Base.StackTraces.StackFrame)
function serialize(s::AbstractSerializer, g::GlobalRef)
function serialize(s::AbstractSerializer, linfo::Core.MethodInstance)
function serialize(s::AbstractSerializer, lock::Base.AbstractLock)
function serialize(s::AbstractSerializer, m::Memory)
function serialize(s::AbstractSerializer, m::Module)
function serialize(s::AbstractSerializer, meth::Method)
function serialize(s::AbstractSerializer, n::BigInt)
function serialize(s::AbstractSerializer, n::Int32)
function serialize(s::AbstractSerializer, n::Int64)
function serialize(s::AbstractSerializer, r::Regex)
function serialize(s::AbstractSerializer, ss::String)
function serialize(s::AbstractSerializer, ss::SubString{String})
function serialize(s::AbstractSerializer, t::Core.TypeName)
function serialize(s::AbstractSerializer, t::DataType)
function serialize(s::AbstractSerializer, t::Task)
function serialize(s::AbstractSerializer, t::Tuple)
function serialize(s::AbstractSerializer, u::UnionAll)
function serialize(s::AbstractSerializer, v::SimpleVector)
function serialize(s::AbstractSerializer, x::Core.AddrSpace)
function serialize(s::AbstractSerializer, x::GenericMemoryRef)
function serialize(s::AbstractSerializer, x::Symbol)
function serialize(s::IO, x)
function serialize_array_data(s::IO, a)
function serialize_dict_data(s::AbstractSerializer, d::AbstractDict)
function serialize_mod_names(s::AbstractSerializer, m::Module)
function serialize_typename(s::AbstractSerializer, t::Core.TypeName)
function set!(c::GitConfig, name::AbstractString, value::AbstractString)
function set!(c::GitConfig, name::AbstractString, value::Bool)
function set!(c::GitConfig, name::AbstractString, value::Int32)
function set!(c::GitConfig, name::AbstractString, value::Int64)
function set!(trie::HAMT, bi::BitmapIndex)
function set!(z::Rational{BigInt}, x::Rational{BigInt})
function set_action!(s::MIState, command::Symbol)
function set_active_project(projfile::Union{AbstractString,Nothing})
function set_aux_root(n :: Int, x :: String)
function set_compare_strategy!(p::Platform, key::String, f::Function)
function set_curr_ssaflag!(sv::IRInterpretationState, flag::UInt32, mask::UInt32=typemax(UInt32))
function set_curr_ssaflag!(sv::InferenceState, flag::UInt32, mask::UInt32=typemax(UInt32))
function set_num_threads(::Nothing)
function set_output_prefix(repl::LineEditREPL, n::Ref{Int})
function set_pkgorigin_version_path(pkg::PkgId, path::Union{String,Nothing})
function set_process_title(title::AbstractString)
function set_prompt(repl::LineEditREPL, n::Ref{Int})
function set_remote_fetch_url(path::AbstractString, remote_name::AbstractString, url::AbstractString)
function set_remote_fetch_url(repo::GitRepo, remote_name::AbstractString, url::AbstractString)
function set_remote_push_url(path::AbstractString, remote_name::AbstractString, url::AbstractString)
function set_remote_push_url(repo::GitRepo, remote_name::AbstractString, url::AbstractString)
function set_remote_url(path::AbstractString, remote_name::AbstractString, url::AbstractString)
function set_remote_url(repo::GitRepo, remote_name::AbstractString, url::AbstractString)
function set_z!(z::Rational{BigInt}, x::BigInt)
function setdiff!(s::AbstractSet, itr)
function setdiff!(s::AbstractSet, itrs...)
function setdiff!(s::Set, t::Set)
function setextheader(stream::IO, md::MD)
function setfield!_nothrow(ð•ƒ::AbstractLattice, s00, name, v)
function setfield!_nothrow(ð•ƒ::AbstractLattice, s00, name, v, order)
function setfield!_tfunc(ð•ƒ::AbstractLattice, o, f, v)
function setfield!_tfunc(ð•ƒ::AbstractLattice, o, f, v, order)
function setglobal!_tfunc(ð•ƒ::AbstractLattice, M, s, v, order=Symbol)
function setindex!(A::AbstractArray, v, I...)
function setindex!(A::Array, X::AbstractArray, I::AbstractVector{Int})
function setindex!(A::Array{T}, X::Array{T}, I::AbstractUnitRange{Int}) where T
function setindex!(A::Array{T}, X::Array{T}, c::Colon) where T
function setindex!(A::Array{T}, x, i1::Int, i2::Int, I::Int...) where {T}
function setindex!(A::Array{T}, x, i::Int) where {T}
function setindex!(A::Bidiagonal, x, i::Integer, j::Integer)
function setindex!(A::Hermitian, v, i::Integer, j::Integer)
function setindex!(A::LowerTriangular, x, i::Integer, j::Integer)
function setindex!(A::Memory{T}, X::Memory{T}, I::AbstractUnitRange{Int}) where T
function setindex!(A::Memory{T}, X::Memory{T}, c::Colon) where T
function setindex!(A::Memory{T}, x, i1::Int) where {T}
function setindex!(A::Memory{T}, x, i1::Int, i2::Int, I::Int...) where {T}
function setindex!(A::ReshapedArray, val, index::ReshapedIndex)
function setindex!(A::ReshapedArrayLF, val, index::Int)
function setindex!(A::ReshapedArray{T,N}, val, indices::Vararg{Int,N}) where {T,N}
function setindex!(A::SymTridiagonal, x, i::Integer, j::Integer)
function setindex!(A::Symmetric, v, i::Integer, j::Integer)
function setindex!(A::Tridiagonal, x, i::Integer, j::Integer)
function setindex!(A::UnitLowerTriangular, x, i::Integer, j::Integer)
function setindex!(A::UnitUpperTriangular, x, i::Integer, j::Integer)
function setindex!(A::UpperHessenberg, x, i::Integer, j::Integer)
function setindex!(A::UpperTriangular, x, i::Integer, j::Integer)
function setindex!(B::BitArray, X::AbstractArray, I::BitArray)
function setindex!(B::BitArray, X::Union{StridedArray,BitArray}, J0::Union{Colon,AbstractUnitRange{Int}})
function setindex!(B::BitArray, x, i::Int)
function setindex!(D::Diagonal, v, i::Int, j::Int)
function setindex!(V::FastContiguousSubArray, x, i::Int)
function setindex!(V::FastContiguousSubArray{<:Any, 1}, x, i::Int)
function setindex!(V::FastSubArray, x, i::Int)
function setindex!(V::FastSubArray{<:Any, 1}, x, i::Int)
function setindex!(V::SubArray{T,N}, x, I::Vararg{Int,N}) where {T,N}
function setindex!(cache::InternalCodeCache, ci::CodeInstance, mi::MethodInstance)
function setindex!(h::Dict{K,Any}, v, key::K) where K
function setindex!(h::Dict{K,V}, v0, key0) where V where K
function setindex!(h::Dict{K,V}, v0, key::K) where V where K
function setindex!(is::InstructionStream, newval::Instruction, idx::Int)
function setindex!(is::InstructionStream, newval::Union{AnySSAValue, Nothing}, idx::Int)
function setindex!(node::Instruction, newval::Instruction)
function setindex!(s::Slices{P,SM,AX,S,N}, val, I::Vararg{Int,N}) where {P,SM,AX,S,N}
function setindex!(wkh::WeakKeyDict{K}, v, key) where K
function setindex!(wvc::WorldView{InternalCodeCache}, ci::CodeInstance, mi::MethodInstance)
function setindex!(x::IRCode, repl::Union{Instruction, Nothing, AnySSAValue}, s::SSAValue)
function setindex(nt::NamedTuple, v, idx::Symbol)
function setindex(x::Tuple, v, i::Integer)
function setindex_shape_check(X::AbstractArray, I::Integer...)
function setindex_shape_check(X::AbstractArray{<:Any,2}, i::Integer, j::Integer)
function setindex_widen_up_to(dest::AbstractArray{T}, el, i) where T
function setmark(s::MIState, guess_region_active::Bool=true)
function setopt(sock::UDPSocket; multicast_loop=nothing, multicast_ttl=nothing, enable_broadcast=nothing, ttl=nothing)
function setprecision(::Type{BigFloat}, precision::Integer; base::Integer=2)
function setprecision(f::Function, ::Type{T}, prec::Integer; kws...) where T
function setproperty!(ci::CodeInfo, s::Symbol, v)
function setproperty!(x, f::Symbol, v)
function setproperty!(x, f::Symbol, v, order::Symbol)
function setproperty!(x::Module, f::Symbol, v, order::Symbol=:monotonic)
function setrounding(f::Function, ::Type{T}, rounding::RoundingMode) where T
function setrounding_raw(f::Function, ::Type{T}, rounding) where T
function setstate!(x::TaskLocalRNG, (s0, s1, s2, s3, s4))
function setstate!(x::Xoshiro, (s0, s1, s2, s3, s4))
function settings(s::RawFD, shared::Bool)
function setup_clone_repo(cache_repo::AbstractString, path::AbstractString; name, email)
function setup_prefix_keymap(hp::HistoryProvider, parent_prompt::Prompt)
function setup_stdio(stdio::FileRedirect, child_readable::Bool)
function setup_stdio(stdio::IO, child_readable::Bool)
function setup_stdio(stdio::IOStream, child_readable::Bool)
function setup_stdio(stdio::Pipe, child_readable::Bool)
function setup_stdio(stdio::PipeEndpoint, child_readable::Bool)
function setup_stdios(f, stdios::SpawnIOs)
function shell_escape_csh(io::IO, args::AbstractString...)
function shell_escape_wincmd(io::IO, s::AbstractString)
function shell_split(s::AbstractString)
function shift_tab_completion(s::MIState)
function shmem_rand(TR::Union{DataType, UnitRange}, dims; kwargs...)
function short_path(spath::Symbol, filenamecache::Dict{Symbol, String})
function shortname(ref::GitReference)
function should_infer_for_effects(sv::InferenceState)
function should_infer_this_call(interp::AbstractInterpreter, sv::InferenceState)
function should_insert_coverage(mod::Module, src::CodeInfo)
function should_send_whole_type(s, t::DataType)
function show(io::IO, ::EnvDict)
function show(io::IO, ::MIME, m::Method)
function show(io::IO, ::MIME md::MD)
function show(io::IO, ::MIME, J::UniformScaling)
function show(io::IO, ::MIME, X::AbstractArray)
function show(io::IO, ::MIME, c::Channel)
function show(io::IO, ::MIME, c::T) where {T<:AbstractChar}
function show(io::IO, ::MIME, f::Function)
function show(io::IO, ::MIME, iter::Union{KeySet,ValueIterator})
function show(io::IO, ::MIME, oc::Core.OpaqueClosure{A, R}) where {A, R}
function show(io::IO, ::MIME, opt::JLOptions)
function show(io::IO, ::MIME, r::LinRange)
function show(io::IO, ::MIME, stack::ExceptionStack)
function show(io::IO, ::MIME, t::AbstractDict{K,V}) where {K,V}
function show(io::IO, ::MIME, t::AbstractSet{T}) where T
function show(io::IO, ::MIME, t::Task)
function show(io::IO, ::MIME, ti::TermInfo)
function show(io::IO, ::MIME, u::UndefInitializer)
function show(io::IO, ::MIME, x::Irrational{sym}) where {sym}
function show(io::IO, M::Bidiagonal)
function show(io::IO, S::SharedArray)
function show(io::IO, X::AbstractArray)
function show(io::IO, addr::InetAddr)
function show(io::IO, b::BigFloat)
function show(io::IO, c::AbstractChar)
function show(io::IO, c::ComposedFunction)
function show(io::IO, c::ComposedFunction{typeof(!)})
function show(io::IO, cf::CacheFlags)
function show(io::IO, cmd::Cmd)
function show(io::IO, cmds::AndCmds)
function show(io::IO, cmds::Union{OrCmds,ErrOrCmds})
function show(io::IO, cr::CmdRedirect)
function show(io::IO, e::Iterators.Enumerate)
function show(io::IO, err::DNSError)
function show(io::IO, ex::PrecompilableError)
function show(io::IO, f::Core.IntrinsicFunction)
function show(io::IO, frame::StackFrame)
function show(io::IO, inferred::Core.Compiler.InferenceResult)
function show(io::IO, ip::InterpreterIP)
function show(io::IO, it::ImageTarget)
function show(io::IO, iter::CartesianIndices)
function show(io::IO, level::LogLevel)
function show(io::IO, m::Module)
function show(io::IO, m::RegexMatch)
function show(io::IO, mi_info::Core.Compiler.Timings.InferenceFrameInfo)
function show(io::IO, mime::MIME, ms::MethodList)
function show(io::IO, mime::MIME, mt::AbstractVector{Method})
function show(io::IO, mime::MIME, F::Hessenberg)
function show(io::IO, mime::MIME, S::SharedArray)
function show(io::IO, mime::MIME, mt::AbstractVector{Method})
function show(io::IO, oc::Core.OpaqueClosure)
function show(io::IO, opt::JLOptions)
function show(io::IO, p::Pair)
function show(io::IO, r::LinRange{T}) where {T}
function show(io::IO, r::StepRangeLen)
function show(io::IO, r::StepRangeLen{<:CartesianIndex})
function show(io::IO, re::Regex)
function show(io::IO, rng::MersenneTwister)
function show(io::IO, s::BitSet)
function show(io::IO, s::MIState)
function show(io::IO, s::PrefixSearchState)
function show(io::IO, s::Set)
function show(io::IO, s::SkipMissing)
function show(io::IO, s::SubstitutionString)
function show(io::IO, src::CodeInfo; debuginfo::Symbol=:source)
function show(io::IO, t::AbstractDict{K,V}) where V where K
function show(io::IO, t::NamedTuple)
function show(io::IO, t::Task)
function show(io::IO, tinf::Core.Compiler.Timings.Timing)
function show(io::IO, tn::Core.TypeName)
function show(io::IO, tv::TypeVar)
function show(io::IO, vm::Core.TypeofVararg)
function show(io::IO, x::Rational)
function show(io::IO, x::Some)
function show(io::IO, z::Complex)
function show_at_namedtuple(io::IO, syms::Tuple, types::DataType)
function show_backtrace(io::IO, t::Vector)
function show_block(io::IO, head, arg, block, i::Int, quote_level::Int)
function show_block(io::IO, head, args::Vector, body, indent::Int, quote_level::Int)
function show_call(io::IO, head, func, func_args, indent, quote_level, kw::Bool)
function show_can_elide(p::TypeVar, wheres::Vector, elide::Int, env::SimpleVector, skip::Int)
function show_completions(s::PromptState, completions::Vector{String})
function show_convert_error(io::IO, ex::MethodError, arg_types_param)
function show_datatype(io::IO, x::DataType, wheres::Vector{TypeVar}=TypeVar[])
function show_delim_array(io::IO, itr, op, delim, cl, delim_one, i1=1, n=typemax(Int))
function show_enclosed_list(io::IO, op, items, sep, cl, indent, prec=0, quote_level=0, encl_ops=false, kw::Bool=false)
function show_exception_stack(io::IO, stack)
function show_full_backtrace(io::IO, trace::Vector; print_linebreaks::Bool)
function show_function(io::IO, f::Function, compact::Bool, fallback::Function)
function show_generator(io, ex::Expr, indent, quote_level)
function show_globalref(io::IO, ex::GlobalRef; allow_macroname=false)
function show_import_path(io::IO, ex, quote_level)
function show_invalid(io::IO, c::Char)
function show_ir(io::IO, ci::CodeInfo, config::IRShowConfig=default_config(ci);
function show_ir(io::IO, compact::IncrementalCompact, config::IRShowConfig=default_config(compact.ir))
function show_ir(io::IO, ir::IRCode, config::IRShowConfig=default_config(ir);
function show_method(io::IO, m::Method; modulecolor = :light_black, digit_align_width = 1)
function show_method_list_header(io::IO, ms::MethodList, namefmt::Function)
function show_method_params(io::IO, tv)
function show_method_table(io::IO, ms::MethodList, max::Int=-1, header::Bool=true)
function show_mi(io::IO, l::Core.MethodInstance, from_stackframe::Bool=false)
function show_pairtyped(io::IO, p::Pair{K,V}) where {K,V}
function show_reduced_backtrace(io::IO, t::Vector)
function show_sexpr(io::IO, ex::Expr, indent::Int)
function show_sexpr(io::IO, ex::QuoteNode, indent::Int)
function show_spec_linfo(io::IO, frame::StackFrame)
function show_statstruct(io::IO, st::StatStruct, oneline::Bool)
function show_supertypes(io::IO, typ::DataType)
function show_sym(io::IO, sym::Symbol; allow_macroname=false)
function show_task_exception(io::IO, t::Task; indent = true)
function show_type_name(io::IO, tn::Core.TypeName)
function show_typealias(io::IO, name::GlobalRef, x::Type, env::SimpleVector, wheres::Vector)
function show_typeparams(io::IO, env::SimpleVector, orig::SimpleVector, wheres::Vector)
function show_unionaliases(io::IO, x::Union)
function show_unquoted(io::IO, ex::Expr, indent::Int, prec::Int, quote_level::Int = 0)
function show_unquoted(io::IO, ex::QuoteNode, indent::Int, prec::Int)
function show_unquoted(io::IO, ex::SlotNumber, ::Int, ::Int)
function show_unquoted(io::IO, stmt::PhiCNode, indent::Int, ::Int)
function show_unquoted(io::IO, stmt::PiNode, indent::Int, ::Int)
function show_unquoted(io::IO, stmt::ReturnNode, indent::Int, ::Int)
function show_unquoted(io::IO, stmt::UpsilonNode, indent::Int, ::Int)
function show_unquoted(io::IO, val::SSAValue, ::Int, ::Int)
function show_unquoted(io::IO, z::Complex, ::Int, prec::Int)
function show_unquoted_expr_fallback(io::IO, ex::Expr, indent::Int, quote_level::Int)
function show_unquoted_gotoifnot(io::IO, stmt::GotoIfNot, indent::Int, prefix::String)
function show_unquoted_phinode(io::IO, stmt::PhiNode, indent::Int, prefix::String)
function show_vector(io::IO, v, opn='[', cls=']')
function show_wheres(io::IO, wheres::Vector{TypeVar})
function show_zero_dim(io::IO, X::AbstractArray{T, 0}) where T
function showarg(io::IO, T::Type, toplevel)
function showarg(io::IO, a::Array{Union{}}, toplevel)
function showarg(io::IO, r::NonReshapedReinterpretArray{T}, toplevel) where {T}
function showarg(io::IO, r::ReshapedArray, toplevel)
function showarg(io::IO, r::ReshapedReinterpretArray{T}, toplevel) where {T}
function showarg(io::IO, v::SubArray, toplevel)
function showerror(io::IO, ce::CapturedException)
function showerror(io::IO, err::ProcessFailedException)
function showerror(io::IO, ex, bt; backtrace=true)
function showerror(io::IO, ex::BoundsError)
function showerror(io::IO, ex::CanonicalIndexError)
function showerror(io::IO, ex::CompositeException)
function showerror(io::IO, ex::DomainError)
function showerror(io::IO, ex::ErrorException)
function showerror(io::IO, ex::InexactError)
function showerror(io::IO, ex::InitError, bt; backtrace=true)
function showerror(io::IO, ex::LoadError, bt; backtrace=true)
function showerror(io::IO, ex::Meta.ParseError)
function showerror(io::IO, ex::MethodError)
function showerror(io::IO, ex::ScheduledAfterSyncException)
function showerror(io::IO, ex::SystemError)
function showerror(io::IO, ex::TaskFailedException, bt = nothing; backtrace=true)
function showerror(io::IO, ex::TypeError)
function showerror(io::IO, ex::UndefVarError)
function showerror(io::IO, p::PaddingError)
function showerror_ambiguous(io::IO, meths, f, args)
function showerror_nostdio(err, msg::AbstractString)
function showrest(io::IO)
function showvalue(io, e::Tuple{Exception,Any})
function shred!(f::Function, x)
function shred!(s::SecretBuffer)
function shuffle!(r::AbstractRNG, a::AbstractArray)
function sign(x::BigFloat)
function sign(x::BigInt)
function signature!(tv::Vector{Any}, expr::Expr)
function significand(x::BigFloat)
function significand(x::T) where T<:IEEEFloat
function simd_outer_range(iter::CartesianIndices)
function simd_outer_range(iter::CartesianPartition)
function simd_outer_range(iter::CartesianPartition{CartesianIndex{2}})
function similar(A::Hermitian, ::Type{T}) where T
function simple_dce!(callback::Function, compact::IncrementalCompact)
function simulate_input(menu::TerminalMenus.AbstractMenu, keys...; kwargs...)
function sin(A::AbstractMatrix{<:Complex})
function sin(A::AbstractMatrix{<:Real})
function sin(x::T) where T<:Union{Float32, Float64}
function sin(z::Complex{T}) where T
function sin_kernel(y::DoubleFloat32)
function sin_kernel(y::DoubleFloat64)
function sin_kernel(y::Float64)
function sincos(A::AbstractMatrix{<:Complex})
function sincos(A::AbstractMatrix{<:Real})
function sincos(A::HermOrSym{<:Real})
function sincos(A::Hermitian{<:Complex})
function sincos(x::T) where T<:Union{Float32, Float64}
function sincos_fast(v::BigFloat)
function sincos_fast(v::Float16)
function sincospi(_x::T) where T<:IEEEFloat
function sincospi(z::Complex{T}) where T
function sind(x::Real)
function single_stride_dim(A::Array)
function sinh(A::AbstractMatrix)
function sinh(x::T) where T<:Union{Float32,Float64}
function sinh(z::Complex)
function sinh16_kernel(x::Float32)
function sinh_kernel(x::Float32)
function sinh_kernel(x::Float64)
function sinpi(_x::T) where T<:IEEEFloat
function sinpi(z::Complex{T}) where T
function sinpi_kernel(x::Float16)
function sinpi_kernel(x::Float32)
function sinpi_kernel(x::Float64)
function sinpi_kernel_wide(x::Float16)
function sinpi_kernel_wide(x::Float32)
function sinpi_kernel_wide(x::Float64)
function size(B::BitVector, d::Integer)
function size(Q::AbstractQ, dim::Integer)
function size(a::Array, d::Int)
function size(a::NonReshapedReinterpretArray{T,N,S} where {N}) where {T,S}
function size(a::ReshapedReinterpretArray{T,N,S} where {N}) where {T,S}
function size(stack :: Stack)
function sizehint!(B::BitVector, sz::Integer)
function sizehint!(a::Vector, sz::Integer; shrink::Bool = true)
function sizehint!(d::Dict{T}, newsz; shrink::Bool = true) where T
function sizehint!(d::IdDict, newsz)
function sizeof_tfunc(ð•ƒ::AbstractLattice, x)
function skip(f::File, n::Integer)
function skip(io::GenericIOBuffer, n::Integer)
function skip(s::IOStream, delta::Integer)
function skip_comment(l::Parser)::Bool
function skip_deleted(h::Dict, i)
function skip_deleted_floor!(h::Dict)
function skip_len_I(I::CartesianIndex{1})
function skip_len_I(i::Int, I::CartesianIndex)
function skip_ws_nl(l::Parser)::Bool
function skipblank(io::IO)
function skipchars(predicate, io::IO; linecomment=nothing)
function skipwhitespace(io::IO; newlines = true)
function sleep(sec::Real)
function slot2reg(ir::IRCode, ci::CodeInfo, sv::OptimizationState)
function slug(x::UInt32, p::Int)
function smerge(lattice::AbstractLattice, sa::Union{NotFound,VarState}, sb::Union{NotFound,VarState})
function snapshot(repo::GitRepo)
function sort!(v::AbstractVector, lo::Integer, hi::Integer, a::Algorithm, o::Ordering)
function sort!(v::AbstractVector, lo::Integer, hi::Integer, a::Algorithm, o::Ordering, scratch::Vector)
function sort!(v::AbstractVector, lo::Integer, hi::Integer, a::QuickSortAlg, o::Ordering)
function sort!(v::Vector; by::Function=identity, (<)::Function=<)
function sort_chunks!(Av, n, alg, order, scratch::AbstractVector, fst, lst)
function sort_chunks!(Av, n, alg, order, scratch::Nothing, fst, lst)
function sortdefs(m1::Method, m2::Method)
function sorteig!(Î»::AbstractVector, X::AbstractMatrix, sortby::Union{Function,Nothing}=eigsortby)
function sortperm_int_range(x::Vector{<:Integer}, rangelen, minval)
function sortslices(A::AbstractArray; dims::Union{Integer, Tuple{Vararg{Integer}}}, kws...)
function source_path(default::Union{AbstractString,Nothing}="")
function sourceinfo_slotnames(slotnames::Vector{Symbol})
function sp_innersig(x::T) where {T}
function specialize_method(match::MethodMatch; kwargs...)
function splace(in::String, p = 0.3)
function splice!(B::BitVector, i::Integer)
function splice!(B::BitVector, r::Union{AbstractUnitRange{Int}, Integer}, ins)
function splice!(B::BitVector, r::Union{AbstractUnitRange{Int}, Integer}, ins::AbstractArray = _default_bit_splice)
function splice!(a::Vector, i::Integer, ins=_default_splice)
function splice!(a::Vector, r::AbstractUnitRange{<:Integer}, ins=_default_splice)
function split(I::CartesianIndex, V::Val)
function split(R::CartesianIndices, V::Val)
function split(t, V::Val)
function split_artifact_slash(name::String)
function split_cfg_entry(ce::ConfigEntry)
function split_rest(itr, n::Int, state...)
function splitbits(x::Float64)
function splitdir(path::String)
function splitdrive(path::String)
function splitenv(e::String)
function splitexpr(x::Expr)
function splitext(path::String)
function splitpath(p::String)
function splitprec(::Type{F}, i::Integer) where {F<:AbstractFloat}
function sprint(f::Function, args...; context=nothing, sizehint::Integer=0)
function sptypes_from_meth_instance(linfo::MethodInstance)
function sqrmod!(f::GF2X, m::GF2X)::GF2X
function sqrt(A::AbstractMatrix{T}) where {T<:Union{Real,Complex}}
function sqrt(A::UnitUpperTriangular{T}) where T
function sqrt(x::BigFloat)
function sqrt(x::Union{Float32,Float64})
function sqrt(z::Complex)
function sqrt_diag!(A0::UpperTriangular, A::UpperTriangular, s)
function srand(seed::Integer=_make_uint64_seed)
function srctext_files(f::IO, srctextpos::Int64, includes::Vector{CacheHeaderIncludes})
function sroa_mutables!(ir::IRCode, defuses::IdDict{Int, Tuple{SPCSet, SSADefUse}}, used_ssas::Vector{Int}, lazydomtree::LazyDomtree, inlining::Union{Nothing, InliningState})
function sroa_pass!(ir::IRCode, inlining::Union{Nothing,InliningState}=nothing)
function ssa_inlining_pass!(ir::IRCode, state::InliningState, propagate_inbounds::Bool)
function ssqs(x::T, y::T) where T<:Real
function stage(ie::IndexEntry)
function stale_pidfile(path::String, stale_age::Real, refresh::Real)
function start( sample_rate::Real)
function start_loading(modkey::PkgId)
function start_reading(stream::LibuvStream)
function start_watching(t::FileMonitor)
function start_watching(t::PollingFileWatcher)
function start_watching(t::_FDWatcher)
function startswith(a::AbstractString, b::AbstractString)
function startswith(s::AbstractString, r::Regex)
function startswith(s::SubString{String}, r::Regex)
function startswith(stream::IO, c::AbstractChar; eat = true)
function startswith(stream::IO, r::Regex; eat = true, padding = false)
function startswith(stream::IO, s::AbstractString; eat = true, padding = false, newlines = true)
function startswith(stream::IO, ss::Vector{<:AbstractString}; kws...)
function startup(l::Parser)
function statement_costs!(cost::Vector{Int}, body::Vector{Any}, src::Union{CodeInfo, IRCode}, sptypes::Vector{VarState}, params::OptimizationParams)
function statement_indices_to_labels(stmt, cfg::CFG)
function statementidx_lineinfo_printer(f, code::CodeInfo)
function statementidx_lineinfo_printer(f, code::IRCode)
function status(repo::GitRepo, path::String)
function steprange_last(start, step, stop)::typeof(stop)
function steprange_last_empty(start::Integer, step, stop)::typeof(stop)
function stmt_taints_inbounds_consistency(sv::AbsIntState)
function stmts_awaiting_insertion(compact::IncrementalCompact, idx::Int)
function stmts_used(::IO, code::CodeInfo)
function stmts_used(io::IO, code::IRCode, warn_unset_entry=true)
function stop_reading(stream::LibuvStream)
function stop_reading(stream::LibuvStream)
function stop_watching(t::FileMonitor)
function stop_watching(t::PollingFileWatcher)
function store_backedges(caller::InferenceResult, edges::Vector{Any})
function store_backedges(caller::MethodInstance, edges::Vector{Any})
function stoverwrite!(state::VarTable, newstate::VarTable)
function stoverwrite1!(state::VarTable, change::StateUpdate)
function strcat(x::String, y::String)
function strftime(fmt::AbstractString, tm::TmStruct)
function stride(A::AbstractArray, k::Integer)
function strides(a::ReinterpretArray{T,<:Any,S,<:AbstractArray{S},IsReshaped}) where {T,S,IsReshaped}
function strides(a::ReshapedArray)
function string(n::BigInt; base::Integer = 10, pad::Integer = 1)
function string(n::Integer; base::Integer = 10, pad::Integer = 1)
function string(u::UUID)
function string_distance(a::AbstractString, lena::Integer, b::AbstractString, lenb::Integer)
function string_mpfr(x::BigFloat, fmt::String)
function strip_trailing_junk!(ci::CodeInfo, cfg::CFG, code::Vector{Any}, info::Vector{CallInfo})
function strptime(fmt::AbstractString, timestr::AbstractString)
function structdiff(a::NamedTuple{an}, b::Union{NamedTuple{bn}, Type{NamedTuple{bn}}}) where {an, bn}
function structured_broadcast_alloc(bc, ::Type{Bidiagonal}, ::Type{ElType}, n) where {ElType}
function stupdate!(lattice::AbstractLattice, state::VarTable, changes::StateUpdate)
function stupdate!(lattice::AbstractLattice, state::VarTable, changes::VarTable)
function sub!(z::Rational{BigInt}, x::Rational{BigInt}, y::Rational{BigInt})
function sub2ind_gen(dims::NTuple{N,Int}, I::Integer...) where N
function sub2ind_gen_fallback(dims::NTuple{N,Int}, I) where N
function sub2ind_gen_impl(dims::Type{NTuple{N,Int}}, I...) where N
function sub_flag(newinst::NewInstruction, newflag::UInt32)
function sub_with_overflow(x::T, y::T) where T<:BrokenSignedInt
function sub_with_overflow(x::T, y::T) where T<:BrokenUnsignedInt
function subtract_singletontype(::Type{T}, x::Pair{K}) where {T, K}
function subtype_nothrow(ð•ƒ::AbstractLattice, lty, rty)
function subtype_tfunc(ð•ƒ::AbstractLattice, a, b)
function success(x::Process)
function sum(arr::AbstractArray{BigFloat})
function sum(r::AbstractRange{<:Real})
function sum(r::StepRangeLen)
function sum(r::StepRangeLen{<:Any,<:TwicePrecision,<:TwicePrecision})
function sum27403(X::AbstractArray)
function summarize(binding::Binding, sig)
function summarize(io::IO, TT::Type, binding::Binding)
function summarize(io::IO, m::Module, binding::Binding; nlines::Int = 200)
function summarize(io::IO, Î»::Function, binding::Binding)
function summary(io::IO, iter::T) where {T<:Union{KeySet,ValueIterator}}
function summary(io::IO, s::AbstractString)
function summary(io::IO, t::AbstractDict)
function summary(io::IO, t::AbstractSet)
function supertypes(T::Type)
function svd!(A::StridedMatrix{T}, B::StridedMatrix{T}) where T<:BlasFloat
function svd!(A::StridedMatrix{T}; full::Bool = false, alg::Algorithm = default_svd_alg(A)) where {T<:BlasFloat}
function svd!(A::StridedVector{T}; full::Bool = false, alg::Algorithm = default_svd_alg(A)) where {T<:BlasFloat}
function svd!(M::Bidiagonal{<:BlasReal}; full::Bool = false)
function svd(A::AbstractMatrix{TA}, B::AbstractMatrix{TB}) where {TA,TB}
function svd(A::AbstractVecOrMat{T}; full::Bool = false, alg::Algorithm = default_svd_alg(A)) where {T <: Union{Float16,Complex{Float16}}}
function svd(A::AbstractVecOrMat{T}; full::Bool = false, alg::Algorithm = default_svd_alg(A)) where {T}
function svd(A::Adjoint; full::Bool = false, alg::Algorithm = default_svd_alg(A))
function svd(A::RealHermSymComplexHerm; full::Bool=false)
function svd(A::Transpose; full::Bool = false, alg::Algorithm = default_svd_alg(A))
function svd(D::Diagonal{T}) where {T<:Number}
function svd(M::Bidiagonal; kw...)
function svd(x::Integer; full::Bool = false, alg::Algorithm = default_svd_alg(x))
function svd(x::Number; full::Bool = false, alg::Algorithm = default_svd_alg(x))
function svdvals!(A::RealHermSymComplexHerm)
function svdvals!(A::StridedMatrix{T}, B::StridedMatrix{T}) where T<:BlasFloat
function svdvals!(A::SymTridiagonal)
function svdvals(A::AbstractMatrix{TA}, B::AbstractMatrix{TB}) where {TA,TB}
function swapcols!(a::AbstractMatrix, i, j)
function swapfield!_tfunc(ð•ƒ::AbstractLattice, o, f, v)
function swapfield!_tfunc(ð•ƒ::AbstractLattice, o, f, v, order)
function swapproperty!(x, f::Symbol, v, order::Symbol=:not_atomic)
function swaprows!(a::AbstractMatrix, i, j)
function sylvester(A::AbstractMatrix, B::AbstractMatrix, C::AbstractMatrix)
function sylvester(A::AbstractMatrix{T}, B::AbstractMatrix{T}, C::AbstractMatrix{T}) where {T<:BlasFloat}
function sym_in(x::Symbol, itr::Tuple{Vararg{Symbol}})
function sym_uplo(uplo::Char)
function symbol_latex(s::String)
function symdiff!(s::AbstractSet, itr::AbstractSet)
function symdiff!(s::AbstractSet, itrs...)
function symdiff!(s::BitSet, ns)
function symdiff!(s::BitSet, ns::AbstractSet)
function symmetric_type(::Type{T}) where {S, T<:AbstractMatrix{S}}
function symmetric_type(::Type{T}) where {S<:AbstractMatrix, T<:AbstractMatrix{S}}
function symmetric_type(::Type{T}) where {S<:Number, T<:AbstractMatrix{S}}
function sympow(A::Symmetric, p::Integer)
function sync!(m::Array, flags::Integer=MS_SYNC)
function sync_end(c::Channel{Any})
function sync_end(c::Channel{Any})
function sync_rational!(xq::_MPQ)
function syr2k(uplo::AbstractChar, trans::AbstractChar, alpha::Number, A::AbstractVecOrMat, B::AbstractVecOrMat)
function syrk(uplo::AbstractChar, trans::AbstractChar, alpha::Number, A::AbstractVecOrMat)
function systemsleep(s::Real)
function tab_should_complete(s::MIState)
function tag_delete(repo::GitRepo, tag::AbstractString)
function tag_list(repo::GitRepo)
function tailjoin(A::SimpleVector, i::Int)
function take!(io::GenericIOBuffer)
function take!(io::IOBuffer)
function take_buffered(c::Channel)
function take_chunks(l::Parser, unescape::Bool)::String
function take_heap_snapshot(all_one::Bool=false; dir::Union{Nothing,S}=nothing) where {S <: AbstractString}
function take_heap_snapshot(filepath::String, all_one::Bool=false)
function take_heap_snapshot(io::IOStream, all_one::Bool=false)
function take_string_or_substring(l, contains_underscore)::SubString
function take_unbuffered(c::Channel{T}) where T
function tan(A::AbstractMatrix)
function tan(x::T) where T<:Union{Float32, Float64}
function tan(z::Complex)
function tan_kernel(y::DoubleFloat32, k)
function tan_kernel(y::DoubleFloat64, k)
function tanh(A::AbstractMatrix)
function tanh(x::T) where T<:Union{Float32, Float64}
function tanh(z::Complex{T}) where T
function tanh_kernel(x::Float32)
function tanh_kernel(x::Float64)
function tanpi(_x::T) where T<:IEEEFloat
function target!(ref::GitReference, new_oid::GitHash; msg::AbstractString="")
function target(tag::GitTag)
function task_done_hook(t::Task)
function task_local_storage(body::Function, key, val)
function tcgetattr(fd::RawFD, termios)
function tcsetattr(fd::RawFD, termios, mode::TCSETATTR_FLAGS = TCSADRAIN)
function tdiv_qr!(x::BigInt, y::BigInt, a::BigInt, b::BigInt)
function temp_cleanup_later(path::AbstractString; asap::Bool=false)
function temp_cleanup_purge( force::Bool=false)
function tempname(parent::AbstractString=tempdir; max_tries::Int = 100, cleanup::Bool=true)
function term(io::IO, br::HorizontalRule, columns)
function term(io::IO, content::Vector, cols)
function term(io::IO, f::Footnote, columns)
function term(io::IO, md::Admonition, columns)
function term(io::IO, md::BlockQuote, columns)
function term(io::IO, md::Code, columns)
function term(io::IO, md::Header{l}, columns) where l
function term(io::IO, md::List, columns)
function term(io::IO, md::Paragraph, columns)
function term(io::IO, md::Table, columns)
function term(io::IO, tex::LaTeX, columns)
function terminline(io::IO, code::Code)
function terminline(io::IO, content::Vector)
function terminline(io::IO, md::AbstractString)
function terminline(io::IO, md::Bold)
function terminline(io::IO, md::Image)
function terminline(io::IO, md::Italic)
function terminline(io::IO, md::LineBreak)
function terminline(io::IO, md::Link)
function terminline(io::IO, tex::LaTeX)
function test_13315(::Type{TestAbstractArray})
function test_UInt_indexing(::Type{TestAbstractArray})
function test_approx_eq_vecs(a::StridedVecOrMat{S}, b::StridedVecOrMat{T}, error=nothing) where {S<:Real,T<:Real}
function test_atomic_cas!(var::Atomic{T}, range::StepRange{Int,Int}) where T
function test_atomic_float(varadd::Atomic{T}, varmax::Atomic{T}, varmin::Atomic{T}, i::Int) where T
function test_atomic_read(commbuf::CommBuf, n::Int)
function test_atomic_write(commbuf::CommBuf, n::Int)
function test_atomic_xchg!(var::Atomic{T}, i::Int, accum::Atomic{Int}) where T
function test_cat(::Type{TestAbstractArray})
function test_copy_alias(::Type{T}) where T
function test_equivalence(n::Int)
function test_feature(features::Vector{UInt8}, feat::FeatureName)
function test_fence(p::Peterson, id::Int, n::Int)
function test_get(::Type{TestAbstractArray})
function test_getindex_internals(::Type{TestAbstractArray})
function test_getindex_internals(::Type{T}, shape, ::Type{TestAbstractArray}) where T
function test_in_bounds(::Type{TestAbstractArray})
function test_ind2sub(::Type{TestAbstractArray})
function test_inferred_static(arrow::Pair, all_ssa)
function test_inferred_static(expr::Expr)
function test_no_apply(expr::Expr)
function test_no_apply(ref::GlobalRef)
function test_overlong(c::Char, n::Integer, rep::String)
function test_primitives(::Type{T}, shape, ::Type{TestAbstractArray}) where T
function test_range_identity(r::AbstractRange{T}, mr) where T
function test_repr(x::String, remove_linenums::Bool = false)
function test_scalar_indexing(::Type{T}, shape, ::Type{TestAbstractArray}) where T
function test_setindex!_internals(::Type{TestAbstractArray})
function test_setindex!_internals(::Type{T}, shape, ::Type{TestAbstractArray}) where T
function test_sse(a1::V4xF32, a2::V4xF32, a3::V4xF32, a4::V4xF32)
function test_sse(a1::V4xI32, a2::V4xI32, a3::V4xI32, a4::V4xI32)
function test_stat_error(stat::Function, pth)
function test_struct1(::Type{Struct}) where {Struct}
function test_struct10(::Type{Struct}) where {Struct}
function test_struct11(::Type{Struct}) where {Struct}
function test_struct12(::Type{Struct}) where {Struct}
function test_struct13(::Type{Struct}) where {Struct}
function test_struct14(::Type{Struct}) where {Struct}
function test_struct15(::Type{Struct}) where {Struct}
function test_struct16(::Type{Struct}, quoteplz = false) where {Struct}
function test_struct17(::Type{Struct}) where {Struct}
function test_struct18(::Type{Struct}) where {Struct}
function test_struct4(::Type{Struct}) where {Struct}
function test_struct5(::Type{Struct}) where {Struct}
function test_struct6(::Type{Struct}) where {Struct}
function test_struct7(::Type{Struct}) where {Struct}
function test_struct8(::Type{Struct}) where {Struct}
function test_struct9(::Type{Struct}) where {Struct}
function test_struct_big(::Type{Struct}) where {Struct}
function test_success(proc::Process)
function test_threaded_atomic_minmax(m::T,n::T) where T
function test_uniform(xs::AbstractArray{T}) where {T<:AbstractFloat}
function test_uniform(xs::AbstractArray{T}) where {T<:Integer}
function test_vector_indexing(::Type{T}, shape, ::Type{TestAbstractArray}) where T
function testclosure(f, a::T, permanent::Bool=false, tt::Type{S}=Any) where {T, S}
function tex(stream::IO, md::MD)
function textwidth(c::AbstractChar)
function thing(a::AbstractArray, b::Int)
function thing(a::Array, b::Real)
function thisind(s::AbstractString, i::Int)
function thrash(handle::Ptr{Cvoid})
function threaded_add_locked(::Type{LockT}, x, n) where LockT
function threaded_gc_locked(::Type{LockT}) where LockT
function threadpoolsize(pool::Symbol = :default)
function threadpooltids(pool::Symbol)
function throw_complex_domainerror(f::Symbol, x)
function throw_complex_domainerror_neg1(f::Symbol, x)
function throw_eachindex_mismatch_indices(::IndexCartesian, inds...)
function throw_eachindex_mismatch_indices(::IndexLinear, inds...)
function throw_negative_refcount_error(x::Int)
function throwaxes1(S::Type, T::Type, ax1)
function throwbits(S::Type, T::Type, U::Type)
function throwintmult(S::Type, T::Type)
function thrownonint(S::Type, T::Type, dim)
function throws_matching_exception(f::Function, acceptable_exceptions::AbstractVector)
function throws_matching_uv_error(f::Function, pfx::AbstractString, codes::AbstractVector{<:Integer})
function throwsingleton(S::Type, T::Type)
function throwsize0(S::Type, T::Type, msg)
function throwsize1(a::AbstractArray, T::Type)
function time_print(io::IO, elapsedtime, bytes=0, gctime=0, allocs=0, compile_time=0, recompile_time=0, newline=false; msg::Union{String,Nothing}=nothing)
function timedwait(testcb, timeout::Real; pollint::Real=0.1)
function timev_print(elapsedtime, diff::GC_Diff, compile_times; msg::Union{String,Nothing}=nothing)
function titlecase(s::AbstractString; wordsep::Function = !isletter, strict::Bool=true)
function to_ieee754(::Type{T}, x::BigFloat, rm) where {T<:AbstractFloat}
function to_indices(A, inds, I::Tuple{Any, Vararg{Any}})
function to_toml_value(f::MbyFunc, value)
function toexpr(md::List)
function toexpr(md::Table)
function tofirst(dt::TimeType, dow::Int; of::Union{Type{Year}, Type{Month}}=Month)
function tohtml(io::IO, m::MIME"image/png", img)
function tohtml(io::IO, m::MIME"image/svg+xml", img)
function tohtml(io::IO, m::MIME, x)
function tohtml(io::IO, m::MIME, x)
function tolast(dt::TimeType, dow::Int; of::Union{Type{Year}, Type{Month}}=Month)
function tonext(func::Function, dt::TimeType; step::Period=Day1, limit::Int=10000, same::Bool=false)
function top(stack :: Stack)
function top_set_bit(x::BigInt)
function toprev(func::Function, dt::TimeType; step::Period=Day1, limit::Int=10000, same::Bool=false)
function touch(f::File)
function touch(path::AbstractString)
function tr(A::AbstractMatrix)
function tr(A::Matrix{T}) where T
function tr(J::UniformScaling{T}) where T
function trace_callback(level::Cint, msg::Cstring)::Cint
function trace_set(level::Union{Integer,Consts.GIT_TRACE_LEVEL}, cb=trace_cb)
function trailing_ones(x::BigInt)
function trailing_zeros(x::BigInt)
function trailingsize(inds::Indices)
function trailingsize(inds::Indices, n)
function transact(f::Function, repo::GitRepo)
function transcode(::Type{UInt16}, src::AbstractVector{UInt8})
function transcode(::Type{UInt8}, src::AbstractVector{UInt16})
function transcode(::Type{UInt8}, src::Vector{<:Union{Int32,UInt32}})
function transfer_progress(progress::Ptr{LibGit2.TransferProgress}, payload::Dict)
function transform!(ci::CodeInfo, nargs::Int, sparams::Core.SimpleVector)
function transform_expr(expr, map_slot_number, map_ssa_value, sparams::Core.SimpleVector)
function transition(f::Function, s::MIState, newmode::Union{TextInterface,Symbol})
function transition(f::Function, s::PrefixSearchState, mode::Prompt)
function transpose!(B::AbstractMatrix, A::AbstractVector)
function transpose!(B::AbstractVector, A::AbstractMatrix)
function transpose!(C::BitMatrix, B::BitMatrix)
function transpose8x8(x::UInt64)
function transpose_f!(f, B::AbstractMatrix, A::AbstractMatrix)
function transposeblock!(f, B::AbstractMatrix, A::AbstractMatrix, m::Int, n::Int, offseti::Int, offsetj::Int)
function tree!(root::StackFrameTree{T}, all::Vector{Alloc}, C::Bool, recur::Symbol) where {T}
function tree(io::IO, data::Vector{Alloc}, cols::Int, fmt::ProfileFormat)
function tree_format(frames::Vector{<:StackFrameTree}, level::Int, cols::Int, maxes, filenamemap::Dict{Symbol,String}, showpointer::Bool)
function treewalk(f, tree::GitTree, post::Bool = false)
function triangular_methodshow(x::T1, y::T2) where {T2<:Integer, T1<:T2}
function tridiag(T::Type, m::Integer, n::Integer)
function tril!(A::UnitLowerTriangular, k::Integer=0)
function tril!(A::UnitUpperTriangular{T}, k::Integer=0) where {T}
function tril!(A::UpperTriangular{T}, k::Integer=0) where {T}
function tril!(D::Diagonal{T}, k::Integer=0) where T
function tril!(M::AbstractMatrix, k::Integer)
function tril!(M::Bidiagonal{T}, k::Integer=0) where T
function tril!(M::SymTridiagonal{T}, k::Integer=0) where T
function tril!(M::Tridiagonal{T}, k::Integer=0) where T
function tril(A::Hermitian, k::Integer=0)
function tril(A::Symmetric, k::Integer=0)
function tril(B::BitMatrix, k::Integer=0)
function trim_after_eval(str::AbstractString)
function trimdocs(md::Markdown.MD, brief::Bool)
function triplet(p::AbstractPlatform)
function triu!(A::LowerTriangular{T}, k::Integer=0) where {T}
function triu!(A::UnitLowerTriangular{T}, k::Integer=0) where T
function triu!(A::UnitUpperTriangular, k::Integer=0)
function triu!(D::Diagonal{T}, k::Integer=0) where T
function triu!(M::AbstractMatrix, k::Integer)
function triu!(M::Bidiagonal{T}, k::Integer=0) where T
function triu!(M::SymTridiagonal{T}, k::Integer=0) where T
function triu!(M::Tridiagonal{T}, k::Integer=0) where T
function triu(A::Hermitian, k::Integer=0)
function triu(A::Symmetric, k::Integer=0)
function triu(B::BitMatrix, k::Integer=0)
function truncate(f::File, n::Integer)
function truncate(io::GenericIOBuffer, n::Integer)
function truncate(s::IOStream, n::Integer)
function truncated(::Type{R}, x::RawBigInt, len::Int) where {R<:Integer}
function truncbits(x::F, nb) where {F<:IEEEFloat}
function truncbits(x::Float64)
function truncmask(x::F, mask) where {F<:IEEEFloat}
function trylisten(sock::LibuvServer; backlog::Integer=BACKLOG_DEFAULT)
function trylock(f, l::AbstractLock)
function trylock(l::SpinLock)
function trylock(rl::ReentrantLock)
function tryopen_exclusive(path::String, mode::Integer = 0o444)
function tryparse(::Type{BigFloat}, s::AbstractString; base::Integer=0, precision::Integer=DEFAULT_PRECISION[], rounding::MPFRRoundingMode=ROUNDING_MODE[])
function tryparse(::Type{Float32}, s::String)
function tryparse(::Type{Float32}, s::SubString{String})
function tryparse(::Type{Float64}, s::String)
function tryparse(::Type{Float64}, s::SubString{String})
function tryparse(::Type{SHA1}, s::AbstractString)
function tryparse(::Type{T}, s::AbstractString; base::Union{Nothing,Integer} = nothing) where {T<:Integer}
function tryparse(::Type{VersionNumber}, v::AbstractString)
function tryparse(l::Parser)::Err{TOMLDict}
function tryparse_internal(::Type{BigInt}, s::AbstractString, startpos::Int, endpos::Int, base_::Integer, raise::Bool)
function tryparse_internal(::Type{Complex{T}}, s::Union{String,SubString{String}}, i::Int, e::Int, raise::Bool) where {T<:Real}
function tryparse_internal(::Type{Float32}, s::String, startpos::Int, endpos::Int)
function tryparse_internal(::Type{Float32}, s::SubString{String}, startpos::Int, endpos::Int)
function tryparse_internal(::Type{Float64}, s::String, startpos::Int, endpos::Int)
function tryparse_internal(::Type{Float64}, s::SubString{String}, startpos::Int, endpos::Int)
function tryparse_internal(::Type{T}, s::AbstractString, raise::Bool; kwargs...) where T<:Real
function tryparse_internal(::Type{T}, s::AbstractString, startpos::Int, endpos::Int, base_::Integer, raise::Bool) where T<:Integer
function tryparse_internal(::Type{T}, s::AbstractString, startpos::Int, endpos::Int, raise::Bool) where T<:Real
function tryparsenext(d::AbstractDateToken, str, i, len, locale)
function tryparsenext(d::DatePart{'s'}, str, i, len)
function tryparsenext(d::Delim{<:AbstractChar, N}, str, i::Int, len) where N
function tryparsenext(d::Delim{String, N}, str, i::Int, len) where N
function tryparsenext_base10(str::AbstractString, i::Int, len::Int, min_width::Int=1, max_width::Int=0)
function tryparsenext_word(str::AbstractString, i, len, locale, maxchars=0)
function trypoptask(W::StickyWorkqueue)
function tryrmopenfile(path::String)
function ttt7049(init::Maybe7049{Union{AbstractString,Tuple{Int,Char}}} = nothing)
function tuple_tfunc(ð•ƒ::AbstractLattice, argtypes::Vector{Any})
function tuple_type_cons(::Type{S}, ::Type{T}) where T<:Tuple where S
function tuple_type_tail(T::Type)
function tuplemerge(a::DataType, b::DataType)
function twice_sitofp(x::Int, y::Int)
function twiceprecision(val::T, nb::Integer) where {T<:IEEEFloat}
function twiceprecision(val::TwicePrecision{T}, nb::Integer) where {T<:IEEEFloat}
function twiceprecision_is_normalized(tw::Tw) where {Tw<:Base.TwicePrecision}
function two_breakpoint(a::Float64)
function two_mul(x::T, y::T) where {T<:Number}
function twomul(a::Float64, b::Float64)
function type_annotate!(interp::AbstractInterpreter, sv::InferenceState)
function type_depth_limit(str::String, n::Int; maxdepth = nothing)
function type_limited_string_from_context(out::IO, str::String)
function typeassert_nothrow(ð•ƒ::AbstractLattice, v, t)
function typeassert_tfunc(ð•ƒ::AbstractLattice, v, t)
function typed_hvcat(::Type{T}, rows::Tuple{Vararg{Int}}, as...) where T
function typed_hvcat(::Type{T}, rows::Tuple{Vararg{Int}}, as::AbstractVecOrMat...) where T
function typed_hvcat(::Type{T}, rows::Tuple{Vararg{Int}}, xs::Number...) where T
function typeinf(interp::AbstractInterpreter, result::InferenceResult, cache_mode::Symbol)
function typeinf(interp::NativeInterpreter, frame::InferenceState)
function typeinf_code(interp::AbstractInterpreter, mi::MethodInstance, run_optimizer::Bool)
function typeinf_ext(interp::AbstractInterpreter, mi::MethodInstance)
function typeinf_ext_toplevel(interp::AbstractInterpreter, mi::MethodInstance)
function typeinf_frame(interp::AbstractInterpreter, mi::MethodInstance, run_optimizer::Bool)
function typeinf_local(interp::AbstractInterpreter, frame::InferenceState)
function typeinf_nocycle(interp::AbstractInterpreter, frame::InferenceState)
function typeinfo_prefix(io::IO, X)
function typejoin_union_tuple(T::DataType)
function typemax(::Type{VersionNumber})
function typename(a::Union)
function typeof_concrete_vararg(t::DataType)
function typeof_tfunc(ð•ƒ::AbstractLattice, t)
function typevar_nothrow(ð•ƒ::AbstractLattice, n, lb, ub)
function typevar_tfunc(ð•ƒ::AbstractLattice, n, lb_arg, ub_arg)
function uint_map!(v::AbstractVector, lo::Integer, hi::Integer, order::Ordering)
function umul256(a::UInt128, bHi::UInt64, bLo::UInt64)
function unaliascopy(V::SubArray{T,N,A,I,LD}) where {T,N,A<:Array,I<:Tuple{Vararg{Union{Real,AbstractRange,Array}}},LD}
function unbiased_exponent(x::T) where {T<:IEEEFloat}
function unconstrain_vararg_length(va::Core.TypeofVararg)
function undeclared_ceil(x::Float64)
function underscore_bold(stream::IO, md::MD)
function underscore_italic(stream::IO, md::MD)
function undot(x::Expr)
function unescape_string(io::IO, s::AbstractString, keep = )
function unexpected_assignment!(ir::IRCode, pc::Int)
function unindent(str::AbstractString, indent::Int; tabwidth=8)
function union!(s::AbstractSet, sets...)
function union!(s::AbstractSet{T}, itr) where T
function union!(s::BitSet, itr)
function union!(s::BitSet, r::AbstractUnitRange{<:Integer})
function union!(s::IntDisjointSet{T}, x::T, y::T) where {T<:Integer}
function union_caller_cycle!(a::InferenceState, b::InferenceState)
function union_causes(causesa::IdSet{InferenceState}, causesb::IdSet{InferenceState})
function unionsplitcost(ð•ƒ::AbstractLattice, argtypes::Union{SimpleVector,Vector{Any}})
function unique!(f, A::AbstractVector; seen::Union{Nothing,Set}=nothing)
function unique(f, C; seen::Union{Nothing,Set}=nothing)
function unique_from(itr, out::Vector{T}, seen, i) where T
function unlink(p::AbstractString)
function unlock(l::SpinLock)
function unlock(rl::ReentrantLock)
function unlockall(rl::ReentrantLock)
function unmark(io::IO)
function unreference_module(key::PkgId)
function unsafe_SecretBuffer!(p::Ptr{UInt8}, len=1)
function unsafe_SecretBuffer!(s::Cstring)
function unsafe_bitfindnext(Bc::Vector{UInt64}, start::Int)
function unsafe_bitfindprev(Bc::Vector{UInt64}, start::Int)
function unsafe_bitgetindex(Bc::Vector{UInt64}, i::Int)
function unsafe_bitsetindex!(Bc::Array{UInt64}, x::Bool, i::Int)
function unsafe_convert(::Type{Cstring}, s::String)
function unsafe_convert(::Type{Ptr{Any}}, b::RefArray{Any})::Ptr{Any}
function unsafe_convert(::Type{Ptr{Any}}, b::RefValue{Any})::Ptr{Any}
function unsafe_convert(::Type{Ptr{Cvoid}}, a::GenericMemoryRef{<:Any,T,Core.CPU}) where {T}
function unsafe_convert(::Type{Ptr{R}}, s::SubString{String}) where R<:Union{Int8, UInt8}
function unsafe_convert(::Type{Ptr{S}}, V::SubArray{T,N,P,<:Tuple{Vararg{Union{RangeIndex,ReshapedUnitRange}}}}) where {S,T,N,P}
function unsafe_convert(P::Union{Type{Ptr{T}},Type{Ptr{Cvoid}}}, b::RefArray{T})::P where T
function unsafe_convert(P::Union{Type{Ptr{T}},Type{Ptr{Cvoid}}}, b::RefValue{T})::P where T
function unsafe_copyto!(dest::Array, doffs, src::Array, soffs, n)
function unsafe_copyto!(dest::BitArray, doffs::Integer, src::Union{BitArray,Array}, soffs::Integer, n::Integer)
function unsafe_copyto!(dest::GenericMemoryRef, src::GenericMemoryRef, n)
function unsafe_copyto!(dest::Memory, doffs, src::Memory, soffs, n)
function unsafe_copyto!(dest::MemoryRef{T}, src::MemoryRef{T}, n) where {T}
function unsafe_copyto!(dest::Memory{T}, doffs, src::Memory{T}, soffs, n) where{T}
function unsafe_copyto!(dest::Ptr{T}, src::Ptr{T}, n) where T
function unsafe_getindex(r::StepRangeLen{T,<:TwicePrecision,<:TwicePrecision}, i::Integer) where T
function unsafe_getindex(r::StepRangeLen{T}, i::Integer) where T
function unsafe_load(p::Ptr, i::Integer, order::Symbol)
function unsafe_load_commands(v::Ptr{Ptr{UInt8}})
function unsafe_modify!(p::Ptr, op, x, order::Symbol=:not_atomic)
function unsafe_read(f::File, p::Ptr{UInt8}, nel::UInt)
function unsafe_read(from::GenericIOBuffer, p::Ptr{UInt8}, nb::UInt)
function unsafe_read(s::BufferStream, a::Ptr{UInt8}, nb::UInt)
function unsafe_read(s::IO, p::Ptr{UInt8}, n::UInt)
function unsafe_read(s::IOStream, p::Ptr{UInt8}, nb::UInt)
function unsafe_read(s::LibuvStream, p::Ptr{UInt8}, nb::UInt)
function unsafe_replace!(p::Ptr{T}, expected, desired, success_order::Symbol=:not_atomic, fail_order::Symbol=success_order) where {T}
function unsafe_setindex!(A::AbstractArray, v, I...)
function unsafe_store!(p::Ptr, x, i::Integer, order::Symbol)
function unsafe_string(cw::Cwstring)
function unsafe_string(p::Ptr{T}, length::Integer) where {T<:Union{UInt16,UInt32,Cwchar_t}}
function unsafe_string(p::Union{Ptr{UInt8},Ptr{Int8}})
function unsafe_string(p::Union{Ptr{UInt8},Ptr{Int8}}, len::Integer)
function unsafe_swap!(p::Ptr{Any}, x, order::Symbol=:not_atomic)
function unsafe_swap!(p::Ptr{T}, x, order::Symbol=:not_atomic) where {T}
function unsafe_trunc(::Type{Int128}, x::Float32)
function unsafe_trunc(::Type{Int128}, x::Float64)
function unsafe_trunc(::Type{UInt128}, x::Float32)
function unsafe_trunc(::Type{UInt128}, x::Float64)
function unsafe_view(A::AbstractArray, I::Vararg{ViewIndex,N}) where {N}
function unsafe_write(f::File, buf::Ptr{UInt8}, len::UInt, offset::Int64=Int64(-1))
function unsafe_write(s::BufferStream, p::Ptr{UInt8}, nb::UInt)
function unsafe_write(s::IO, p::Ptr{UInt8}, n::UInt)
function unsafe_write(s::IOStream, p::Ptr{UInt8}, nb::UInt)
function unsafe_write(s::LibuvStream, p::Ptr{UInt8}, n::UInt)
function unsafe_write(to::GenericIOBuffer, p::Ptr{UInt8}, nb::UInt)
function unset!(trie::HAMT, bi::BitmapIndex)
function unwatch_folder(s::String)
function unwrap_macrocalls(ex::Expr)
function unwrap_task_failed(f::Function, t::UnwrapTaskFailedException)
function update!(idx::GitIndex, files::AbstractString...)
function update!(repo::GitRepo, files::AbstractString...)
function update23685!(::Node23685{T}) where T
function update_bbstate!(ð•ƒáµ¢::AbstractLattice, frame::InferenceState, bb::Int, vartable::VarTable)
function update_display_buffer(s::SearchState, data::ModeState)
function update_key_repeats(s::MIState, keystroke::Vector{Char})
function update_level!(nodes::Vector{DomTreeNode}, node::BBNumber, level::Int)
function update_phi!(irsv::IRInterpretationState, from::Int, to::Int)
function update_valid_age!(sv::AbsIntState, valid_worlds::WorldRange)
function updated_methodloc(m::Method)::Tuple{String, Int32}
function uppercasefirst(s::AbstractString)
function upstream(ref::GitReference)
function url(m::Method)
function url(rmt::GitRemote)
function use_http_path(cfg::GitConfig, cred::GitCredential)
function utf8proc_decompose(str, options, buffer, nwords, chartransform::T) where T
function utf8proc_decompose(str, options, buffer, nwords, chartransform::typeof(identity))
function utf8proc_map(str::Union{String,SubString{String}}, options::Integer, chartransform=identity)
function uuid1(rng::AbstractRNG=Random.RandomDevice)
function uuid4(rng::AbstractRNG=Random.RandomDevice)
function uuid5(namespace::UUID, key::String)
function uuid5(ns::UUID, name::String)
function uv_alloc_buf(handle::Ptr{Cvoid}, size::Csize_t, buf::Ptr{Cvoid})
function uv_asynccb(handle::Ptr{Cvoid})
function uv_connectcb(conn::Ptr{Cvoid}, status::Cint)
function uv_connectioncb(stream::Ptr{Cvoid}, status::Cint)
function uv_fseventscb_file(handle::Ptr{Cvoid}, filename::Ptr, events::Int32, status::Int32)
function uv_fseventscb_folder(handle::Ptr{Cvoid}, filename::Ptr, events::Int32, status::Int32)
function uv_fspollcb(handle::Ptr{Cvoid}, status::Int32, prev::Ptr, curr::Ptr)
function uv_getaddrinfocb(req::Ptr{Cvoid}, status::Cint, addrinfo::Ptr{Cvoid})
function uv_getnameinfocb(req::Ptr{Cvoid}, status::Cint, hostname::Cstring, service::Cstring)
function uv_pollcb(handle::Ptr{Cvoid}, status::Int32, events::Int32)
function uv_readcb(handle::Ptr{Cvoid}, nread::Cssize_t, buf::Ptr{Cvoid})
function uv_recvcb(handle::Ptr{Cvoid}, nread::Cssize_t, buf::Ptr{Cvoid}, addr::Ptr{Cvoid}, flags::Cuint)
function uv_ref(h::Ptr{Cvoid})
function uv_return_spawn(p::Ptr{Cvoid}, exit_status::Int64, termsignal::Int32)
function uv_shutdowncb_task(req::Ptr{Cvoid}, status::Cint)
function uv_timercb(handle::Ptr{Cvoid})
function uv_unref(h::Ptr{Cvoid})
function uv_write(s::LibuvStream, p::Ptr{UInt8}, n::UInt)
function uv_write_async(s::LibuvStream, p::Ptr{UInt8}, n::UInt)
function uv_writecb_task(req::Ptr{Cvoid}, status::Cint)
function uvfinalize(proc::Process)
function uvfinalize(t::Union{Timer, AsyncCondition})
function uvfinalize(t::_FDWatcher)
function uvfinalize(uv::Union{FileMonitor, FolderMonitor, PollingFileWatcher})
function uvfinalize(uv::Union{LibuvStream, LibuvServer})
function v6387(r::AbstractRange{T}) where T
function val_for_def_expr(ir::IRCode, def::Int, fidx::Int)
function validargs(::Type{Date}, y::Int64, m::Int64, d::Int64)
function validargs(::Type{Time}, h::Int64, mi::Int64, s::Int64, ms::Int64, us::Int64, ns::Int64, ampm::AMPM=TWENTYFOURHOUR)
function validate_code!(errors::Vector{InvalidCodeError}, c::CodeInfo, is_top_level::Bool = false)
function validate_code!(errors::Vector{InvalidCodeError}, mi::Core.MethodInstance, c::Union{Nothing,CodeInfo})
function validate_code_in_debug_mode(linfo::MethodInstance, src::CodeInfo, kind::String)
function validate_sparams(sparams::SimpleVector)
function validate_tags(tags::Dict)
function varinfo(m::Module=Base.active_module, pattern::Regex; all::Bool = false, imported::Bool = false, recursive::Bool = false, sortby::Symbol = :name, minsize::Int=0)
function vcat(A::BitMatrix...)
function vcat(V::BitVector...)
function vcat(arrays::Vector{T}...) where T
function vcat(rs::AbstractRange{T}...) where T
function vec_pointer_stride(x::AbstractArray, stride0check = nothing)
function vect(X::T...) where T
function verify_host_error(message::AbstractString)
function verify_linetable(linetable::Vector{LineInfoNode}, print::Bool=true)
function version_slug(uuid::UUID, sha1::SHA1, p::Int=5)
function versioninfo(io::IO=stdout)
function versioninfo(io::IO=stdout; verbose::Bool=false)
function view(A::AbstractArray{<:Any,N}, I::Vararg{Any,M}) where {N,M}
function view(r1::AbstractRange, c::Colon)
function view(r1::AbstractUnitRange, r2::AbstractUnitRange{<:Integer})
function view(r1::AbstractUnitRange, r2::StepRange{<:Integer})
function view(r1::LinRange, r2::OrdinalRange{<:Integer})
function view(r1::OneTo, r2::OneTo)
function view(r1::StepRange, r2::AbstractRange{<:Integer})
function view(r1::StepRangeLen, r2::OrdinalRange{<:Integer})
function visit!(bb::Int)
function visit!(bb::Int)
function visit(f, d::Core.TypeMapEntry)
function visit(f, mc::Core.TypeMapLevel)
function visit(f, mt::Core.MethodTable)
function visit_bb_phis!(callback, ir::IRCode, bb::Int)
function wait(c::Channel)
function wait(c::GenericCondition; first::Bool=false)
function wait(e::Event)
function wait(fd::RawFD, mask::FDEvent)
function wait(fdw::FDWatcher)
function wait(fdw::_FDWatcher, mask::FDEvent)
function wait(fdw::_FDWatcher; readable=true, writable=true)
function wait(m::FileMonitor)
function wait(m::FolderMonitor)
function wait(pfw::PollingFileWatcher)
function wait(socket::RawFD; readable=false, writable=false)
function wait(socket::WindowsRawSocket, mask::FDEvent)
function wait(socket::WindowsRawSocket; readable=false, writable=false)
function wait(t::Task)
function wait(t::Union{Timer, AsyncCondition})
function wait(x::Process)
function wait_close(s::BufferStream)
function wait_close(x::Union{LibuvStream, LibuvServer})
function wait_connected(x::LibuvStream)
function wait_done(itr::AsyncCollector, state::AsyncCollectorState)
function wait_readnb(s::BufferStream, nb::Int)
function wait_readnb(x::LibuvStream, nb::Int)
function waitkill(P::Union{Process,ProcessChain})
function watch_file(s::String, timeout_s::Float64=-1.0)
function watch_folder(s::String, timeout_s::Real=-1)
function where1090(x::Array{T})::T where T<:Real
function which(m::Module, s::Symbol)
function which(program_name::String)
function widemul(u::Int64, v::Int64)
function widemul(u::UInt64, v::UInt64)
function widen_all_consts!(src::CodeInfo)
function winuppercase(s::AbstractString)
function with(f, pair::Pair{<:ScopedValue}, rest::Pair{<:ScopedValue}...)
function with(f::Function, obj)
function with_artifacts_directory(f::Function, artifacts_dir::String)
function with_raw_tty(f::Function, input::TTY)
function with_repl_linfo(f, repl::LineEditREPL)
function with_self_aliased(from_bb::Int, succs::Vector{Int})
function with_temp_cleanup(f::Function, n::Int)
function with_ulimit(f::Function, stacksize::Int)
function with_warn(f::Function, ::Type{T}, args...) where T
function withenv(f, keyvals::Pair{T}...) where T<:AbstractString
function withtag(f, io::IO, tag, attrs...)
function workdir(repo::GitRepo)
function workqueue_for(tid::Int)
function worlds(mi::Core.MethodInstance)
function wrapped_line(io::IO, s::AbstractString, width, i)
function wrapped_lines(io::IO, s::AbstractString; width = 80, i = 0)
function write!(idx::GitIndex)
function write(io::IO, c::Char)
function write(io::IO, s::SecretBuffer)
function write(io::IO, s::Symbol)
function write(io::IO, x1, xs...)
function write(io::IO, x::String)
function write(io::SecretBuffer, b::UInt8)
function write(s::IO, A::AbstractArray)
function write(s::IO, A::StridedArray)
function write(s::IO, x::Ref{T}) where {T}
function write(s::IO, x::Union{Int16,UInt16,Int32,UInt32,Int64,UInt64,Int128,UInt128,Float16,Float32,Float64})
function write(s::IO, z::Complex)
function write(s::IO, z::Rational)
function write(s::IOStream, b::UInt8)
function write(s::LibuvStream, b::UInt8)
function write(to::GenericIOBuffer, a::UInt8)
function write(to::IO, from::GenericIOBuffer)
function write(to::IO, from::IO)
function writeLine(buf::IOBuffer, m::AbstractMenu, idx::Int, cursor::Bool)
function writeLine(buf::IOBuffer, menu::RadioMenu{<:Dict}, idx::Int, cursor::Bool)
function write_as_tag(s::IO, tag)
function write_output_prefix(io::IO, p::Prompt, color::Bool)
function write_pidfile(io::IO, pid::Cint)
function write_prompt(terminal::AbstractTerminal, p::Prompt, color::Bool)
function write_prompt(terminal::Union{IO, AbstractTerminal}, s::Union{AbstractString,Function}, color::Bool)
function write_tree!(idx::GitIndex)
function writeheader(s::AbstractSerializer)
function writeline(buf::IO, m::AbstractMenu, idx::Int, iscursor::Bool)
function writeline(buf::IOBuffer, menu::MultiSelectMenu{MultiSelectConfig}, idx::Int, iscursor::Bool)
function writeline(buf::IOBuffer, menu::RadioMenu{Config}, idx::Int, iscursor::Bool)
function writeline(buf::IOBuffer, pager::Pager{Config}, idx::Int, iscursor::Bool)
function xoshiro_bulk(rng::Union{TaskLocalRNG, Xoshiro}, dst::Ptr{UInt8}, len::Int, T::Union{Type{UInt8}, Type{Bool}, Type{Float32}, Type{Float64}}, ::Val{N}, f::F = _id) where {N, F}
function xoshiro_bulk_nosimd(rng::Union{TaskLocalRNG, Xoshiro}, dst::Ptr{UInt8}, len::Int, ::Type{Bool}, f)
function xoshiro_bulk_simd(rng::Union{TaskLocalRNG, Xoshiro}, dst::Ptr{UInt8}, len::Int, ::Type{Bool}, ::Val{N}, f) where {N}
function xoshiro_bulk_simd(rng::Union{TaskLocalRNG, Xoshiro}, dst::Ptr{UInt8}, len::Int, ::Type{T}, ::Val{N}, f::F) where {T,N,F}
function zero(::Type{TwicePrecision{T}}) where {T}
function axes(a::NonReshapedReinterpretArray{T,N,S} where {N}) where {T,S}
function axes(a::ReshapedReinterpretArray{T,N,S} where {N}) where {T,S}
function axpby!(alpha::Number, x::AbstractArray{T}, beta::Number, y::AbstractArray{T}) where T<:BlasFloat
function axpy!(alpha::Number, x::AbstractArray{T}, y::AbstractArray{T}) where T<:BlasFloat
function axpy!(Î±, x::AbstractArray, rx::AbstractArray{<:Integer}, y::AbstractArray, ry::AbstractArray{<:Integer})
